{"version":3,"file":"98.bundle.js","mappings":"oPAYA,MAAMA,EACJ,WAAAC,GACEC,KAAKC,aAAe,CACtB,CACA,aAAAC,CAAcC,GACZ,MAAMC,EAAgB,IAAIC,EAAA,EAAa,CACrCC,iBAAkB,CAAEC,MAAO,IAAIC,EAAA,EAAUC,KAAM,eAC/CC,OAAQ,CAAEH,MAAO,IAAII,aAAa,CAAC,EAAG,EAAG,EAAG,IAAKF,KAAM,aACvDG,OAAQ,CAAEL,MAAO,EAAGE,KAAM,SAE5BT,KAAKC,aAAeE,EAASU,OAAOC,qBACpC,MAAMC,GAAa,OAA4B,CAC7CC,KAAM,WACNC,KAAM,CACJC,EAAA,GACA,EAAAC,EAAA,GAAwBnB,KAAKC,cAC7BmB,EAAA,GACAC,EAAA,KAGJrB,KAAKsB,OAAS,IAAIC,EAAA,EAAO,CACvBR,aACAS,UAAW,CAETpB,kBAGN,CACA,OAAAqB,CAAQC,EAAcC,GACpB,MAAMC,EAAUD,EAAWC,QACrBN,EAASM,EAAQC,cAAgB7B,KAAKsB,OACtCnB,EAAWuB,EAAavB,SACxB2B,EAAgB3B,EAAS4B,iBACzB,QACJC,EAAO,aACPC,GACEH,EAAcI,qBAAqBN,GACjCO,EAAUhC,EAASgC,QACzBA,EAAQC,YAAYJ,EAAQK,SAAUf,EAAOP,YAC7C,MAAMuB,EAA0BnC,EAASoC,eAAeC,UACxDL,EAAQM,aAAa,EAAGH,EAAyBhB,EAAOP,YACxD,MAAM2B,EAAiBvC,EAASwC,YAAYC,aAAaC,oBAAoBvB,EAAOE,UAAUpB,eAAe,GAC7G+B,EAAQM,aAAa,EAAGC,EAAgBpB,EAAOP,YAC/C,MAAM+B,EAAUb,EAAaA,aAC7B,IAAIc,EAAW,KACf,IAAK,IAAIC,EAAI,EAAGA,EAAIf,EAAagB,gBAAiBD,IAAK,CACrD,MAAME,EAAQJ,EAAQE,GAWtB,GAVIE,EAAMH,WAAaA,IACrBA,EAAWG,EAAMH,SACjBZ,EAAQgB,uCACNnB,EAAQK,SACRf,EAAOP,WACPW,EAAa0B,MACbF,EAAMH,WAGVzB,EAAO+B,OAAO,GAAKH,EAAMV,WACpBU,EAAMI,aAAc,CACvB,MAAMC,EAAeL,EAAMM,SAC3BN,EAAMV,WAAY,EAAAiB,EAAA,GAChBF,EAAaC,SACbD,EAAaG,MACb1D,KAAKC,cAEPiD,EAAMI,aAAenD,EAASqC,UAAUmB,aACtCT,EAAMV,UACNlB,EAAOP,WACP,EAEJ,CACAoB,EAAQM,aAAa,EAAGS,EAAMV,UAAWlB,EAAOP,YAChDoB,EAAQyB,kBAAkBC,YAAYX,EAAMY,KAAM,EAAGZ,EAAMa,MAC7D,CACF,CACA,OAAAC,GACEhE,KAAKsB,OAAO0C,SAAQ,GACpBhE,KAAKsB,OAAS,IAChB,EAGFxB,EAAmBmE,UAAY,CAC7BxD,KAAM,CACJ,KAAcyD,oBAEhBlD,KAAM,Y,iCCrFR,MAAMmD,EACJ,IAAAC,GACE,MAAMrD,GAAa,OAA4B,CAC7CC,KAAM,OACNC,KAAM,CACJG,EAAA,GACAiD,EAAA,EACAhD,EAAA,KAGJrB,KAAKsE,QAAU,IAAI/C,EAAA,EAAO,CACxBR,aACAS,UAAW,CACT+C,SAAUC,EAAA,EAAQC,MAAMC,QACxBC,SAAUH,EAAA,EAAQC,MAAMC,QAAQE,MAChCC,gBAAiB,CACfC,eAAgB,CAAErE,KAAM,cAAeF,MAAO,IAAIC,EAAA,MAI1D,CACA,OAAAiB,CAAQsD,EAAUC,GAChB,MAAM7E,EAAW4E,EAAS5E,SAC1B,IAAImB,EAAS0D,EAAKV,QAClB,GAAKhD,GAGE,IAAKA,EAAOP,WAEjB,YADA,EAAAkE,EAAA,GAAK,gCAAiCD,EAAK1D,aAH3CA,EAAStB,KAAKsE,QACdhD,EAAO+B,OAAO,GAAKlD,EAAS+E,QAAQC,oBAAoBH,EAAKE,SAK/D,MAAMnE,EAAaO,EAAOP,WAI1B,GAHIA,EAAWqE,2BACb9D,EAAO+B,OAAO,GAAKlD,EAASoC,eAAeC,WAEzCzB,EAAWsE,wBAAyB,CACtC,MAAMjF,EAAgB2E,EAAS3E,cAC/BkB,EAAO+B,OAAO,GAAKlD,EAASwC,YAAYC,aAAaC,oBAAoBzC,GAAe,EAC1F,CACAD,EAASgC,QAAQmD,KAAK,CACpBjD,SAAU2C,EAAKO,UACfjE,SACA8B,MAAO4B,EAAK5B,OAEhB,CACA,OAAAY,GACEhE,KAAKsE,QAAQN,SAAQ,GACrBhE,KAAKsE,QAAU,IACjB,EAGFH,EAAeF,UAAY,CACzBxD,KAAM,CACJ,KAAcyD,oBAEhBlD,KAAM,Q,cC7DR,MAAMwE,EAAYC,EAAA,EAAMC,QACxB,MAAMC,EACJ,KAAA5B,CAAM6B,EAAWvD,EAAUf,GACzB,MAAMnB,EAAWyF,EAAUzF,SACrBgC,EAAUhC,EAASgC,QACnB0D,EAAUvE,EAAOP,WACvBf,KAAKsE,QAAUhD,EACftB,KAAKuF,UAAYlD,EACjBF,EAAQC,YAAYC,EAAUwD,GAC9BL,EAAUM,UAAY,SACtB3F,EAAS4F,SAASC,YAChB3D,EACAwD,EACAL,GAEF,MAAMlD,EAA0BnC,EAASoC,eAAeC,UACxDL,EAAQ8D,eAAe,GACvB9D,EAAQM,aAAa,EAAGH,EAAyBuD,EACnD,CACA,OAAApE,CAAQmE,EAAW1C,GACjB,MAAM2C,EAAU7F,KAAKsE,QAAQvD,WACvBZ,EAAWyF,EAAUzF,SACrBgC,EAAUhC,EAASgC,QACzB,IAAKe,EAAMV,UAAW,CACpB,MAAMe,EAAeL,EAAMM,SAC3BN,EAAMV,WAAY,EAAAiB,EAAA,GAChBF,EAAaC,SACbD,EAAaG,MACbvD,EAASU,OAAOC,qBAEpB,CACA0E,EAAUM,UAAY5C,EAAM4C,UAC5B,MAAMxC,EAAenD,EAASqC,UAAUmB,aACtCT,EAAMV,UACNqD,EACA,GAEIE,EAAW5F,EAAS4F,SAASC,YACjChG,KAAKuF,UACLM,EACAL,EACAtC,EAAMH,UAERG,EAAMV,UAAU0D,OAAO/F,EAASgG,GAAGC,IAAKjG,EAASkG,MACjDlE,EAAQmE,YAAYP,GACpB5D,EAAQyB,kBAAkBnB,aAAa,EAAGa,GAC1CnB,EAAQyB,kBAAkBC,YAAYX,EAAMY,KAAM,EAAGZ,EAAMa,MAC7D,EAGF4B,EAAgB1B,UAAY,CAC1BxD,KAAM,CACJ,KAAcyD,oBAEhBlD,KAAM,S,iCCxDR,MAAMuF,EACJ,WAAAxG,CAAYI,GACVH,KAAKwG,MAAwBC,OAAOC,OAAO,MAC3C1G,KAAK2G,UAAYxG,CACnB,CACA,aAAAD,CAAc0G,GACZ5G,KAAK6G,KAAOD,CACd,CACA,YAAAjD,CAAanB,EAAWqD,EAASiB,GAG/B,OAFAtE,EAAUuE,aACW/G,KAAKwG,MAAMhE,EAAUwE,OAAShH,KAAKiH,iBAAiBzE,EAAWqD,EAASiB,EAE/F,CACA,gBAAAG,CAAiBC,EAAOrB,EAASiB,GAC/B,MAAMK,EAASnH,KAAK6G,KAAKM,OACnBC,EAAcvB,EAAQwB,OAAOP,GAC7BQ,EAAU,GACVnH,EAAWH,KAAK2G,UACtB,IAAK,MAAMY,KAAKH,EAAa,CAC3B,MAAMI,EAAWN,EAAM1F,UAAU+F,IAAML,EAAM1F,UAAU4F,EAAYG,IACnE,IAAIE,EACJ,GAA+B,iBAA3BD,EAASE,cAAkC,CAC7C,MAAMC,EAAeH,EACrBrH,EAASyH,IAAIC,mBAAmBF,GAChC,MAAMG,EAASH,EAAaG,OAC5BL,EAAc,CACZK,OAAQ3H,EAAS2H,OAAOC,aAAaD,GACrCE,OAAQ,EACRlE,KAAMgE,EAAOG,WAAWnE,KAE5B,MAAO,GAA+B,WAA3B0D,EAASE,cAA4B,CAC9C,MAAMI,EAASN,EACfC,EAAc,CACZK,OAAQ3H,EAAS2H,OAAOC,aAAaD,GACrCE,OAAQ,EACRlE,KAAMgE,EAAOG,WAAWnE,KAE5B,MAAO,GAA+B,mBAA3B0D,EAASE,cAAoC,CACtD,MAAMQ,EAAiBV,EACvBC,EAAc,CACZK,OAAQ3H,EAAS2H,OAAOC,aAAaG,EAAeJ,QACpDE,OAAQE,EAAeF,OACvBlE,KAAMoE,EAAepE,KAEzB,MAAO,GAA+B,mBAA3B0D,EAASE,cAAoC,CACtD,MAAMS,EAAUX,EAChBC,EAActH,EAAS+E,QAAQkD,cAAcD,EAC/C,MAAO,GAA+B,kBAA3BX,EAASE,cAAmC,CACrD,MAAMxC,EAAUsC,EAChBC,EAActH,EAAS+E,QAAQmD,aAAanD,GAASoD,YACvD,CACAhB,EAAQiB,KAAK,CACXC,QAASpB,EAAYG,GACrBC,SAAUC,GAEd,CACA,MAAMJ,EAASlH,EAASmB,OAAOmH,eAAe5C,GAAS6C,WAAW5B,GAC5DxD,EAAe6D,EAAOwB,gBAAgB,CAC1CtB,SACAC,YAGF,OADAtH,KAAKwG,MAAMU,EAAMF,MAAQ1D,EAClBA,CACT,CACA,OAAAU,GACEhE,KAAKwG,MAAQ,KACbxG,KAAK2G,UAAY,IACnB,EAGFJ,EAAgBtC,UAAY,CAC1BxD,KAAM,CACJ,KAAcmI,cAEhB5H,KAAM,a,iCCvER,MAAM6H,EACJ,WAAA9I,CAAY+I,GACV9I,KAAK8I,UAAYA,CACnB,CACA,OAAA9E,GACEhE,KAAK8I,UAAU9E,UACfhE,KAAK8I,UAAY,IACnB,EAEF,MAAMC,EACJ,WAAAhJ,CAAYI,GACVH,KAAK2G,UAAYxG,EACjBH,KAAKgJ,gBAAkB,IAAIC,EAAA,EAAc,CACvC9I,WACAM,KAAM,WACNyI,SAAUlJ,KAAKmJ,eAAeC,KAAKpJ,MACnCgB,KAAM,aAEV,CACA,aAAAd,CAAc0G,GACZ5G,KAAK6G,KAAOD,CACd,CACA,YAAAmB,CAAaD,GAEX,OADAA,EAAOuB,YAAcrJ,KAAK2G,UAAUR,GAAGC,IAChC0B,EAAOwB,SAAStJ,KAAK2G,UAAU4C,MAAMT,WAAa9I,KAAKwJ,gBAAgB1B,EAChF,CACA,YAAA2B,CAAa3B,GACX,MAAMgB,EAAY9I,KAAK+H,aAAaD,GAC9B4B,EAAO5B,EAAO4B,KAYpB,OAXI5B,EAAO6B,WAAaD,IACtB5B,EAAO6B,UAAY,EACnB3J,KAAK6G,KAAKM,OAAOyC,MAAMC,YACrBf,EACA,EACAY,EAAK5B,OACL,GAECA,EAAOgC,aAAeJ,EAAKK,YAAc,GAAI,IAG3CjB,CACT,CAEA,UAAAkB,GACEhK,KAAKgJ,gBAAgBiB,WACvB,CACA,cAAAd,CAAerB,GACbA,EAAOoC,IAAI,SAAUlK,KAAKyJ,aAAczJ,MACxC8H,EAAOoC,IAAI,SAAUlK,KAAKmK,eAAgBnK,KAC5C,CACA,eAAAwJ,CAAgB1B,GACd,MAAMgB,EAAY9I,KAAK6G,KAAKM,OAAOiD,aAAatC,EAAOG,YAYvD,OAXAH,EAAO6B,UAAY,EACnB7B,EAAOuC,aAAc,EAAAd,EAAA,GAAI,YACrBzB,EAAO4B,QACT,EAAAY,EAAA,GAASxC,EAAO4B,KAAK5B,OAAQgB,EAAUyB,kBACvCzB,EAAU0B,SAEZ1C,EAAOwB,SAAStJ,KAAK2G,UAAU4C,KAAO,IAAIV,EAAcC,GACpD9I,KAAKgJ,gBAAgByB,IAAI3C,KAC3BA,EAAO4C,GAAG,SAAU1K,KAAKyJ,aAAczJ,MACvC8H,EAAO4C,GAAG,SAAU1K,KAAKmK,eAAgBnK,OAEpC8I,CACT,CACA,cAAAqB,CAAerC,GACb9H,KAAKgJ,gBAAgB2B,OAAO7C,GAC5BA,EAAO6B,UAAY,EACnB3J,KAAKwJ,gBAAgB1B,EACvB,CACA,OAAA9D,GACEhE,KAAKgJ,gBAAgBhF,UACrBhE,KAAK2G,UAAY,KACjB3G,KAAK6G,KAAO,IACd,EAGFkC,EAAgB9E,UAAY,CAC1BxD,KAAM,CACJ,KAAcmI,cAEhB5H,KAAM,UCpFR,MAAM4J,EACJ,WAAA7K,CAAYI,GACVH,KAAK6K,gBAAkB,GACvB7K,KAAK2G,UAAYxG,CACnB,CACA,OAAA2K,CAAQC,GACF/K,KAAK6K,kBAAoBE,IAE7B/K,KAAK6K,gBAAkBE,EACvB/K,KAAK2G,UAAUZ,SAASiF,aAAaD,GACvC,CACA,OAAA/G,GACEhE,KAAK2G,UAAY,KACjB3G,KAAK6K,gBAAkB,IACzB,EAGFD,EAAmB3G,UAAY,CAC7BxD,KAAM,CACJ,KAAcmI,cAEhB5H,KAAM,a,cCpBR,MAAMiK,EAIJ,WAAAlL,CAAYI,GACVH,KAAK2G,UAAYxG,CACnB,CACA,UAAMiE,CAAK8G,GACT,OAAIlL,KAAKmL,eAETnL,KAAKmL,cAAgBD,EAAQtE,IAAMwE,QAAQC,QAAQH,EAAQtE,KAAO5G,KAAKsL,wBAAwBJ,IAAUK,KAAM3E,IAC7G5G,KAAK4G,IAAMA,EACX5G,KAAK2G,UAAU6E,QAAQtL,cAAcuL,KAAKzL,KAAK4G,QAHxC5G,KAAKmL,YAMhB,CAKA,aAAAjL,CAAc0G,GACZ5G,KAAK2G,UAAUC,IAAMA,CACvB,CAQA,6BAAM0E,CAAwBJ,GAC5B,MAAMQ,QAAgB,IAAWC,MAAMC,eAAehF,IAAIiF,eAAe,CACvEC,gBAAiBZ,EAAQY,gBACzBC,qBAAsBb,EAAQa,uBAE1BC,EAAmB,CACvB,yBACA,2BACA,4BACAC,OAAQC,GAAYR,EAAQS,SAASC,IAAIF,IACrC/E,QAAeuE,EAAQW,cAAc,CACzCL,qBAEF,MAAO,CAAEN,UAASvE,SACpB,CACA,OAAAnD,GACEhE,KAAK4G,IAAM,KACX5G,KAAK2G,UAAY,IACnB,EAGFsE,EAAgBhH,UAAY,CAC1BxD,KAAM,CACJ,KAAcmI,cAEhB5H,KAAM,UAGRiK,EAAgBqB,eAAiB,CAK/BR,qBAAiB,EAKjBC,sBAAsB,GCrExB,MAAMQ,EACJ,WAAAxM,CAAYI,GACVH,KAAKwM,gBAAkC/F,OAAOC,OAAO,MACrD1G,KAAKyM,mBAAqChG,OAAOC,OAAO,MACxD1G,KAAK2G,UAAYxG,CACnB,CACA,WAAAuM,GACE1M,KAAK2M,gBAAkB,IAAIvB,QAASC,IAClCrL,KAAK4M,wBAA0BvB,IAEjCrL,KAAK6M,eAAiB7M,KAAK2G,UAAUC,IAAIO,OAAO2F,sBAClD,CACA,eAAAC,CAAgBC,GACdhN,KAAKiN,gBACLjN,KAAKkN,cACLlN,KAAK4D,kBAAoB5D,KAAK6M,eAAeE,gBAAgBC,EAAgB/E,WAC/E,CACA,aAAAgF,GACMjN,KAAK4D,mBACP5D,KAAK4D,kBAAkBuJ,MAEzBnN,KAAK4D,kBAAoB,IAC3B,CACA,WAAAwJ,CAAYC,GACVrN,KAAK4D,kBAAkBwJ,YAAYC,EAASC,EAAGD,EAASE,EAAGF,EAASG,MAAOH,EAASI,OAAQ,EAAG,EACjG,CACA,sCAAAtK,CAAuCd,EAAUwD,EAASzC,EAAOL,GAC/D,MAAMgD,EAAW/F,KAAK2G,UAAUZ,SAASC,YAAY3D,EAAUwD,EAASzC,EAAOL,GAC/E/C,KAAKsG,YAAYP,EACnB,CACA,WAAAO,CAAYP,GACN/F,KAAK0N,iBAAmB3H,IAE5B/F,KAAK0N,eAAiB3H,EACtB/F,KAAK4D,kBAAkB0C,YAAYP,GACrC,CACA,gBAAA4H,CAAiBC,EAAO9F,GAClB9H,KAAKyM,mBAAmBmB,KAAW9F,IAEvC9H,KAAKyM,mBAAmBmB,GAAS9F,EACjC9H,KAAK4D,kBAAkBiK,gBAAgBD,EAAO5N,KAAK2G,UAAUmB,OAAO2B,aAAa3B,IACnF,CACA,eAAAgG,CAAgBhG,GACd,GAAI9H,KAAK+N,oBAAsBjG,EAC7B,OACF9H,KAAK+N,kBAAoBjG,EACzB,MAAMkG,EAAgD,IAAlClG,EAAO4B,KAAKuE,kBAA0B,SAAW,SACrEjO,KAAK4D,kBAAkBsK,eAAelO,KAAK2G,UAAUmB,OAAO2B,aAAa3B,GAASkG,EACpF,CACA,cAAA/H,CAAe2H,GACb5N,KAAKwM,gBAAgBoB,GAAS,IAChC,CACA,YAAAnL,CAAamL,EAAOpL,EAAWqD,GAC7B,GAAI7F,KAAKwM,gBAAgBoB,KAAWpL,EAClC,OACFxC,KAAKwM,gBAAgBoB,GAASpL,EAC9BA,EAAU0D,OAAOlG,KAAK2G,UAAUR,GAAGC,IAAKpG,KAAK2G,UAAUN,MACvD,MAAM/C,EAAetD,KAAK2G,UAAUnE,UAAUmB,aAAanB,EAAWqD,EAAS+H,GAC/E5N,KAAK4D,kBAAkBnB,aAAamL,EAAOtK,EAC7C,CACA,WAAAlB,CAAYC,EAAUwD,GACpB,MAAMsI,EAAgBnO,KAAK2G,UAAUZ,SAASqI,qBAAqB/L,EAAUwD,GAC7E,IAAK,MAAM7C,KAAKmL,EACdnO,KAAK2N,iBAAiBU,SAASrL,EAAG,IAAKX,EAASiM,WAAWH,EAAcnL,IAAI8E,QAE3EzF,EAASkM,aACXvO,KAAK8N,gBAAgBzL,EAASkM,YAElC,CACA,oBAAAC,CAAqBlN,EAAQmN,GAC3B,IAAK,MAAMzL,KAAK1B,EAAO+B,OAAQ,CAC7B,MAAMb,EAAYlB,EAAO+B,OAAOL,GAC3ByL,GACHzO,KAAK0O,eAAelM,GAEtBxC,KAAKyC,aAAaO,EAAGR,EAAWlB,EAAOP,WACzC,CACF,CACA,cAAA2N,CAAelM,GACb,IAAK,MAAM+E,KAAK/E,EAAUhB,UAAW,CACnC,MAAMgG,EAAWhF,EAAUhB,UAAU+F,GACjCC,EAASmH,gBACX3O,KAAK2G,UAAUiB,IAAIC,mBAAmBL,EAE1C,CACF,CACA,IAAAlC,CAAK4F,GACH,MAAM,SAAE7I,EAAQ,OAAEf,EAAM,MAAE8B,EAAK,SAAEL,EAAQ,KAAEe,EAAI,MAAEC,EAAK,cAAE6K,EAAa,SAAEH,GAAavD,EACpFlL,KAAKmD,uCAAuCd,EAAUf,EAAOP,WAAYqC,EAAOL,GAChF/C,KAAKoC,YAAYC,EAAUf,EAAOP,YAClCf,KAAKwO,qBAAqBlN,EAAQmN,GAC9BpM,EAASkM,YACXvO,KAAK4D,kBAAkBC,YACrBC,GAAQzB,EAASkM,YAAY7E,KAAKmF,OAClCD,GAAiBvM,EAASuM,cAC1B7K,GAAS,GAGX/D,KAAK4D,kBAAkB0B,KAAKxB,GAAQzB,EAASyM,UAAWF,GAAiBvM,EAASuM,cAAe7K,GAAS,EAE9G,CACA,gBAAAgL,GACM/O,KAAK4D,oBACP5D,KAAK4D,kBAAkBuJ,MACvBnN,KAAK4D,kBAAoB,KAE7B,CACA,UAAAoL,GACEhP,KAAK+O,mBACL/O,KAAK6G,KAAKM,OAAOyC,MAAMqF,OAAO,CAACjP,KAAK6M,eAAeqC,WACnDlP,KAAK4M,0BACL5M,KAAK6M,eAAiB,IACxB,CAIA,iBAAAsC,GACE,MAAMlH,EAAajI,KAAK2G,UAAUyI,aAAaC,QAAQC,cACrDtP,KAAK2G,UAAUyI,aAAaA,cAC5B,EACA,CAAC,EAAG,EAAG,EAAG,IAEZpP,KAAK4D,kBAAoB5D,KAAK6M,eAAeE,gBAAgB9E,GAC7D,MAAMsH,EAAgBvP,KAAK0N,eACrB8B,EAAoB,IAAKxP,KAAKyM,oBAC9BgD,EAAmBzP,KAAK+N,kBACxB2B,EAAiB,IAAK1P,KAAKwM,iBACjCxM,KAAKkN,cACL,MAAMG,EAAWrN,KAAK2G,UAAUyI,aAAa/B,SAC7CrN,KAAK4D,kBAAkBwJ,YAAYC,EAASC,EAAGD,EAASE,EAAGF,EAASG,MAAOH,EAASI,OAAQ,EAAG,GAC/FzN,KAAKsG,YAAYiJ,GACjB,IAAK,MAAMvM,KAAKwM,EACdxP,KAAK2N,iBAAiB3K,EAAGwM,EAAkBxM,IAE7C,IAAK,MAAMA,KAAK0M,EACd1P,KAAKyC,aAAaO,EAAG0M,EAAe1M,GAAI,MAE1ChD,KAAK8N,gBAAgB2B,EACvB,CACA,WAAAvC,GACE,IAAK,IAAIlK,EAAI,EAAGA,EAAI,GAAIA,IACtBhD,KAAKwM,gBAAgBxJ,GAAK,KAC1BhD,KAAKyM,mBAAmBzJ,GAAK,KAE/BhD,KAAK+N,kBAAoB,KACzB/N,KAAK0N,eAAiB,IACxB,CACA,OAAA1J,GACEhE,KAAK2G,UAAY,KACjB3G,KAAK6G,KAAO,KACZ7G,KAAKwM,gBAAkB,KACvBxM,KAAKyM,mBAAqB,KAC1BzM,KAAK+N,kBAAoB,KACzB/N,KAAK0N,eAAiB,IACxB,CACA,aAAAxN,CAAc0G,GACZ5G,KAAK6G,KAAOD,CACd,EAGF2F,EAAiBtI,UAAY,CAC3BxD,KAAM,CAAC,KAAcmI,cACrB5H,KAAM,UACN2O,SAAU,GCnKZ,MAAMC,EACJ,WAAA7P,CAAYI,GACVH,KAAK2G,UAAYxG,CACnB,CACA,aAAAD,GACEF,KAAK6P,YAAc7P,KAAK2G,UAAUQ,OAAOP,IAAIO,OAAOtG,OAAOiP,iCAC3D9P,KAAKc,qBAAuBd,KAAK6P,WACnC,CACA,OAAA7L,GACA,EAGF4L,EAAgB3L,UAAY,CAC1BxD,KAAM,CACJ,KAAcmI,cAEhB5H,KAAM,U,cCfR,MAAM+O,EACJ,WAAAhQ,CAAYI,GACVH,KAAKgQ,0BAA4CvJ,OAAOC,OAAO,MAC/D1G,KAAK2G,UAAYxG,EACjBA,EAASiP,aAAaa,qBAAqBxF,IAAIzK,KACjD,CACA,oBAAAiQ,CAAqBb,GACnB,IAAIc,EAAelQ,KAAKgQ,0BAA0BZ,EAAa7F,KAC1D2G,IACHA,EAAelQ,KAAKgQ,0BAA0BZ,EAAa7F,KAAO,CAChE4G,YAAa,IAAcC,SAC3BC,iBAAkB,IAGtBrQ,KAAKsQ,oBAAsBlB,EAC3BpP,KAAKuQ,eAAeL,EAAaC,YAAaD,EAAaG,iBAC7D,CACA,cAAAE,CAAeJ,EAAaE,GAC1B,MAAMH,EAAelQ,KAAKgQ,0BAA0BhQ,KAAKsQ,oBAAoB/G,KAC7E2G,EAAaC,YAAcA,EAC3BD,EAAaG,iBAAmBA,EAChC,MAAMlQ,EAAWH,KAAK2G,UACtBxG,EAAS4F,SAASwK,eAAeJ,GACjChQ,EAASgC,QAAQyB,kBAAkB4M,oBAAoBH,EACzD,CACA,OAAArM,GACEhE,KAAK2G,UAAUyI,aAAaa,qBAAqBtF,OAAO3K,MACxDA,KAAK2G,UAAY,KACjB3G,KAAKsQ,oBAAsB,KAC3BtQ,KAAKgQ,0BAA4B,IACnC,EAGFD,EAAiB9L,UAAY,CAC3BxD,KAAM,CACJ,KAAcmI,cAEhB5H,KAAM,W,cCxCR,MAAMyP,EAAuB,CAC3BC,IAAK,CAAEC,MAAO,EAAG7M,KAAM,GACvB8M,IAAK,CAAED,MAAO,EAAG7M,KAAM,GACvB+M,IAAK,CAAEF,MAAO,EAAG7M,KAAM,GACvBgN,IAAK,CAAEH,MAAO,EAAG7M,KAAM,GACvB,YAAa,CAAE6M,MAAO,EAAG7M,KAAM,GAC/B,YAAa,CAAE6M,MAAO,EAAG7M,KAAM,GAC/B,YAAa,CAAE6M,MAAO,EAAG7M,KAAM,GAC/B,YAAa,CAAE6M,MAAO,EAAG7M,KAAM,GAC/B,YAAa,CAAE6M,MAAO,GAAI7M,KAAM,IAChC,YAAa,CAAE6M,MAAO,GAAI7M,KAAM,IAChC,YAAa,CAAE6M,MAAO,GAAI7M,KAAM,IAChC,YAAa,CAAE6M,MAAO,EAAG7M,KAAM,GAC/B,YAAa,CAAE6M,MAAO,GAAI7M,KAAM,IAChC,YAAa,CAAE6M,MAAO,GAAI7M,KAAM,IAChC,YAAa,CAAE6M,MAAO,GAAI7M,KAAM,IAChC,YAAa,CAAE6M,MAAO,EAAG7M,KAAM,GAC/B,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,IACjC,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,GACjC,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,IACjC,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,IACjC,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,IACjC,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,IACjC,cAAe,CAAE6M,MAAO,GAAI7M,KAAM,IAClC,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,IACjC,cAAe,CAAE6M,MAAO,GAAI7M,KAAM,IAClC,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,IACjC,cAAe,CAAE6M,MAAO,GAAI7M,KAAM,IAClC,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,IACjC,cAAe,CAAE6M,MAAO,GAAI7M,KAAM,IAClC,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,IACjC,cAAe,CAAE6M,MAAO,GAAI7M,KAAM,IAClC,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,IACjC,cAAe,CAAE6M,MAAO,GAAI7M,KAAM,IAClC,cAAe,CAAE6M,MAAO,EAAG7M,KAAM,KAEnC,SAASiN,EAAsBC,GAC7B,MAAMC,EAAcD,EAAYE,IAAKxH,IAAS,CAC5CA,OACA1B,OAAQ,EACRlE,KAAM,KAER,IAAIkE,EAAS,EACb,IAAK,IAAIhF,EAAI,EAAGA,EAAIiO,EAAYpC,OAAQ7L,IAAK,CAC3C,MAAMmO,EAAaF,EAAYjO,GAC/B,IAAIc,EAAO2M,EAAqBU,EAAWzH,KAAKjJ,MAAMqD,KACtD,MAAM6M,EAAQF,EAAqBU,EAAWzH,KAAKjJ,MAAMkQ,MACzD,IAAKF,EAAqBU,EAAWzH,KAAKjJ,MACxC,MAAM,IAAI2Q,MAAM,gDAAgDD,EAAWzH,KAAKjJ,QAE9E0Q,EAAWzH,KAAK5F,KAAO,IACzBA,EAAOuN,KAAKC,IAAIxN,EAAM6M,GAASQ,EAAWzH,KAAK5F,MAEjDkE,EAASqJ,KAAKE,KAAKvJ,EAAS2I,GAASA,EACrCQ,EAAWrN,KAAOA,EAClBqN,EAAWnJ,OAASA,EACpBA,GAAUlE,CACZ,CAEA,OADAkE,EAAkC,GAAzBqJ,KAAKE,KAAKvJ,EAAS,IACrB,CAAEiJ,cAAanN,KAAMkE,EAC9B,C,wBC1DA,SAASwJ,EAAsBL,EAAYM,GACzC,MAAM,KAAE3N,EAAI,MAAE6M,GAAUF,EAAqBU,EAAWzH,KAAKjJ,MACvDiR,GAAaf,EAAQ7M,GAAQ,EAC7B4F,EAAOyH,EAAWzH,KAAKjJ,KAAKkR,QAAQ,QAAU,EAAI,YAAc,OACtE,MAAO,qBACSR,EAAWzH,KAAK1I,mBACP,IAAhByQ,EAAoB,aAAaA,KAAiB,wFAMjCN,EAAWzH,KAAK5F,MAAQA,EAAO,yDAEzBA,EAAO,6CAEtB4F,4DAEU,IAAdgI,EAAkB,kBAAkBA,KAAe,uBAGlE,CCnBA,SAASE,EAA0BX,GACjC,OAAO,EAAAY,EAAA,GACLZ,EACA,UACAO,EACAM,EAAA,EAEJ,CCNA,MAAMC,UAAqBC,EAAA,EACzB,WAAAjS,GACEkS,MAAM,CACJC,kBAAmBnB,EACnBoB,gBAAiBP,GAErB,EAGFG,EAAa9N,UAAY,CACvBxD,KAAM,CAAC,KAAcmI,cACrB5H,KAAM,O,gCChBR,MAAMoR,EACJ,WAAArS,EAAY,0BAAEsS,IACZrS,KAAKsS,2BAA6B,IAClCtS,KAAKuS,UAAY,EACjBvS,KAAKsS,2BAA6BD,EAClCrS,KAAK0J,KAAO,IAAI/I,aAAa,MAC/B,CACA,KAAA6R,GACExS,KAAKuS,UAAY,CACnB,CACA,aAAAE,CAAc3O,GACZ,GAAIA,EAAO9D,KAAKsS,2BAA6B,EAC3C,MAAM,IAAIlB,MAAM,2CAAkD,EAAPtN,GAE7D,MAAMC,EAAQ/D,KAAKuS,UACnB,IAAIG,EAAU3O,EAAe,EAAPD,EAEtB,GADA4O,EAAUrB,KAAKE,KAAKmB,EAAU1S,KAAKsS,4BAA8BtS,KAAKsS,2BAClEI,EAA6B,EAAnB1S,KAAK0J,KAAKmF,OACtB,MAAM,IAAIuC,MAAM,6CAGlB,OADApR,KAAKuS,UAAYG,EACV3O,CACT,CACA,QAAA4O,CAASC,GACP,MAAM5K,EAAShI,KAAKyS,cAAcG,EAAM/D,QACxC,IAAK,IAAI7L,EAAI,EAAGA,EAAI4P,EAAM/D,OAAQ7L,IAChChD,KAAK0J,KAAK1B,EAAS,EAAIhF,GAAK4P,EAAM5P,GAEpC,OAAOgF,CACT,CACA,OAAAhE,GACEhE,KAAK0J,KAAO,IACd,E,cCzBF,MAAM2I,EAA4B,IAClC,MAAMQ,EACJ,WAAA9S,CAAYI,GACVH,KAAK8S,eAAiCrM,OAAOC,OAAO,MAEpD1G,KAAK+S,SAAW,GAChB/S,KAAKgT,YAAc,GACnBhT,KAAKiT,iBAAmB,GACxBjT,KAAK2G,UAAYxG,EACjBH,KAAKkT,aAAe,IAAId,EAAS,CAAEC,8BAEnC,IAAK,IAAIrP,EAAI,EAAGA,EADK,EACaA,IAAK,CACrC,IAAImQ,EAAQ,IAAYC,QAAU,IAAYC,SACpC,IAANrQ,IACFmQ,GAAS,IAAYG,UACvBtT,KAAK+S,SAASxK,KAAK,IAAIgL,EAAA,EAAO,CAC5B7J,KAAM1J,KAAKkT,aAAaxJ,KACxByJ,UAEJ,CACF,CACA,SAAAK,GACExT,KAAKyT,oBACLzT,KAAK0T,kBACP,CACA,gBAAAA,GACE1T,KAAK8S,eAAiCrM,OAAOC,OAAO,MACpD1G,KAAKkT,aAAaV,OACpB,CAEA,mBAAA3P,CAAoBqE,EAAOyM,GACzB,IAAKA,GAAa3T,KAAK8S,eAAe5L,EAAMqC,KAC1C,OAAOvJ,KAAK8S,eAAe5L,EAAMqC,KAEnCvJ,KAAK2G,UAAUiB,IAAIgM,mBAAmB1M,GACtC,MAAMwC,EAAOxC,EAAMY,OAAO4B,KACpB1B,EAAShI,KAAKkT,aAAaT,cAAc/I,EAAKmF,QAGpD,OAFA7O,KAAK2G,UAAUiB,IAAIiM,iBAAiB3M,EAAOlH,KAAKkT,aAAaxJ,KAAM1B,EAAS,GAC5EhI,KAAK8S,eAAe5L,EAAMqC,KAAOvJ,KAAK8T,cAAc9L,EAASqK,GACtDrS,KAAK8S,eAAe5L,EAAMqC,IACnC,CACA,cAAAwK,CAAe7M,GACblH,KAAK2G,UAAUiB,IAAIC,mBAAmBX,GACtC,MAAMwC,EAAOxC,EAAMY,OAAO4B,KACpB1B,EAAShI,KAAKkT,aAAaP,SAASjJ,GAC1C,OAAO1J,KAAKgU,mBAAmBhM,EAASqK,EAC1C,CACA,iBAAA4B,CAAkBvK,GAChB,MAAM1B,EAAShI,KAAKkT,aAAaP,SAASjJ,GAC1C,OAAO1J,KAAK8T,cAAc9L,EAASqK,EACrC,CACA,sBAAA6B,CAAuBxK,GACrB,MACMkE,EADS5N,KAAKkT,aAAaP,SAASjJ,GACnB2I,EACvB,OAAOrS,KAAKgU,mBAAmBpG,EACjC,CACA,kBAAAoG,CAAmBpG,GACjB,IAAK5N,KAAKiT,iBAAiBrF,GAAQ,CACjC,MAAM9F,EAAS9H,KAAK+S,SAASnF,EAAQ,GACrC5N,KAAKiT,iBAAiBrF,GAAS,IAAIuG,EAAA,EAAe,CAChDrM,SACAE,OAA0B,KAAjB4F,EAAQ,EAAI,GACrB9J,KAAMuO,GAEV,CACA,OAAOrS,KAAKiT,iBAAiBrF,EAC/B,CACA,aAAAkG,CAAclG,GACZ,IAAK5N,KAAKgT,YAAYpF,GAAQ,CAC5B,MAAMpL,EAAY,IAAI4R,EAAA,EAAU,CAC9B,EAAGpU,KAAKgU,mBAAmBpG,KAE7B5N,KAAKgT,YAAYpF,GAASpL,CAC5B,CACA,OAAOxC,KAAKgT,YAAYpF,EAC1B,CACA,iBAAA6F,GACE,MAAMY,EAAerU,KAAK2G,UAAUmB,OAC9BwM,EAActU,KAAK+S,SAAS,GAClCuB,EAAYC,OAAOvU,KAAKkT,aAAaX,WACrC8B,EAAa5K,aAAa6K,GAC1B,MAAMzH,EAAiB7M,KAAK2G,UAAUC,IAAIO,OAAO2F,uBACjD,IAAK,IAAI9J,EAAI,EAAGA,EAAIhD,KAAK+S,SAASlE,OAAQ7L,IAAK,CAC7C,MAAM8E,EAAS9H,KAAK+S,SAAS/P,GAC7B6J,EAAe2H,mBACbH,EAAatM,aAAauM,GAC1BjC,EACAgC,EAAatM,aAAaD,GAC1B,EACA9H,KAAKkT,aAAaX,UAEtB,CACAvS,KAAK2G,UAAUC,IAAIO,OAAOyC,MAAMqF,OAAO,CAACpC,EAAeqC,UACzD,CACA,OAAAlL,GACE,IAAK,IAAIhB,EAAI,EAAGA,EAAIhD,KAAKgT,YAAYnE,OAAQ7L,IAC3ChD,KAAKgT,YAAYhQ,IAAIgB,UAEvBhE,KAAKgT,YAAc,KACnBhT,KAAK8S,eAAiB,KACtB,IAAK,IAAI9P,EAAI,EAAGA,EAAIhD,KAAK+S,SAASlE,OAAQ7L,IACxChD,KAAK+S,SAAS/P,GAAGgB,UAEnBhE,KAAK+S,SAAW,KAChB,IAAK,IAAI/P,EAAI,EAAGA,EAAIhD,KAAKiT,iBAAiBpE,OAAQ7L,IAChDhD,KAAKiT,iBAAiBjQ,GAAGgB,UAE3BhE,KAAKiT,iBAAmB,KACxBjT,KAAKkT,aAAalP,UAClBhE,KAAK2G,UAAY,IACnB,EAGFkM,EAAoB5O,UAAY,CAC9BxD,KAAM,CACJ,KAAcgU,aAEhBzT,KAAM,gB,mCCrHR,MAAM0T,GAAqB,CACzB,aAAc,EACd,YAAa,EACb,aAAc,EACd,gBAAiB,EACjB,iBAAkB,GAQpB,MAAMC,GACJ,WAAA5U,CAAYI,GACVH,KAAK4U,aAA+BnO,OAAOC,OAAO,MAClD1G,KAAK6U,oBAAsCpO,OAAOC,OAAO,MACzD1G,KAAK8U,mBAAqCrO,OAAOC,OAAO,MACxD1G,KAAK+U,WAA6BtO,OAAOC,OAAO,MAChD1G,KAAKgV,iBAAmCvO,OAAOC,OAAO,MACtD1G,KAAKiV,WAAa,GAClBjV,KAAKkV,kBAAoB,EACzBlV,KAAKmV,kBAAoB,EACzBnV,KAAK2G,UAAYxG,CACnB,CACA,aAAAD,CAAc0G,GACZ5G,KAAK6G,KAAOD,EACZ5G,KAAKuQ,eAAe,IAAcH,UAClCpQ,KAAKoV,iBACP,CACA,mBAAAC,CAAoBC,GACdtV,KAAKkV,oBAAsBI,IAE/BtV,KAAKkV,kBAAoBI,EACzBtV,KAAKoV,kBACP,CACA,eAAAG,CAAgBnG,GACdpP,KAAKkV,kBAAoB9F,EAAaoG,YACtCxV,KAAKyV,wBAA0BrG,EAAanH,WAAWyN,uBAAyB,EAAI,EACpF1V,KAAKmV,kBAAoB/F,EAAauG,iBACtC3V,KAAKoV,iBACP,CACA,YAAApK,CAAaD,GACP/K,KAAKiV,aAAelK,IAExB/K,KAAKiV,WAAalK,EAClB/K,KAAKoV,kBACP,CACA,cAAA7E,CAAeJ,GACTnQ,KAAK4V,eAAiBzF,IAE1BnQ,KAAK4V,aAAezF,EACpBnQ,KAAK6V,cAAgBC,GAAA,EAAsB3F,GAC3CnQ,KAAKoV,kBACP,CACA,WAAA9O,CAAYjE,EAAUwD,EAASzC,EAAO2S,GACpC,MAAMhQ,EAAW/F,KAAKgG,YAAY3D,EAAUwD,EAASzC,GACrD2S,EAAYzP,YAAYP,EAC1B,CACA,WAAAC,CAAY3D,EAAUwD,EAASzC,EAAOL,GAC/BV,EAAS2T,cACZ,EAAAC,EAAA,GAAiB5T,EAAUwD,EAAQqQ,eACnClW,KAAKmW,mBAAmB9T,IAE1BU,IAAaA,EAAWV,EAASU,UACjC,MAAMqT,EA1DV,SAA6BC,EAAgBC,EAAWlT,EAAO0C,EAAW/C,GACxE,OAAOsT,GAAkB,GAAKC,GAAa,GAAKlT,GAAS,GAAK0C,GAAa,EAAI/C,CACjF,CAwDgBwT,CACVlU,EAAS2T,WACTnQ,EAAQmQ,WACR5S,EAAMsG,KACNtG,EAAMoT,aACN9B,GAAmB3R,IAErB,OAAI/C,KAAK+U,WAAWqB,KAEpBpW,KAAK+U,WAAWqB,GAAOpW,KAAKyW,gBAAgBpU,EAAUwD,EAASzC,EAAOL,IAD7D/C,KAAK+U,WAAWqB,EAG3B,CACA,eAAAK,CAAgBpU,EAAUwD,EAASzC,EAAOL,GACxC,MAAMoE,EAASnH,KAAK6G,KAAKM,OACnBuP,EAAU1W,KAAK2W,2BAA2BtU,EAAUwD,GACpD+Q,EAAa5W,KAAK2G,UAAUvD,MAAMyT,gBAAgBzT,EAAOpD,KAAKmV,mBAC9D2B,EAAY9W,KAAK4V,eAAiB,IAAcmB,mBAAqB,EAAI/W,KAAKiV,WACpF,IAAK,IAAIjS,EAAI,EAAGA,EAAI4T,EAAW/H,OAAQ7L,IACrC4T,EAAW5T,GAAG8T,UAAYA,EAE5B,MAAMzP,EAASrH,KAAK2G,UAAUrF,OAAOmH,eAAe5C,GAASE,SACvDkC,EAAa,CAGjB+O,OAAQ,CACNC,OAAQjX,KAAKkX,WAAWrR,EAAQmR,OAAOG,QACvCC,WAAYvR,EAAQmR,OAAOI,WAE3BV,WAEFW,SAAU,CACRJ,OAAQjX,KAAKkX,WAAWrR,EAAQwR,SAASF,QACzCC,WAAYvR,EAAQwR,SAASD,WAC7BE,QAASV,GAEXW,UAAW,CACTxU,WACAyU,SAAUpU,EAAMoU,UAElBnQ,SACAoQ,YAAa,CACX/T,MAAO1D,KAAKkV,mBAGdwC,MAAO,iBAWT,OATI1X,KAAKyV,0BACPxN,EAAW0P,aAAe,IACrB3X,KAAK6V,cACR+B,OAAQ,uBACRC,kBAAmBzU,EAAM0U,UACzBC,aAAc3U,EAAM0U,UAAY,OAAS,WAG5B3Q,EAAO6Q,qBAAqB/P,EAE/C,CACA,UAAAiP,CAAWe,GACT,OAAOjY,KAAK4U,aAAaqD,IAASjY,KAAKkY,cAAcD,EACvD,CACA,aAAAC,CAAcD,GACZ,MAAM9Q,EAASnH,KAAK6G,KAAKM,OAIzB,OAHAnH,KAAK4U,aAAaqD,GAAQ9Q,EAAOgR,mBAAmB,CAClDF,SAEKjY,KAAK4U,aAAaqD,EAC3B,CACA,kBAAA9B,CAAmB9T,GACjB,MAAM+V,EAAS,GACf,IAAIxK,EAAQ,EACZ,MAAMyK,EAAgB5R,OAAO6R,KAAKjW,EAASiM,YAAYiK,OACvD,IAAK,IAAIvV,EAAI,EAAGA,EAAIqV,EAAcxJ,OAAQ7L,IAAK,CAC7C,MAAMwV,EAAYnW,EAASiM,WAAW+J,EAAcrV,IACpDoV,EAAOxK,KAAW4K,EAAUxQ,OAC5BoQ,EAAOxK,KAAW4K,EAAUZ,OAC5BQ,EAAOxK,KAAW4K,EAAUC,OAC5BL,EAAOxK,KAAW4K,EAAUE,QAC9B,CACA,MAAMC,EAAYP,EAAOQ,KAAK,KAE9B,OADAvW,EAAS2T,YAAa,EAAA6C,EAAA,GAAmBF,EAAW,YAC7CtW,EAAS2T,UAClB,CACA,8BAAA8C,CAA+BjT,GAC7B,MAAMuS,EAAS,GACf,IAAIxK,EAAQ,EACZ,MAAMyK,EAAgB5R,OAAO6R,KAAKzS,EAAQqQ,eAAeqC,OACzD,IAAK,IAAIvV,EAAI,EAAGA,EAAIqV,EAAcxJ,OAAQ7L,IAAK,CAC7C,MAAMwV,EAAY3S,EAAQqQ,cAAcmC,EAAcrV,IACtDoV,EAAOxK,KAAW4K,EAAUO,QAC9B,CACA,MAAMJ,EAAYP,EAAOQ,KAAK,KAE9B,OADA/S,EAAQmT,wBAAyB,EAAAH,EAAA,GAAmBF,EAAW,qBACxD9S,EAAQmT,sBACjB,CAQA,oBAAA5K,CAAqB/L,EAAUwD,GAC7B,MAAMuQ,EAAM/T,EAAS2T,YAAc,GAAKnQ,EAAQmT,uBAChD,GAAIhZ,KAAK8U,mBAAmBsB,GAC1B,OAAOpW,KAAK8U,mBAAmBsB,GACjC,MAAM1M,EAAO1J,KAAK2W,2BAA2BtU,EAAUwD,GACjDoT,EAAoCxS,OAAOC,OAAO,MAClDwP,EAAgBrQ,EAAQqQ,cAC9B,IAAK,IAAIlT,EAAI,EAAGA,EAAI0G,EAAKmF,OAAQ7L,IAAK,CACpC,MACMkW,EADazS,OAAO0S,OAAOzP,EAAK1G,GAAGsL,YACP,GAAG4K,eACrC,IAAK,MAAM3R,KAAK2O,EACd,GAAIA,EAAc3O,GAAGwR,WAAaG,EAAgB,CAChDD,EAAkBjW,GAAKuE,EACvB,KACF,CAEJ,CAEA,OADAvH,KAAK8U,mBAAmBsB,GAAO6C,EACxBA,CACT,CACA,0BAAAtC,CAA2BtU,EAAUwD,GAC9BA,EAAQmT,wBACXhZ,KAAK8Y,+BAA+BjT,GACtC,MAAMuQ,EAAM/T,EAAS2T,YAAc,GAAKnQ,EAAQmT,uBAChD,GAAIhZ,KAAK6U,oBAAoBuB,GAC3B,OAAOpW,KAAK6U,oBAAoBuB,GAElC,MAAMgD,EAAsB,GA4B5B,OA3BA/W,EAASqU,QAAQ2C,QAASvR,IACxB,MAAMwR,EAAc,CAClBC,YAAa,EACbC,SAAU,SACVlL,WAAY,IAERmL,EAAwBH,EAAYhL,WAC1C,IAAK,MAAMtL,KAAK6C,EAAQqQ,cAAe,CACrC,MAAMsC,EAAYnW,EAASiM,WAAWtL,GACL,KAA5BwV,EAAUkB,SAAW,KACxB,EAAAzU,EAAA,GAAK,aAAajC,sCAAsCwV,EAAUkB,uDAEhElB,EAAU1Q,SAAWA,IACvBwR,EAAYC,YAAcf,EAAUC,OACpCa,EAAYE,SAAWhB,EAAUE,SAAW,WAAa,SACzDe,EAAsBlR,KAAK,CACzB2Q,eAAgBrT,EAAQqQ,cAAclT,GAAG+V,SACzC/Q,OAAQwQ,EAAUxQ,OAClB4P,OAAQY,EAAUZ,SAGxB,CACI6B,EAAsB5K,QACxBuK,EAAoB7Q,KAAK+Q,KAG7BtZ,KAAK6U,oBAAoBuB,GAAOgD,EACzBA,CACT,CACA,eAAAhE,GACE,MAAMgB,GAtNiBuD,EAuNrB3Z,KAAK4V,aAvNgCgE,EAwNrC5Z,KAAKkV,kBACLlV,KAAKiV,YAxNW,EAAI0E,GAAkB,EAyNtC3Z,KAAKyV,yBAzNqD,EA0N1DzV,KAAKmV,mBA1N6E,EAAIyE,GAD5F,IAA2BD,EAAgBC,EA6NlC5Z,KAAKgV,iBAAiBoB,KACzBpW,KAAKgV,iBAAiBoB,GAAuB3P,OAAOC,OAAO,OAE7D1G,KAAK+U,WAAa/U,KAAKgV,iBAAiBoB,EAC1C,CACA,OAAApS,GACEhE,KAAK2G,UAAY,KACjB3G,KAAK6U,oBAAsB,IAC7B,EAGFF,GAAe1Q,UAAY,CACzBxD,KAAM,CAAC,KAAcmI,cACrB5H,KAAM,Y,+CC3PR,MAAM6Y,GACJ,WAAA9Z,GACEC,KAAK8Z,SAAW,GAChB9Z,KAAK+Z,aAAe,GACpB/Z,KAAKwV,YAAc,CACrB,ECAF,MAAMwE,GACJ,IAAA5V,CAAKjE,EAAU8Z,GACbja,KAAK2G,UAAYxG,EACjBH,KAAKka,oBAAsBD,CAC7B,CACA,aAAAE,CAAcC,EAA4BC,EAAoBC,EAAWxW,EAAMyW,GAC7E,MAAMpa,EAAWH,KAAK2G,UAChB6T,EAAiBxa,KAAKya,oBAC1BL,GAEIM,EAAiBva,EAAS+E,QAAQmD,aACtCgS,EAAmBlD,QAarB,OAXAhX,EAASgC,QAAQ0K,eAAe8N,qBAC9B,CACEzV,QAASsV,EACTI,OAAQN,GAEV,CACEpV,QAASwV,EACTE,OAAQL,GAEVzW,GAEKuW,CACT,CACA,eAAAQ,CAAgBzL,EAAcoD,GAAQ,EAAMsI,EAAYzN,GACtD,MACML,EADqBhN,KAAKka,oBACWa,mBAAmB3L,GACxDnH,EAAajI,KAAKsP,cAAcF,EAAcoD,EAAOsI,GAC3D9N,EAAgB/E,WAAaA,EAC7BjI,KAAK2G,UAAUZ,SAASwP,gBAAgBvI,GACxChN,KAAK2G,UAAUxE,QAAQ4K,gBAAgBC,GACvChN,KAAK2G,UAAUxE,QAAQiL,YAAYC,EACrC,CACA,gBAAA0B,GACE/O,KAAK2G,UAAUxE,QAAQ8K,eACzB,CAOA,mBAAAwN,CAAoBrL,GAClB,MAAMpC,EAAkBhN,KAAKka,oBAAoBa,mBAAmB3L,GACpE,OAAIpC,EAAgB8M,SAAS,GACpB9M,EAAgB8M,SAAS,GAAGkB,oBAE9Bhb,KAAK2G,UAAUzB,QAAQmD,aAC5B+G,EAAa6L,cAAc,GAAG9D,OAElC,CACA,aAAA7H,CAAcF,EAAcoD,EAAO0I,GACZ,kBAAV1I,IACTA,EAAQA,EAAQ,KAAM2I,IAAM,KAAMC,MAEpC,MAAMnB,EAAqBja,KAAKka,oBAC1BlN,EAAkBiN,EAAmBc,mBAAmB3L,GACxDiM,EAAmBjM,EAAa6L,cAAc/J,IAClD,CAAChM,EAASlC,KACR,MAAMpB,EAAUoL,EAAgB8M,SAAS9W,GACzC,IAAIsY,EACAC,EAIFD,EAHE1Z,EACqBA,EAAQoZ,oBACU1S,aAGlCtI,KAAK2G,UAAUzB,QAAQmD,aAAanD,GAASoD,WAAW,CAC7DkT,cAAe,IAGfxO,EAAgB+M,aAAa/W,KAC/BuY,EAAgBD,EAChBA,EAAOtb,KAAK2G,UAAUzB,QAAQuW,eAC5BzO,EAAgB+M,aAAa/W,KAGjC,MAAM0Y,EAASlJ,EAAQ,KAAMmJ,MAAQ,QAAU,OAE/C,OADAT,IAAeA,EAAajB,EAAmB2B,mBACxC,CACLN,OACAC,gBACAL,aACAW,QAAS,QACTH,YAIN,IAAIhG,EAKJ,IAJKtG,EAAa0M,UAAW1M,EAAa2M,OAAW3M,EAAa4M,sBAChE5M,EAAa6M,4BACb7M,EAAa4M,oBAAoB7E,OAAO+E,YAAclP,EAAgBmP,KAAO,EAAI,GAE/E/M,EAAa4M,oBAAqB,CACpC,MAAMI,EAAgB5J,EAAQ,KAAM6J,QAAU,QAAU,OAClDC,EAAc9J,EAAQ,KAAM+J,MAAQ,QAAU,OACpD7G,EAAyB,CACvB4F,KAAMtb,KAAK2G,UAAUzB,QAAQmD,aAAa+G,EAAa4M,oBAAoB7E,QAAQ7O,aACnFkU,eAAgB,QAChBJ,gBACAK,gBAAiB,EACjBH,cACAI,aAAc,QAElB,CAKA,MAJmB,CACjBrB,mBACA3F,yBAGJ,CACA,KAAAlD,CAAMpD,EAAcoD,GAAQ,EAAMsI,EAAYzN,GAC5C,IAAKmF,EACH,OACF,MAAM,IAAE5L,EAAG,QAAEzE,GAAYnC,KAAK2G,UACxBQ,EAASP,EAAIO,OAEnB,GAD8C,OAA3BhF,EAAQ0K,eACX,CACd,MAAMA,EAAiB1F,EAAO2F,uBACxB6P,EAAuB3c,KAAKsP,cAAcF,EAAcoD,EAAOsI,GAC/D/E,EAAclJ,EAAeE,gBAAgB4P,GACnD5G,EAAY3I,YAAYC,EAASC,EAAGD,EAASE,EAAGF,EAASG,MAAOH,EAASI,OAAQ,EAAG,GACpFsI,EAAY5I,MACZ,MAAMyP,EAAc/P,EAAeqC,SACnC/H,EAAOyC,MAAMqF,OAAO,CAAC2N,GACvB,MACE5c,KAAK6a,gBAAgBzL,EAAcoD,EAAOsI,EAAYzN,EAE1D,CACA,mBAAAwP,CAAoBzN,GAClBA,EAAa0N,QAAS,EACtB,MAAM9P,EAAkB,IAAI6M,GAoC5B,OAnCA7M,EAAgB2I,iBAAmBvG,EAAa6L,cAAcpM,OAC9DO,EAAa6L,cAAc5B,QAAQ,CAAC0D,EAAc/Z,KAChD,GAAI+Z,aAAwBC,GAAA,EAAc,CACxC,MAAMpb,EAAUmb,EAAavV,SAASyV,WACpC,UAEIC,EAAYH,EAAaI,YAAc,gBAAkB,SAC/D,IACEvb,EAAQwb,UAAU,CAChBjW,OAAQnH,KAAK2G,UAAUC,IAAIO,OAC3BgM,MAAOkK,gBAAgBC,gBAAkBD,gBAAgBhK,SAAWgK,gBAAgBE,kBAAoBF,gBAAgB/J,SACxHsE,OAAQ,aACRsF,aAEJ,CAAE,MAAOM,GACPC,QAAQC,MAAMF,EAChB,CACAxQ,EAAgB8M,SAAS9W,GAAKpB,CAChC,CAEA,GADAoL,EAAgBmP,KAAOY,EAAa5F,OAAOwG,UACvCZ,EAAa5F,OAAOwG,UAAW,CACjC,MAAMC,EAAc,IAAIC,GAAA,EAAc,CACpCrQ,MAAO,EACPC,OAAQ,EACRyO,YAAa,IAEflP,EAAgB+M,aAAa/W,GAAK4a,CACpC,IAEE5Q,EAAgBmP,OAClBnP,EAAgBwI,YAAc,EAC1BpG,EAAa4M,sBACf5M,EAAa4M,oBAAoB7E,OAAO+E,YAAc,IAGnDlP,CACT,CACA,sBAAA8Q,CAAuB9Q,GACrBA,EAAgB8M,SAAST,QAASzX,IAChCA,EAAQmc,gBAEV/Q,EAAgB+M,aAAaV,QAASnU,IACpCA,EAAQlB,YAEVgJ,EAAgB+M,aAAalL,OAAS,EACtC7B,EAAgB8M,SAASjL,OAAS,CACpC,CACA,yBAAAoN,CAA0B7M,GACxB,MAAMpC,EAAkBhN,KAAKka,oBAAoBa,mBAAmB3L,GAChEA,EAAa4M,qBAAuBhP,EAAgBmP,OACtD/M,EAAa4M,oBAAoB7E,OAAO+E,YAAc,EAE1D,CACA,qBAAA8B,CAAsB5O,GACpB,MAAMpC,EAAkBhN,KAAKka,oBAAoBa,mBAAmB3L,GACpEpC,EAAgBQ,MAAQ4B,EAAa5B,MACrCR,EAAgBS,OAAS2B,EAAa3B,OAClCT,EAAgBmP,MAClB/M,EAAa6L,cAAc5B,QAAQ,CAAC0D,EAAc/Z,KAChD,MAAM4a,EAAc5Q,EAAgB+M,aAAa/W,GACjD4a,GAAaK,OACXlB,EAAa5F,OAAO3J,MACpBuP,EAAa5F,OAAO1J,OACpBsP,EAAa5F,OAAO+G,cAI5B,EC1MF,MAAMC,WAA8BC,GAAA,EAClC,WAAAre,CAAYI,GACV8R,MAAM9R,GACNH,KAAKqP,QAAU,IAAI2K,GACnBha,KAAKqP,QAAQjL,KAAKjE,EAAUH,KAC9B,EAGFme,GAAsBla,UAAY,CAChCxD,KAAM,CAAC,KAAcmI,cACrB5H,KAAM,gBCZR,MAAMqd,GACJ,WAAAte,GACEC,KAAKse,gBAAkC7X,OAAOC,OAAO,KACvD,CACA,aAAAxG,CAAc0G,GACZ5G,KAAK6G,KAAOD,CACd,CACA,cAAA6B,CAAe5C,GACb,OAAO7F,KAAKse,gBAAgBzY,EAAQmQ,aAAehW,KAAKue,sBAAsB1Y,EAChF,CACA,qBAAA0Y,CAAsB1Y,GACpB,MAAMsB,EAASnH,KAAK6G,KAAKM,OACnBuB,EAAa7C,EAAQ2Y,UAAUtN,IAAKhK,GAAUC,EAAOsX,sBAAsB,CAAEnX,QAASJ,KACtFwX,EAAqB,CAAEC,iBAAkBjW,GAK/C,OAJA1I,KAAKse,gBAAgBzY,EAAQmQ,YAAc,CACzCtN,aACA3C,SAAUoB,EAAOyX,qBAAqBF,IAEjC1e,KAAKse,gBAAgBzY,EAAQmQ,WACtC,CACA,OAAAhS,GACEhE,KAAK6G,KAAO,KACZ7G,KAAKse,gBAAkB,IACzB,EAGFD,GAAgBpa,UAAY,CAC1BxD,KAAM,CACJ,KAAcmI,cAEhB5H,KAAM,UChCR,MAAM6d,GAAsB,CAC5BA,OAA6B,CAC3BC,MAAO,CACLC,UAAW,MACXC,UAAW,sBACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,MACXC,UAAW,sBACXC,UAAW,QAGfJ,IAA0B,CACxBC,MAAO,CACLC,UAAW,YACXC,UAAW,sBACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,MACXC,UAAW,MACXC,UAAW,QAGfJ,SAA+B,CAC7BC,MAAO,CACLC,UAAW,MACXC,UAAW,sBACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,MACXC,UAAW,sBACXC,UAAW,QAGfJ,OAA6B,CAC3BC,MAAO,CACLC,UAAW,MACXC,UAAW,sBACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,MACXC,UAAW,gBACXC,UAAW,QAGfJ,QAA8B,CAC5BC,MAAO,CACLC,UAAW,MACXC,UAAW,sBACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,MACXC,UAAW,gBACXC,UAAW,QAGfJ,KAA2B,CACzBC,MAAO,CACLC,UAAW,MACXC,UAAW,sBACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,OACXC,UAAW,OACXC,UAAW,QAGfJ,aAAoC,CAClCC,MAAO,CACLC,UAAW,MACXC,UAAW,sBACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,YACXC,UAAW,sBACXC,UAAW,QAGfJ,UAAiC,CAC/BC,MAAO,CACLC,UAAW,MACXC,UAAW,MACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,YACXC,UAAW,MACXC,UAAW,QAGfJ,aAAoC,CAClCC,MAAO,CACLC,UAAW,MACXC,UAAW,sBACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,YACXC,UAAW,gBACXC,UAAW,QAGfJ,MAA4B,CAC1BC,MAAO,CACLC,UAAW,OACXC,UAAW,sBACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,OACXC,UAAW,gBACXC,UAAW,QAGfJ,IAA0B,CACxBC,MAAO,CACLC,UAAW,MACXC,UAAW,MACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,MACXC,UAAW,MACXC,UAAW,QAGfJ,IAA0B,CACxBC,MAAO,CACLC,UAAW,MACXC,UAAW,MACXC,UAAW,OAEbC,MAAO,CACLH,UAAW,MACXC,UAAW,MACXC,UAAW,SC1If,MAAME,GACJ,WAAApf,GACEC,KAAKof,aAAe,IAAI3Z,EAAA,EACxBzF,KAAKof,aAAaC,OAAQ,CAC5B,CACA,aAAAnf,CAAc0G,GACZ5G,KAAK4G,IAAMA,CACb,CAMA,eAAAiQ,CAAgBzT,EAAOM,GACrB,MACM4T,EAAU,GACVgI,EAAS,CACb1H,OAAQ,aACRd,UAAW,EACXuI,MALYR,GAAoBzb,EAAM0C,YAAc+Y,GAAoBU,QAO1E,IAAK,IAAIvc,EAAI,EAAGA,EAAIU,EAAOV,IACzBsU,EAAQtU,GAAKsc,EAEf,OAAOhI,CACT,CACA,OAAAtT,GACEhE,KAAK4G,IAAM,IACb,EAGFuY,GAAelb,UAAY,CACzBxD,KAAM,CACJ,KAAcmI,cAEhB5H,KAAM,S,eCvCR,MAAMwe,GAA+B,CACnC/e,KAAM,QACN,MAAAgf,CAAOtI,EAAQuI,EAAY9Y,GACzB,MAAMY,EAAW2P,EAAO3P,SAClBmY,GAA6B,EAApBxI,EAAOyI,aAAwC,EAArBzI,EAAO0I,aAC1CC,EAAgBtY,EAASuC,WAAa4V,EAC5C/Y,EAAIO,OAAOyC,MAAMmW,aACf,CAAE7a,QAASwa,GACXlY,EACA,CACEQ,OAAQ,EACRgY,aAAc7I,EAAO0I,YACrBI,YAAa9I,EAAOyI,WAAaE,GAEnC,CACEtS,MAAO2J,EAAOyI,WACdnS,OAAQ0J,EAAO0I,YACfK,mBAAoB,GAG1B,GCpBIC,GAAe,CACnB,iBAAkB,CAAEC,WAAY,EAAGC,WAAY,EAAGC,YAAa,GAC/D,iBAAkB,CAAEF,WAAY,GAAIC,WAAY,EAAGC,YAAa,GAChE,iBAAkB,CAAEF,WAAY,GAAIC,WAAY,EAAGC,YAAa,GAChE,iBAAkB,CAAEF,WAAY,GAAIC,WAAY,EAAGC,YAAa,GAChE,iBAAkB,CAAEF,WAAY,EAAGC,WAAY,EAAGC,YAAa,GAC/D,kBAAmB,CAAEF,WAAY,GAAIC,WAAY,EAAGC,YAAa,GACjE,iBAAkB,CAAEF,WAAY,GAAIC,WAAY,EAAGC,YAAa,IAE5DC,GAAmB,CAAEH,WAAY,EAAGC,WAAY,EAAGC,YAAa,GAChEE,GAAqC,CACzC/f,KAAM,aACN,MAAAgf,CAAOtI,EAAQuI,EAAY9Y,GACzB,IAAI6Z,EAAWtJ,EAAOyI,WAClBc,EAAYvJ,EAAO0I,YACvB,MAAMc,EAAYR,GAAahJ,EAAOS,SAAW2I,GACjD,IAAK,IAAIvd,EAAI,EAAGA,EAAImU,EAAO3P,SAASqH,OAAQ7L,IAAK,CAC/C,MAAM4d,EAAczJ,EAAO3P,SAASxE,GAC9Bid,EAAc5O,KAAKE,KAAKkP,EAAWE,EAAUN,YAAcM,EAAUP,WAC3ExZ,EAAIO,OAAOyC,MAAMmW,aACf,CACE7a,QAASwa,EACTmB,SAAU7d,GAEZ4d,EACA,CACE5Y,OAAQ,EACRiY,eAEF,CACEzS,MAAO6D,KAAKE,KAAKkP,EAAWE,EAAUN,YAAcM,EAAUN,WAC9D5S,OAAQ4D,KAAKE,KAAKmP,EAAYC,EAAUL,aAAeK,EAAUL,YACjEJ,mBAAoB,IAGxBO,EAAWpP,KAAKC,IAAImP,GAAY,EAAG,GACnCC,EAAYrP,KAAKC,IAAIoP,GAAa,EAAG,EACvC,CACF,GCnCII,GAAyB,CAC7BrgB,KAAM,QACN,MAAAgf,CAAOtI,EAAQuI,EAAY9Y,GACzB,MAAMY,EAAW2P,EAAO3P,SACxB,IAAKA,EACH,OACF,GAAIuZ,WAAWC,kBAAoBxZ,aAAoBwZ,iBAAkB,CACvE,MAAMC,EAAS,IAAWtV,MAAMuV,aAAa1Z,EAASgG,MAAOhG,EAASiG,QACtDwT,EAAOhE,WAAW,MAC1BkE,UAAU3Z,EAAU,EAAG,EAAGA,EAASgG,MAAOhG,EAASiG,QAC3D0J,EAAO3P,SAAWyZ,GAClB,EAAAhc,EAAA,GAAK,kFACP,CACA,MAAMuI,EAAQ6D,KAAK+P,IAAI1B,EAAWlS,MAAO2J,EAAOkK,eAAiBlK,EAAOyI,YAClEnS,EAAS4D,KAAK+P,IAAI1B,EAAWjS,OAAQ0J,EAAOmK,gBAAkBnK,EAAO0I,aACrE0B,EAA0C,gCAArBpK,EAAO+F,UAClCtW,EAAIO,OAAOyC,MAAM4X,2BACf,CAAErK,OAAQ3P,GACV,CAAEtC,QAASwa,EAAY6B,sBACvB,CACE/T,QACAC,UAGN,GCzBIgU,GAAyB,CAC7BhhB,KAAM,QACN,MAAAgf,CAAOtI,EAAQuI,EAAY9Y,GACzBka,GAAuBrB,OAAOtI,EAAQuI,EAAY9Y,EACpD,GCNF,MAAM8a,GACJ,WAAA3hB,CAAYoH,GACVnH,KAAKmH,OAASA,EACdnH,KAAKmI,QAAUhB,EAAOwa,cAAc,CAAEC,UAAW,WACjD5hB,KAAK6hB,UAAY,CAAC,CACpB,CACA,kBAAAC,CAAmBlK,GACjB,IAAI7R,EAAW/F,KAAK6hB,UAAUjK,GAgD9B,OA/CK7R,IACE/F,KAAK+hB,qBACR/hB,KAAK+hB,mBAAqB/hB,KAAKmH,OAAOgR,mBAAmB,CACvDF,KAEE,stCA4BNlS,EAAW/F,KAAKmH,OAAO6Q,qBAAqB,CAC1C3Q,OAAQ,OACR2P,OAAQ,CACNC,OAAQjX,KAAK+hB,mBACb3K,WAAY,cAEdC,SAAU,CACRJ,OAAQjX,KAAK+hB,mBACb3K,WAAY,eACZE,QAAS,CAAC,CAAEM,cAGhB5X,KAAK6hB,UAAUjK,GAAU7R,GAEpBA,CACT,CAMA,cAAAic,CAAe9c,GACb,MAAMa,EAAW/F,KAAK8hB,mBAAmB5c,EAAQ0S,QACjD,GAA0B,OAAtB1S,EAAQ+c,WAA4C,OAAtB/c,EAAQ+c,UACxC,MAAM,IAAI7Q,MAAM,oEAElB,IAAI8Q,EAAahd,EACjB,MAAMid,EAAkBjd,EAAQgb,oBAAsB,EAChDkC,EAAiBld,EAAQiO,MAAQkK,gBAAgBE,kBACvD,IAAK6E,EAAgB,CACnB,MAAMC,EAAuB,CAC3Bve,KAAM,CACJ0J,MAAO6D,KAAKE,KAAKrM,EAAQsI,MAAQ,GACjCC,OAAQ4D,KAAKE,KAAKrM,EAAQuI,OAAS,GACnCyS,mBAAoBiC,GAEtBvK,OAAQ1S,EAAQ0S,OAChBzE,MAAOkK,gBAAgBC,gBAAkBD,gBAAgB/J,SAAW+J,gBAAgBE,kBACpF/B,cAAetW,EAAQsW,cAAgB,GAEzC0G,EAAaliB,KAAKmH,OAAOmb,cAAcD,EACzC,CACA,MAAMxV,EAAiB7M,KAAKmH,OAAO2F,qBAAqB,CAAC,GACnDyV,EAAkBxc,EAASyc,mBAAmB,GACpD,IAAK,IAAIC,EAAa,EAAGA,EAAaN,IAAmBM,EAAY,CACnE,IAAIC,EAAUxd,EAAQoD,WAAW,CAC/Bqa,aAAc,EACdnH,cAAe,EACfyG,UAAW,KACXW,eAAgBH,EAChBN,gBAAiB,IAEfU,EAAcT,EAAiB,EAAI,EACvC,IAAK,IAAIpf,EAAI,EAAGA,EAAIkC,EAAQsW,gBAAiBxY,EAAG,CAC9C,MAAM8f,EAAUZ,EAAW5Z,WAAW,CACpCqa,aAAcE,IACdrH,cAAe,EACfyG,UAAW,KACXW,eAAgBH,EAChBN,gBAAiB,IAEbpM,EAAclJ,EAAeE,gBAAgB,CACjDsO,iBAAkB,CAAC,CACjBC,KAAMwH,EACNjH,QAAS,QACTH,OAAQ,QACRR,WAAY,CAAE6H,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,OAGjC1gB,EAAYxC,KAAKmH,OAAOwB,gBAAgB,CAC5CtB,OAAQkb,EACRjb,QAAS,CAAC,CACRkB,QAAS,EACThB,SAAUxH,KAAKmI,SACd,CACDK,QAAS,EACThB,SAAUkb,MAGd3M,EAAYzP,YAAYP,GACxBgQ,EAAYtT,aAAa,EAAGD,GAC5BuT,EAAYzQ,KAAK,EAAG,EAAG,EAAG,GAC1ByQ,EAAY5I,MACZuV,EAAUI,CACZ,CACF,CACA,IAAKV,EAAgB,CACnB,MAAMe,EAAe,CACnB3V,MAAO6D,KAAKE,KAAKrM,EAAQsI,MAAQ,GACjCC,OAAQ4D,KAAKE,KAAKrM,EAAQuI,OAAS,GACnCyS,mBAAoBiC,GAEtB,IAAK,IAAInf,EAAI,EAAGA,EAAIkC,EAAQsW,gBAAiBxY,EAC3C6J,EAAe8N,qBAAqB,CAClCzV,QAASgd,EACTrB,SAAU7d,EAAI,GACb,CACDkC,UACA2b,SAAU7d,GACTmgB,GACHA,EAAa3V,MAAQ6D,KAAKE,KAAK4R,EAAa3V,MAAQ,GACpD2V,EAAa1V,OAAS4D,KAAKE,KAAK4R,EAAa1V,OAAS,EAE1D,CAKA,OAJAzN,KAAKmH,OAAOyC,MAAMqF,OAAO,CAACpC,EAAeqC,WACpCkT,GACHF,EAAWle,UAENkB,CACT,EC1IF,MAAMke,GACJ,WAAArjB,CAAY2f,GACV1f,KAAKqjB,YAAc,KACnBrjB,KAAK0f,WAAaA,CACpB,CAEA,OAAA1b,GACEhE,KAAK0f,WAAW1b,UAChBhE,KAAKqjB,YAAc,KACnBrjB,KAAK0f,WAAa,IACpB,EAEF,MAAM4D,GACJ,WAAAvjB,CAAYI,GACVH,KAAKujB,aAA+B9c,OAAOC,OAAO,MAClD1G,KAAK8S,eAAiCrM,OAAOC,OAAO,MACpD1G,KAAKwjB,SAAW,CACdC,MAAO3C,GACPhZ,OAAQ0X,GACRkE,MAAOjC,GACPkC,WAAYnD,IAEdxgB,KAAK2G,UAAYxG,EACjBA,EAASyjB,aAAaC,eAAe7jB,KAAM,kBAC3CA,KAAK8jB,iBAAmB,IAAI7a,EAAA,EAAc,CACxC9I,WACAM,KAAM,WACNyI,SAAUlJ,KAAK+jB,eAAe3a,KAAKpJ,MACnCgB,KAAM,oBAEV,CAIA,mBAAIgjB,GACF,OAAOvd,OAAO0S,OAAOnZ,KAAK8jB,iBAAiBG,MAC7C,CACA,aAAA/jB,CAAc0G,GACZ5G,KAAK6G,KAAOD,CACd,CAMA,UAAAsd,CAAW/M,GACT,OAAOA,EAAO7N,SAAStJ,KAAK2G,UAAU4C,MAAMmW,YAAc1f,KAAKmkB,YAAYhN,EAC7E,CACA,WAAAgN,CAAYhN,GACV,GAAIA,EAAOiN,oBAAqB,CAC9B,MAAMC,EAAmBhT,KAAKC,IAAI6F,EAAOyI,WAAYzI,EAAO0I,aAC5D1I,EAAOqE,cAAgBnK,KAAKiT,MAAMjT,KAAKkT,KAAKF,IAAqB,CACnE,CACA,IAAIlR,EAAQkK,gBAAgBC,gBAAkBD,gBAAgBhK,SAChC,eAA1B8D,EAAOqN,iBACTrR,GAASkK,gBAAgBE,kBACzBpK,GAASkK,gBAAgB/J,UAE3B,MAAMqN,EAAYR,GAAahJ,EAAOS,SAAW,CAAEwI,WAAY,EAAGC,WAAY,EAAGC,YAAa,GACxF9S,EAAQ6D,KAAKE,KAAK4F,EAAOyI,WAAae,EAAUN,YAAcM,EAAUN,WACxE5S,EAAS4D,KAAKE,KAAK4F,EAAO0I,YAAcc,EAAUL,aAAeK,EAAUL,YAC3EmE,EAAoB,CACxB/M,MAAOP,EAAOO,MACd5T,KAAM,CAAE0J,QAAOC,UACfmK,OAAQT,EAAOS,OACfsE,YAAa/E,EAAO+E,YACpBV,cAAerE,EAAOqE,cACtByG,UAAW9K,EAAO8K,UAClB9O,SAEIuM,EAAa1f,KAAK6G,KAAKM,OAAOmb,cAAcmC,GASlD,OARAtN,EAAO7N,SAAStJ,KAAK2G,UAAU4C,KAAO,IAAI6Z,GAAkB1D,GAC9C1f,KAAK8jB,iBAAiBrZ,IAAI0M,KAEtCA,EAAOzM,GAAG,SAAU1K,KAAK0kB,eAAgB1kB,MACzCmX,EAAOzM,GAAG,SAAU1K,KAAK2kB,eAAgB3kB,MACzCmX,EAAOzM,GAAG,gBAAiB1K,KAAK4kB,gBAAiB5kB,OAEnDA,KAAK0kB,eAAevN,GACbuI,CACT,CACA,cAAAgF,CAAevN,GACb,MAAMuI,EAAa1f,KAAKqI,aAAa8O,GAChCuI,IAED1f,KAAKwjB,SAASrM,EAAOqN,iBACvBxkB,KAAKwjB,SAASrM,EAAOqN,gBAAgB/E,OAAOtI,EAAQuI,EAAY1f,KAAK6G,MAEnEsQ,EAAOiN,qBAAuBjN,EAAOqE,cAAgB,GACvDxb,KAAK4kB,gBAAgBzN,GAEzB,CACA,eAAAyN,CAAgBzN,GACTnX,KAAK6kB,mBACR7kB,KAAK6kB,iBAAmB,IAAInD,GAAmB1hB,KAAK6G,KAAKM,SAE3D,MAAMuY,EAAa1f,KAAKqI,aAAa8O,GACrCnX,KAAK6kB,iBAAiB7C,eAAetC,EACvC,CACA,cAAAqE,CAAe5M,GACbA,EAAOjN,IAAI,SAAUlK,KAAK0kB,eAAgB1kB,MAC1CmX,EAAOjN,IAAI,SAAUlK,KAAK2kB,eAAgB3kB,MAC1CmX,EAAOjN,IAAI,gBAAiBlK,KAAK4kB,gBAAiB5kB,KACpD,CACA,cAAA2kB,CAAexN,GACbA,EAAO9N,YAAcrJ,KAAK2G,UAAUR,GAAGC,IACvC,MAAM0e,EAAU3N,EAAO7N,SAAStJ,KAAK2G,UAAU4C,KACzCmW,EAAaoF,GAASpF,WACvBA,EAEMA,EAAWlS,QAAU2J,EAAOyI,YAAcF,EAAWjS,SAAW0J,EAAO0I,cAChFiF,EAAQ9gB,UACRhE,KAAK8S,eAAeqE,EAAO5N,KAAO,KAClC4N,EAAO7N,SAAStJ,KAAK2G,UAAU4C,KAAO,KACtCvJ,KAAKkkB,WAAW/M,IALhBnX,KAAKkkB,WAAW/M,EAOpB,CACA,YAAA4N,CAAa5c,GAEX,OADAnI,KAAKujB,aAAapb,EAAQkC,aAAerK,KAAK6G,KAAKM,OAAOwa,cAAcxZ,GACjEnI,KAAKujB,aAAapb,EAAQkC,YACnC,CACA,aAAAjC,CAAcD,GACZ,OAAOnI,KAAKujB,aAAapb,EAAQkC,cAAgBrK,KAAK+kB,aAAa5c,EACrE,CACA,YAAAE,CAAa8O,GAEX,OADAA,EAAO9N,YAAcrJ,KAAK2G,UAAUR,GAAGC,IAChC+Q,EAAO7N,SAAStJ,KAAK2G,UAAU4C,MAAMmW,YAAc1f,KAAKkkB,WAAW/M,EAC5E,CAUA,mBAAAhS,CAAoBD,GAClB,OAAOlF,KAAK8S,eAAe5N,EAAQqE,MAAQvJ,KAAKglB,wBAAwB9f,EAC1E,CACA,uBAAA8f,CAAwB9f,GACtB,MAAMiS,EAASjS,EAAQiS,OAQvB,OAPAnX,KAAK8S,eAAe5N,EAAQqE,KAAO,IAAI6K,EAAA,EAAU,CAC/C,EAAG+C,EACH,EAAGA,EAAOvS,MACV,EAAG,IAAIvE,EAAA,EAAa,CAClByE,eAAgB,CAAErE,KAAM,cAAeF,MAAO2E,EAAQ+f,cAAcC,cAGjEllB,KAAK8S,eAAe5N,EAAQqE,IACrC,CACA,cAAAkS,CAAevW,GACb,MAAMiS,EAASjS,EAAQiS,OACvBA,EAAO9N,YAAcrJ,KAAK2G,UAAUR,GAAGC,IACvC,IAAI0e,EAAU3N,EAAO7N,SAAStJ,KAAK2G,UAAU4C,KACzC8Z,EAAc,KAMlB,OALKyB,IACH9kB,KAAKkkB,WAAW/M,GAChB2N,EAAU3N,EAAO7N,SAAStJ,KAAK2G,UAAU4C,MAE3C8Z,EAAcyB,EAAQzB,aAAeyB,EAAQpF,WAAWpX,aACjD+a,CACT,CACA,cAAA8B,CAAejgB,GACb,MAAM/E,EAAWH,KAAK2G,UAChBkG,EAAiB1M,EAASyG,IAAIO,OAAO2F,uBACrCmU,EAAS,IAAWtV,MAAMuV,eAChCD,EAAOzT,MAAQtI,EAAQiS,OAAOyI,WAC9BqB,EAAOxT,OAASvI,EAAQiS,OAAO0I,YAC/B,MAAMje,EAAUqf,EAAOhE,WAAW,UAoBlC,OAnBArb,EAAQwb,UAAU,CAChBjW,OAAQhH,EAASyG,IAAIO,OACrBgM,MAAOkK,gBAAgBhK,SAAWgK,gBAAgB/J,SAClDsE,OAAQ,IAAWjM,MAAMC,eAAehF,IAAIwe,2BAC5ClI,UAAW,kBAEbrQ,EAAe8N,qBAAqB,CAClCzV,QAAS/E,EAAS+E,QAAQmD,aAAanD,EAAQiS,QAC/CyD,OAAQ,CACNtN,EAAG,EACHC,EAAG,IAEJ,CACDrI,QAAStD,EAAQoZ,qBAChB,CACDxN,MAAOyT,EAAOzT,MACdC,OAAQwT,EAAOxT,SAEjBtN,EAASyG,IAAIO,OAAOyC,MAAMqF,OAAO,CAACpC,EAAeqC,WAC1C+R,CACT,CACA,SAAAoE,CAAUngB,GACR,MAAMogB,EAAetlB,KAAKmlB,eAAejgB,GACnCqgB,EAAmBC,GAAA,EAAWC,2BAA2BH,EAAa9X,MAAO8X,EAAa7X,QAC1F7L,EAAU2jB,EAAiB3jB,QACjCA,EAAQuf,UAAUmE,EAAc,EAAG,GACnC,MAAM,MAAE9X,EAAK,OAAEC,GAAW6X,EACpBI,EAAY9jB,EAAQ+jB,aAAa,EAAG,EAAGnY,EAAOC,GAC9CmY,EAAS,IAAIC,kBAAkBH,EAAUhc,KAAK5B,QAEpD,OADA0d,GAAA,EAAWM,uBAAuBP,GAC3B,CAAEK,SAAQpY,QAAOC,SAC1B,CACA,OAAAzJ,GACEhE,KAAK8jB,iBAAiB9f,UACtB,IAAK,MAAM+hB,KAAKtf,OAAO6R,KAAKtY,KAAK8S,gBAAiB,CAChD,MAAMsD,EAAM4P,OAAOD,GACbvjB,EAAYxC,KAAK8S,eAAesD,GACtC5T,GAAWwB,SACb,CACAhE,KAAK2G,UAAY,KACjB3G,KAAK6G,KAAO,KACZ7G,KAAK6kB,iBAAmB,KACxB7kB,KAAKujB,aAAe,KACpBvjB,KAAK8S,eAAiB,IACxB,EAGFwQ,GAAiBrf,UAAY,CAC3BxD,KAAM,CACJ,KAAcmI,cAEhB5H,KAAM,WCnNR,MAAMilB,GAAuB,IACxBC,EAAA,EACHnU,EACAxF,EACAtB,EACA2E,EACA7G,EACAua,GACAnF,GACAE,GACAc,GACAxK,GACA/J,EACAmF,EACAxJ,GAEI4f,GAAqB,IAAI,IAAmBtT,GAC5CuT,GAAwB,CAACzgB,EAAiBxB,EAAgBrE,GAC1DumB,GAAU,GACV1jB,GAAc,GACd2jB,GAAqB,GAC3B,KAAWC,kBAAkB,KAAc3d,aAAcyd,IACzD,KAAWE,kBAAkB,KAAc9R,YAAa9R,IACxD,KAAW4jB,kBAAkB,KAAcriB,mBAAoBoiB,IAC/D,KAAW7b,OAAOwb,MAAyBE,MAAuBC,IAClE,MAAMI,WAAuBC,EAAA,EAC3B,WAAA1mB,GAQEkS,MAPqB,CACnBjR,KAAM,SACNP,KAAM,IAAaimB,OACnBL,WACA1jB,eACA2jB,uBAGJ,E","sources":["webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GpuGraphicsAdaptor {\n  constructor() {\n    this._maxTextures = 0;\n  }\n  contextChange(renderer) {\n    const localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this._maxTextures = renderer.limits.maxBatchableTextures;\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"graphics\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(this._maxTextures),\n        localUniformBitGroup2,\n        roundPixelsBit\n      ]\n    });\n    this.shader = new Shader({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      batcher,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    let topology = null;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      if (batch.topology !== topology) {\n        topology = batch.topology;\n        encoder.setPipelineFromGeometryProgramAndState(\n          batcher.geometry,\n          shader.gpuProgram,\n          graphicsPipe.state,\n          batch.topology\n        );\n      }\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = getTextureBatchBindGroup(\n          textureBatch.textures,\n          textureBatch.count,\n          this._maxTextures\n        );\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n          batch.bindGroup,\n          shader.gpuProgram,\n          1\n        );\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexport { GpuGraphicsAdaptor };\n//# sourceMappingURL=GpuGraphicsAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nclass GpuMeshAdapter {\n  init() {\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"mesh\",\n      bits: [\n        localUniformBit,\n        textureBit,\n        roundPixelsBit\n      ]\n    });\n    this._shader = new Shader({\n      gpuProgram,\n      resources: {\n        uTexture: Texture.EMPTY._source,\n        uSampler: Texture.EMPTY._source.style,\n        textureUniforms: {\n          uTextureMatrix: { type: \"mat3x3<f32>\", value: new Matrix() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n    } else if (!shader.gpuProgram) {\n      warn(\"Mesh shader has no gpuProgram\", mesh.shader);\n      return;\n    }\n    const gpuProgram = shader.gpuProgram;\n    if (gpuProgram.autoAssignGlobalUniforms) {\n      shader.groups[0] = renderer.globalUniforms.bindGroup;\n    }\n    if (gpuProgram.autoAssignLocalUniforms) {\n      const localUniforms = meshPipe.localUniforms;\n      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n    }\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuMeshAdapter.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"mesh\"\n};\n\nexport { GpuMeshAdapter };\n//# sourceMappingURL=GpuMeshAdapter.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup.mjs';\n\n\"use strict\";\nconst tempState = State.for2d();\nclass GpuBatchAdaptor {\n  start(batchPipe, geometry, shader) {\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    const program = shader.gpuProgram;\n    this._shader = shader;\n    this._geometry = geometry;\n    encoder.setGeometry(geometry, program);\n    tempState.blendMode = \"normal\";\n    renderer.pipeline.getPipeline(\n      geometry,\n      program,\n      tempState\n    );\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.resetBindGroup(1);\n    encoder.setBindGroup(0, globalUniformsBindGroup, program);\n  }\n  execute(batchPipe, batch) {\n    const program = this._shader.gpuProgram;\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    if (!batch.bindGroup) {\n      const textureBatch = batch.textures;\n      batch.bindGroup = getTextureBatchBindGroup(\n        textureBatch.textures,\n        textureBatch.count,\n        renderer.limits.maxBatchableTextures\n      );\n    }\n    tempState.blendMode = batch.blendMode;\n    const gpuBindGroup = renderer.bindGroup.getBindGroup(\n      batch.bindGroup,\n      program,\n      1\n    );\n    const pipeline = renderer.pipeline.getPipeline(\n      this._geometry,\n      program,\n      tempState,\n      batch.topology\n    );\n    batch.bindGroup._touch(renderer.gc.now, renderer.tick);\n    encoder.setPipeline(pipeline);\n    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n  }\n}\n/** @ignore */\nGpuBatchAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"batch\"\n};\n\nexport { GpuBatchAdaptor };\n//# sourceMappingURL=GpuBatchAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass BindGroupSystem {\n  constructor(renderer) {\n    this._hash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getBindGroup(bindGroup, program, groupIndex) {\n    bindGroup._updateKey();\n    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n    return gpuBindGroup;\n  }\n  _createBindGroup(group, program, groupIndex) {\n    const device = this._gpu.device;\n    const groupLayout = program.layout[groupIndex];\n    const entries = [];\n    const renderer = this._renderer;\n    for (const j in groupLayout) {\n      const resource = group.resources[j] ?? group.resources[groupLayout[j]];\n      let gpuResource;\n      if (resource._resourceType === \"uniformGroup\") {\n        const uniformGroup = resource;\n        renderer.ubo.updateUniformGroup(uniformGroup);\n        const buffer = uniformGroup.buffer;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"buffer\") {\n        const buffer = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"bufferResource\") {\n        const bufferResource = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n          offset: bufferResource.offset,\n          size: bufferResource.size\n        };\n      } else if (resource._resourceType === \"textureSampler\") {\n        const sampler = resource;\n        gpuResource = renderer.texture.getGpuSampler(sampler);\n      } else if (resource._resourceType === \"textureSource\") {\n        const texture = resource;\n        gpuResource = renderer.texture.getGpuSource(texture).createView();\n      }\n      entries.push({\n        binding: groupLayout[j],\n        resource: gpuResource\n      });\n    }\n    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n    const gpuBindGroup = device.createBindGroup({\n      layout,\n      entries\n    });\n    this._hash[group._key] = gpuBindGroup;\n    return gpuBindGroup;\n  }\n  destroy() {\n    this._hash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBindGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"bindGroup\"\n};\n\nexport { BindGroupSystem };\n//# sourceMappingURL=BindGroupSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy.mjs';\n\n\"use strict\";\nclass GpuBufferData {\n  constructor(gpuBuffer) {\n    this.gpuBuffer = gpuBuffer;\n  }\n  destroy() {\n    this.gpuBuffer.destroy();\n    this.gpuBuffer = null;\n  }\n}\nclass GpuBufferSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._managedBuffers = new GCManagedHash({\n      renderer,\n      type: \"resource\",\n      onUnload: this.onBufferUnload.bind(this),\n      name: \"gpuBuffer\"\n    });\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getGPUBuffer(buffer) {\n    buffer._gcLastUsed = this._renderer.gc.now;\n    return buffer._gpuData[this._renderer.uid]?.gpuBuffer || this.createGPUBuffer(buffer);\n  }\n  updateBuffer(buffer) {\n    const gpuBuffer = this.getGPUBuffer(buffer);\n    const data = buffer.data;\n    if (buffer._updateID && data) {\n      buffer._updateID = 0;\n      this._gpu.device.queue.writeBuffer(\n        gpuBuffer,\n        0,\n        data.buffer,\n        0,\n        // round to the nearest 4 bytes\n        (buffer._updateSize || data.byteLength) + 3 & ~3\n      );\n    }\n    return gpuBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    this._managedBuffers.removeAll();\n  }\n  onBufferUnload(buffer) {\n    buffer.off(\"update\", this.updateBuffer, this);\n    buffer.off(\"change\", this.onBufferChange, this);\n  }\n  createGPUBuffer(buffer) {\n    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n    buffer._updateID = 0;\n    buffer._resourceId = uid(\"resource\");\n    if (buffer.data) {\n      fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n      gpuBuffer.unmap();\n    }\n    buffer._gpuData[this._renderer.uid] = new GpuBufferData(gpuBuffer);\n    if (this._managedBuffers.add(buffer)) {\n      buffer.on(\"update\", this.updateBuffer, this);\n      buffer.on(\"change\", this.onBufferChange, this);\n    }\n    return gpuBuffer;\n  }\n  onBufferChange(buffer) {\n    this._managedBuffers.remove(buffer);\n    buffer._updateID = 0;\n    this.createGPUBuffer(buffer);\n  }\n  destroy() {\n    this._managedBuffers.destroy();\n    this._renderer = null;\n    this._gpu = null;\n  }\n}\n/** @ignore */\nGpuBufferSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"buffer\"\n};\n\nexport { GpuBufferData, GpuBufferSystem };\n//# sourceMappingURL=GpuBufferSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask)\n      return;\n    this._colorMaskCache = colorMask;\n    this._renderer.pipeline.setColorMask(colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorMaskCache = null;\n  }\n}\n/** @ignore */\nGpuColorMaskSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"colorMask\"\n};\n\nexport { GpuColorMaskSystem };\n//# sourceMappingURL=GpuColorMaskSystem.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuDeviceSystem {\n  /**\n   * @param {WebGPURenderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  async init(options) {\n    if (this._initPromise)\n      return this._initPromise;\n    this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options)).then((gpu) => {\n      this.gpu = gpu;\n      this._renderer.runners.contextChange.emit(this.gpu);\n    });\n    return this._initPromise;\n  }\n  /**\n   * Handle the context change event\n   * @param gpu\n   */\n  contextChange(gpu) {\n    this._renderer.gpu = gpu;\n  }\n  /**\n   * Helper class to create a WebGL Context\n   * @param {object} options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */\n  async _createDeviceAndAdaptor(options) {\n    const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({\n      powerPreference: options.powerPreference,\n      forceFallbackAdapter: options.forceFallbackAdapter\n    });\n    const requiredFeatures = [\n      \"texture-compression-bc\",\n      \"texture-compression-astc\",\n      \"texture-compression-etc2\"\n    ].filter((feature) => adapter.features.has(feature));\n    const device = await adapter.requestDevice({\n      requiredFeatures\n    });\n    return { adapter, device };\n  }\n  destroy() {\n    this.gpu = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuDeviceSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"device\"\n};\n/** The default options for the GpuDeviceSystem. */\nGpuDeviceSystem.defaultOptions = {\n  /**\n   * {@link WebGPUOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * Force the use of the fallback adapter\n   * @default false\n   */\n  forceFallbackAdapter: false\n};\n\nexport { GpuDeviceSystem };\n//# sourceMappingURL=GpuDeviceSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuEncoderSystem {\n  constructor(renderer) {\n    this._boundBindGroup = /* @__PURE__ */ Object.create(null);\n    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  renderStart() {\n    this.commandFinished = new Promise((resolve) => {\n      this._resolveCommandFinished = resolve;\n    });\n    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n  }\n  beginRenderPass(gpuRenderTarget) {\n    this.endRenderPass();\n    this._clearCache();\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n  }\n  endRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n    }\n    this.renderPassEncoder = null;\n  }\n  setViewport(viewport) {\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n  }\n  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {\n    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n    this.setPipeline(pipeline);\n  }\n  setPipeline(pipeline) {\n    if (this._boundPipeline === pipeline)\n      return;\n    this._boundPipeline = pipeline;\n    this.renderPassEncoder.setPipeline(pipeline);\n  }\n  _setVertexBuffer(index, buffer) {\n    if (this._boundVertexBuffer[index] === buffer)\n      return;\n    this._boundVertexBuffer[index] = buffer;\n    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n  }\n  _setIndexBuffer(buffer) {\n    if (this._boundIndexBuffer === buffer)\n      return;\n    this._boundIndexBuffer = buffer;\n    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? \"uint16\" : \"uint32\";\n    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n  }\n  resetBindGroup(index) {\n    this._boundBindGroup[index] = null;\n  }\n  setBindGroup(index, bindGroup, program) {\n    if (this._boundBindGroup[index] === bindGroup)\n      return;\n    this._boundBindGroup[index] = bindGroup;\n    bindGroup._touch(this._renderer.gc.now, this._renderer.tick);\n    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n  }\n  setGeometry(geometry, program) {\n    const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n    for (const i in buffersToBind) {\n      this._setVertexBuffer(parseInt(i, 10), geometry.attributes[buffersToBind[i]].buffer);\n    }\n    if (geometry.indexBuffer) {\n      this._setIndexBuffer(geometry.indexBuffer);\n    }\n  }\n  _setShaderBindGroups(shader, skipSync) {\n    for (const i in shader.groups) {\n      const bindGroup = shader.groups[i];\n      if (!skipSync) {\n        this._syncBindGroup(bindGroup);\n      }\n      this.setBindGroup(i, bindGroup, shader.gpuProgram);\n    }\n  }\n  _syncBindGroup(bindGroup) {\n    for (const j in bindGroup.resources) {\n      const resource = bindGroup.resources[j];\n      if (resource.isUniformGroup) {\n        this._renderer.ubo.updateUniformGroup(resource);\n      }\n    }\n  }\n  draw(options) {\n    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n    this.setGeometry(geometry, shader.gpuProgram);\n    this._setShaderBindGroups(shader, skipSync);\n    if (geometry.indexBuffer) {\n      this.renderPassEncoder.drawIndexed(\n        size || geometry.indexBuffer.data.length,\n        instanceCount ?? geometry.instanceCount,\n        start || 0\n      );\n    } else {\n      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n    }\n  }\n  finishRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n      this.renderPassEncoder = null;\n    }\n  }\n  postrender() {\n    this.finishRenderPass();\n    this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n    this._resolveCommandFinished();\n    this.commandEncoder = null;\n  }\n  // restores a render pass if finishRenderPass was called\n  // not optimised as really used for debugging!\n  // used when we want to stop drawing and log a texture..\n  restoreRenderPass() {\n    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(\n      this._renderer.renderTarget.renderTarget,\n      false,\n      [0, 0, 0, 1]\n    );\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n    const boundPipeline = this._boundPipeline;\n    const boundVertexBuffer = { ...this._boundVertexBuffer };\n    const boundIndexBuffer = this._boundIndexBuffer;\n    const boundBindGroup = { ...this._boundBindGroup };\n    this._clearCache();\n    const viewport = this._renderer.renderTarget.viewport;\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    this.setPipeline(boundPipeline);\n    for (const i in boundVertexBuffer) {\n      this._setVertexBuffer(i, boundVertexBuffer[i]);\n    }\n    for (const i in boundBindGroup) {\n      this.setBindGroup(i, boundBindGroup[i], null);\n    }\n    this._setIndexBuffer(boundIndexBuffer);\n  }\n  _clearCache() {\n    for (let i = 0; i < 16; i++) {\n      this._boundBindGroup[i] = null;\n      this._boundVertexBuffer[i] = null;\n    }\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this._gpu = null;\n    this._boundBindGroup = null;\n    this._boundVertexBuffer = null;\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n}\n/** @ignore */\nGpuEncoderSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"encoder\",\n  priority: 1\n};\n\nexport { GpuEncoderSystem };\n//# sourceMappingURL=GpuEncoderSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuLimitsSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  contextChange() {\n    this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;\n    this.maxBatchableTextures = this.maxTextures;\n  }\n  destroy() {\n  }\n}\n/** @ignore */\nGpuLimitsSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"limits\"\n};\n\nexport { GpuLimitsSystem };\n//# sourceMappingURL=GpuLimitsSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { STENCIL_MODES } from '../shared/state/const.mjs';\n\n\"use strict\";\nclass GpuStencilSystem {\n  constructor(renderer) {\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  onRenderTargetChange(renderTarget) {\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: STENCIL_MODES.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this._activeRenderTarget = renderTarget;\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    const renderer = this._renderer;\n    renderer.pipeline.setStencilMode(stencilMode);\n    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n  }\n  destroy() {\n    this._renderer.renderTarget.onRenderTargetChange.remove(this);\n    this._renderer = null;\n    this._activeRenderTarget = null;\n    this._renderTargetStencilState = null;\n  }\n}\n/** @ignore */\nGpuStencilSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"stencil\"\n};\n\nexport { GpuStencilSystem };\n//# sourceMappingURL=GpuStencilSystem.mjs.map\n","\"use strict\";\nconst WGSL_ALIGN_SIZE_DATA = {\n  i32: { align: 4, size: 4 },\n  u32: { align: 4, size: 4 },\n  f32: { align: 4, size: 4 },\n  f16: { align: 2, size: 2 },\n  \"vec2<i32>\": { align: 8, size: 8 },\n  \"vec2<u32>\": { align: 8, size: 8 },\n  \"vec2<f32>\": { align: 8, size: 8 },\n  \"vec2<f16>\": { align: 4, size: 4 },\n  \"vec3<i32>\": { align: 16, size: 12 },\n  \"vec3<u32>\": { align: 16, size: 12 },\n  \"vec3<f32>\": { align: 16, size: 12 },\n  \"vec3<f16>\": { align: 8, size: 6 },\n  \"vec4<i32>\": { align: 16, size: 16 },\n  \"vec4<u32>\": { align: 16, size: 16 },\n  \"vec4<f32>\": { align: 16, size: 16 },\n  \"vec4<f16>\": { align: 8, size: 8 },\n  \"mat2x2<f32>\": { align: 8, size: 16 },\n  \"mat2x2<f16>\": { align: 4, size: 8 },\n  \"mat3x2<f32>\": { align: 8, size: 24 },\n  \"mat3x2<f16>\": { align: 4, size: 12 },\n  \"mat4x2<f32>\": { align: 8, size: 32 },\n  \"mat4x2<f16>\": { align: 4, size: 16 },\n  \"mat2x3<f32>\": { align: 16, size: 32 },\n  \"mat2x3<f16>\": { align: 8, size: 16 },\n  \"mat3x3<f32>\": { align: 16, size: 48 },\n  \"mat3x3<f16>\": { align: 8, size: 24 },\n  \"mat4x3<f32>\": { align: 16, size: 64 },\n  \"mat4x3<f16>\": { align: 8, size: 32 },\n  \"mat2x4<f32>\": { align: 16, size: 32 },\n  \"mat2x4<f16>\": { align: 8, size: 16 },\n  \"mat3x4<f32>\": { align: 16, size: 48 },\n  \"mat3x4<f16>\": { align: 8, size: 24 },\n  \"mat4x4<f32>\": { align: 16, size: 64 },\n  \"mat4x4<f16>\": { align: 8, size: 32 }\n};\nfunction createUboElementsWGSL(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {\n      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, align) * uboElement.data.size;\n    }\n    offset = Math.ceil(offset / align) * align;\n    uboElement.size = size;\n    uboElement.offset = offset;\n    offset += size;\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\nexport { WGSL_ALIGN_SIZE_DATA, createUboElementsWGSL };\n//# sourceMappingURL=createUboElementsWGSL.mjs.map\n","import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL.mjs';\n\n\"use strict\";\nfunction generateArraySyncWGSL(uboElement, offsetToAdd) {\n  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n  const remainder = (align - size) / 4;\n  const data = uboElement.data.type.indexOf(\"i32\") >= 0 ? \"dataInt32\" : \"data\";\n  return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : \"\"}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : \"\"}\n         }\n     `;\n}\n\nexport { generateArraySyncWGSL };\n//# sourceMappingURL=generateArraySyncWGSL.mjs.map\n","import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction.mjs';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions.mjs';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL.mjs';\n\n\"use strict\";\nfunction createUboSyncFunctionWGSL(uboElements) {\n  return createUboSyncFunction(\n    uboElements,\n    \"uboWgsl\",\n    generateArraySyncWGSL,\n    uboSyncFunctionsWGSL\n  );\n}\n\nexport { createUboSyncFunctionWGSL };\n//# sourceMappingURL=createUboSyncFunctionWGSL.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { UboSystem } from '../shared/shader/UboSystem.mjs';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL.mjs';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL.mjs';\n\n\"use strict\";\nclass GpuUboSystem extends UboSystem {\n  constructor() {\n    super({\n      createUboElements: createUboElementsWGSL,\n      generateUboSync: createUboSyncFunctionWGSL\n    });\n  }\n}\n/** @ignore */\nGpuUboSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"ubo\"\n};\n\nexport { GpuUboSystem };\n//# sourceMappingURL=GpuUboSystem.mjs.map\n","\"use strict\";\nclass UboBatch {\n  constructor({ minUniformOffsetAlignment }) {\n    this._minUniformOffsetAlignment = 256;\n    this.byteIndex = 0;\n    this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n    this.data = new Float32Array(65535);\n  }\n  clear() {\n    this.byteIndex = 0;\n  }\n  addEmptyGroup(size) {\n    if (size > this._minUniformOffsetAlignment / 4) {\n      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n    }\n    const start = this.byteIndex;\n    let newSize = start + size * 4;\n    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n    if (newSize > this.data.length * 4) {\n      throw new Error(\"UniformBufferBatch: ubo batch got too big\");\n    }\n    this.byteIndex = newSize;\n    return start;\n  }\n  addGroup(array) {\n    const offset = this.addEmptyGroup(array.length);\n    for (let i = 0; i < array.length; i++) {\n      this.data[offset / 4 + i] = array[i];\n    }\n    return offset;\n  }\n  destroy() {\n    this.data = null;\n  }\n}\n\nexport { UboBatch };\n//# sourceMappingURL=UboBatch.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Buffer } from '../shared/buffer/Buffer.mjs';\nimport { BufferResource } from '../shared/buffer/BufferResource.mjs';\nimport { BufferUsage } from '../shared/buffer/const.mjs';\nimport { UboBatch } from './buffer/UboBatch.mjs';\nimport { BindGroup } from './shader/BindGroup.mjs';\n\n\"use strict\";\nconst minUniformOffsetAlignment = 128;\nclass GpuUniformBatchPipe {\n  constructor(renderer) {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    // number of buffers..\n    this._buffers = [];\n    this._bindGroups = [];\n    this._bufferResources = [];\n    this._renderer = renderer;\n    this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n    const totalBuffers = 256 / minUniformOffsetAlignment;\n    for (let i = 0; i < totalBuffers; i++) {\n      let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n      if (i === 0)\n        usage |= BufferUsage.COPY_SRC;\n      this._buffers.push(new Buffer({\n        data: this._batchBuffer.data,\n        usage\n      }));\n    }\n  }\n  renderEnd() {\n    this._uploadBindGroups();\n    this._resetBindGroups();\n  }\n  _resetBindGroups() {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._batchBuffer.clear();\n  }\n  // just works for single bind groups for now\n  getUniformBindGroup(group, duplicate) {\n    if (!duplicate && this._bindGroupHash[group.uid]) {\n      return this._bindGroupHash[group.uid];\n    }\n    this._renderer.ubo.ensureUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addEmptyGroup(data.length);\n    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n    return this._bindGroupHash[group.uid];\n  }\n  getUboResource(group) {\n    this._renderer.ubo.updateUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBufferResource(offset / minUniformOffsetAlignment);\n  }\n  getArrayBindGroup(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBindGroup(offset / minUniformOffsetAlignment);\n  }\n  getArrayBufferResource(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    const index = offset / minUniformOffsetAlignment;\n    return this._getBufferResource(index);\n  }\n  _getBufferResource(index) {\n    if (!this._bufferResources[index]) {\n      const buffer = this._buffers[index % 2];\n      this._bufferResources[index] = new BufferResource({\n        buffer,\n        offset: (index / 2 | 0) * 256,\n        size: minUniformOffsetAlignment\n      });\n    }\n    return this._bufferResources[index];\n  }\n  _getBindGroup(index) {\n    if (!this._bindGroups[index]) {\n      const bindGroup = new BindGroup({\n        0: this._getBufferResource(index)\n      });\n      this._bindGroups[index] = bindGroup;\n    }\n    return this._bindGroups[index];\n  }\n  _uploadBindGroups() {\n    const bufferSystem = this._renderer.buffer;\n    const firstBuffer = this._buffers[0];\n    firstBuffer.update(this._batchBuffer.byteIndex);\n    bufferSystem.updateBuffer(firstBuffer);\n    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    for (let i = 1; i < this._buffers.length; i++) {\n      const buffer = this._buffers[i];\n      commandEncoder.copyBufferToBuffer(\n        bufferSystem.getGPUBuffer(firstBuffer),\n        minUniformOffsetAlignment,\n        bufferSystem.getGPUBuffer(buffer),\n        0,\n        this._batchBuffer.byteIndex\n      );\n    }\n    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n  }\n  destroy() {\n    for (let i = 0; i < this._bindGroups.length; i++) {\n      this._bindGroups[i]?.destroy();\n    }\n    this._bindGroups = null;\n    this._bindGroupHash = null;\n    for (let i = 0; i < this._buffers.length; i++) {\n      this._buffers[i].destroy();\n    }\n    this._buffers = null;\n    for (let i = 0; i < this._bufferResources.length; i++) {\n      this._bufferResources[i].destroy();\n    }\n    this._bufferResources = null;\n    this._batchBuffer.destroy();\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuUniformBatchPipe.extension = {\n  type: [\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"uniformBatch\"\n};\n\nexport { GpuUniformBatchPipe };\n//# sourceMappingURL=GpuUniformBatchPipe.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes.mjs';\nimport { STENCIL_MODES } from '../../shared/state/const.mjs';\nimport { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi.mjs';\n\n\"use strict\";\nconst topologyStringToId = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 2,\n  \"triangle-list\": 3,\n  \"triangle-strip\": 4\n};\nfunction getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget, colorTargetCount) {\n  return colorMask << 8 | stencilStateId << 5 | renderTarget << 3 | colorTargetCount << 1 | multiSampleCount;\n}\nclass PipelineSystem {\n  constructor(renderer) {\n    this._moduleCache = /* @__PURE__ */ Object.create(null);\n    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);\n    this._bindingNamesCache = /* @__PURE__ */ Object.create(null);\n    this._pipeCache = /* @__PURE__ */ Object.create(null);\n    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);\n    this._colorMask = 15;\n    this._multisampleCount = 1;\n    this._colorTargetCount = 1;\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.setStencilMode(STENCIL_MODES.DISABLED);\n    this._updatePipeHash();\n  }\n  setMultisampleCount(multisampleCount) {\n    if (this._multisampleCount === multisampleCount)\n      return;\n    this._multisampleCount = multisampleCount;\n    this._updatePipeHash();\n  }\n  setRenderTarget(renderTarget) {\n    this._multisampleCount = renderTarget.msaaSamples;\n    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n    this._colorTargetCount = renderTarget.colorTargetCount;\n    this._updatePipeHash();\n  }\n  setColorMask(colorMask) {\n    if (this._colorMask === colorMask)\n      return;\n    this._colorMask = colorMask;\n    this._updatePipeHash();\n  }\n  setStencilMode(stencilMode) {\n    if (this._stencilMode === stencilMode)\n      return;\n    this._stencilMode = stencilMode;\n    this._stencilState = GpuStencilModesToPixi[stencilMode];\n    this._updatePipeHash();\n  }\n  setPipeline(geometry, program, state, passEncoder) {\n    const pipeline = this.getPipeline(geometry, program, state);\n    passEncoder.setPipeline(pipeline);\n  }\n  getPipeline(geometry, program, state, topology) {\n    if (!geometry._layoutKey) {\n      ensureAttributes(geometry, program.attributeData);\n      this._generateBufferKey(geometry);\n    }\n    topology || (topology = geometry.topology);\n    const key = getGraphicsStateKey(\n      geometry._layoutKey,\n      program._layoutKey,\n      state.data,\n      state._blendModeId,\n      topologyStringToId[topology]\n    );\n    if (this._pipeCache[key])\n      return this._pipeCache[key];\n    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n    return this._pipeCache[key];\n  }\n  _createPipeline(geometry, program, state, topology) {\n    const device = this._gpu.device;\n    const buffers = this._createVertexBufferLayouts(geometry, program);\n    const blendModes = this._renderer.state.getColorTargets(state, this._colorTargetCount);\n    const writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n    for (let i = 0; i < blendModes.length; i++) {\n      blendModes[i].writeMask = writeMask;\n    }\n    const layout = this._renderer.shader.getProgramData(program).pipeline;\n    const descriptor = {\n      // TODO later check if its helpful to create..\n      // layout,\n      vertex: {\n        module: this._getModule(program.vertex.source),\n        entryPoint: program.vertex.entryPoint,\n        // geometry..\n        buffers\n      },\n      fragment: {\n        module: this._getModule(program.fragment.source),\n        entryPoint: program.fragment.entryPoint,\n        targets: blendModes\n      },\n      primitive: {\n        topology,\n        cullMode: state.cullMode\n      },\n      layout,\n      multisample: {\n        count: this._multisampleCount\n      },\n      // depthStencil,\n      label: `PIXI Pipeline`\n    };\n    if (this._depthStencilAttachment) {\n      descriptor.depthStencil = {\n        ...this._stencilState,\n        format: \"depth24plus-stencil8\",\n        depthWriteEnabled: state.depthTest,\n        depthCompare: state.depthTest ? \"less\" : \"always\"\n      };\n    }\n    const pipeline = device.createRenderPipeline(descriptor);\n    return pipeline;\n  }\n  _getModule(code) {\n    return this._moduleCache[code] || this._createModule(code);\n  }\n  _createModule(code) {\n    const device = this._gpu.device;\n    this._moduleCache[code] = device.createShaderModule({\n      code\n    });\n    return this._moduleCache[code];\n  }\n  _generateBufferKey(geometry) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(geometry.attributes).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = geometry.attributes[attributeKeys[i]];\n      keyGen[index++] = attribute.offset;\n      keyGen[index++] = attribute.format;\n      keyGen[index++] = attribute.stride;\n      keyGen[index++] = attribute.instance;\n    }\n    const stringKey = keyGen.join(\"|\");\n    geometry._layoutKey = createIdFromString(stringKey, \"geometry\");\n    return geometry._layoutKey;\n  }\n  _generateAttributeLocationsKey(program) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(program.attributeData).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = program.attributeData[attributeKeys[i]];\n      keyGen[index++] = attribute.location;\n    }\n    const stringKey = keyGen.join(\"|\");\n    program._attributeLocationsKey = createIdFromString(stringKey, \"programAttributes\");\n    return program._attributeLocationsKey;\n  }\n  /**\n   * Returns a hash of buffer names mapped to bind locations.\n   * This is used to bind the correct buffer to the correct location in the shader.\n   * @param geometry - The geometry where to get the buffer names\n   * @param program - The program where to get the buffer names\n   * @returns An object of buffer names mapped to the bind location.\n   */\n  getBufferNamesToBind(geometry, program) {\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bindingNamesCache[key])\n      return this._bindingNamesCache[key];\n    const data = this._createVertexBufferLayouts(geometry, program);\n    const bufferNamesToBind = /* @__PURE__ */ Object.create(null);\n    const attributeData = program.attributeData;\n    for (let i = 0; i < data.length; i++) {\n      const attributes = Object.values(data[i].attributes);\n      const shaderLocation = attributes[0].shaderLocation;\n      for (const j in attributeData) {\n        if (attributeData[j].location === shaderLocation) {\n          bufferNamesToBind[i] = j;\n          break;\n        }\n      }\n    }\n    this._bindingNamesCache[key] = bufferNamesToBind;\n    return bufferNamesToBind;\n  }\n  _createVertexBufferLayouts(geometry, program) {\n    if (!program._attributeLocationsKey)\n      this._generateAttributeLocationsKey(program);\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bufferLayoutsCache[key]) {\n      return this._bufferLayoutsCache[key];\n    }\n    const vertexBuffersLayout = [];\n    geometry.buffers.forEach((buffer) => {\n      const bufferEntry = {\n        arrayStride: 0,\n        stepMode: \"vertex\",\n        attributes: []\n      };\n      const bufferEntryAttributes = bufferEntry.attributes;\n      for (const i in program.attributeData) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.divisor ?? 1) !== 1) {\n          warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);\n        }\n        if (attribute.buffer === buffer) {\n          bufferEntry.arrayStride = attribute.stride;\n          bufferEntry.stepMode = attribute.instance ? \"instance\" : \"vertex\";\n          bufferEntryAttributes.push({\n            shaderLocation: program.attributeData[i].location,\n            offset: attribute.offset,\n            format: attribute.format\n          });\n        }\n      }\n      if (bufferEntryAttributes.length) {\n        vertexBuffersLayout.push(bufferEntry);\n      }\n    });\n    this._bufferLayoutsCache[key] = vertexBuffersLayout;\n    return vertexBuffersLayout;\n  }\n  _updatePipeHash() {\n    const key = getGlobalStateKey(\n      this._stencilMode,\n      this._multisampleCount,\n      this._colorMask,\n      this._depthStencilAttachment,\n      this._colorTargetCount\n    );\n    if (!this._pipeStateCaches[key]) {\n      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);\n    }\n    this._pipeCache = this._pipeStateCaches[key];\n  }\n  destroy() {\n    this._renderer = null;\n    this._bufferLayoutsCache = null;\n  }\n}\n/** @ignore */\nPipelineSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"pipeline\"\n};\n\nexport { PipelineSystem };\n//# sourceMappingURL=PipelineSystem.mjs.map\n","\"use strict\";\nclass GpuRenderTarget {\n  constructor() {\n    this.contexts = [];\n    this.msaaTextures = [];\n    this.msaaSamples = 1;\n  }\n}\n\nexport { GpuRenderTarget };\n//# sourceMappingURL=GpuRenderTarget.mjs.map\n","import { CLEAR } from '../../gl/const.mjs';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource.mjs';\nimport { GpuRenderTarget } from './GpuRenderTarget.mjs';\n\n\"use strict\";\nclass GpuRenderTargetAdaptor {\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderer = this._renderer;\n    const baseGpuTexture = this._getGpuColorTexture(\n      sourceRenderSurfaceTexture\n    );\n    const backGpuTexture = renderer.texture.getGpuSource(\n      destinationTexture.source\n    );\n    renderer.encoder.commandEncoder.copyTextureToTexture(\n      {\n        texture: baseGpuTexture,\n        origin: originSrc\n      },\n      {\n        texture: backGpuTexture,\n        origin: originDest\n      },\n      size\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n    gpuRenderTarget.descriptor = descriptor;\n    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n    this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n    this._renderer.encoder.setViewport(viewport);\n  }\n  finishRenderPass() {\n    this._renderer.encoder.endRenderPass();\n  }\n  /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */\n  _getGpuColorTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (gpuRenderTarget.contexts[0]) {\n      return gpuRenderTarget.contexts[0].getCurrentTexture();\n    }\n    return this._renderer.texture.getGpuSource(\n      renderTarget.colorTextures[0].source\n    );\n  }\n  getDescriptor(renderTarget, clear, clearValue) {\n    if (typeof clear === \"boolean\") {\n      clear = clear ? CLEAR.ALL : CLEAR.NONE;\n    }\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const colorAttachments = renderTarget.colorTextures.map(\n      (texture, i) => {\n        const context = gpuRenderTarget.contexts[i];\n        let view;\n        let resolveTarget;\n        if (context) {\n          const currentTexture = context.getCurrentTexture();\n          const canvasTextureView = currentTexture.createView();\n          view = canvasTextureView;\n        } else {\n          view = this._renderer.texture.getGpuSource(texture).createView({\n            mipLevelCount: 1\n          });\n        }\n        if (gpuRenderTarget.msaaTextures[i]) {\n          resolveTarget = view;\n          view = this._renderer.texture.getTextureView(\n            gpuRenderTarget.msaaTextures[i]\n          );\n        }\n        const loadOp = clear & CLEAR.COLOR ? \"clear\" : \"load\";\n        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);\n        return {\n          view,\n          resolveTarget,\n          clearValue,\n          storeOp: \"store\",\n          loadOp\n        };\n      }\n    );\n    let depthStencilAttachment;\n    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n      renderTarget.ensureDepthStencilTexture();\n      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n    }\n    if (renderTarget.depthStencilTexture) {\n      const stencilLoadOp = clear & CLEAR.STENCIL ? \"clear\" : \"load\";\n      const depthLoadOp = clear & CLEAR.DEPTH ? \"clear\" : \"load\";\n      depthStencilAttachment = {\n        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),\n        stencilStoreOp: \"store\",\n        stencilLoadOp,\n        depthClearValue: 1,\n        depthLoadOp,\n        depthStoreOp: \"store\"\n      };\n    }\n    const descriptor = {\n      colorAttachments,\n      depthStencilAttachment\n    };\n    return descriptor;\n  }\n  clear(renderTarget, clear = true, clearColor, viewport) {\n    if (!clear)\n      return;\n    const { gpu, encoder } = this._renderer;\n    const device = gpu.device;\n    const standAlone = encoder.commandEncoder === null;\n    if (standAlone) {\n      const commandEncoder = device.createCommandEncoder();\n      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n      passEncoder.end();\n      const gpuCommands = commandEncoder.finish();\n      device.queue.submit([gpuCommands]);\n    } else {\n      this.startRenderPass(renderTarget, clear, clearColor, viewport);\n    }\n  }\n  initGpuRenderTarget(renderTarget) {\n    renderTarget.isRoot = true;\n    const gpuRenderTarget = new GpuRenderTarget();\n    gpuRenderTarget.colorTargetCount = renderTarget.colorTextures.length;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (colorTexture instanceof CanvasSource) {\n        const context = colorTexture.resource.getContext(\n          \"webgpu\"\n        );\n        const alphaMode = colorTexture.transparent ? \"premultiplied\" : \"opaque\";\n        try {\n          context.configure({\n            device: this._renderer.gpu.device,\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            format: \"bgra8unorm\",\n            alphaMode\n          });\n        } catch (e) {\n          console.error(e);\n        }\n        gpuRenderTarget.contexts[i] = context;\n      }\n      gpuRenderTarget.msaa = colorTexture.source.antialias;\n      if (colorTexture.source.antialias) {\n        const msaaTexture = new TextureSource({\n          width: 0,\n          height: 0,\n          sampleCount: 4\n        });\n        gpuRenderTarget.msaaTextures[i] = msaaTexture;\n      }\n    });\n    if (gpuRenderTarget.msaa) {\n      gpuRenderTarget.msaaSamples = 4;\n      if (renderTarget.depthStencilTexture) {\n        renderTarget.depthStencilTexture.source.sampleCount = 4;\n      }\n    }\n    return gpuRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    gpuRenderTarget.contexts.forEach((context) => {\n      context.unconfigure();\n    });\n    gpuRenderTarget.msaaTextures.forEach((texture) => {\n      texture.destroy();\n    });\n    gpuRenderTarget.msaaTextures.length = 0;\n    gpuRenderTarget.contexts.length = 0;\n  }\n  ensureDepthStencilTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {\n      renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    gpuRenderTarget.width = renderTarget.width;\n    gpuRenderTarget.height = renderTarget.height;\n    if (gpuRenderTarget.msaa) {\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const msaaTexture = gpuRenderTarget.msaaTextures[i];\n        msaaTexture?.resize(\n          colorTexture.source.width,\n          colorTexture.source.height,\n          colorTexture.source._resolution\n        );\n      });\n    }\n  }\n}\n\nexport { GpuRenderTargetAdaptor };\n//# sourceMappingURL=GpuRenderTargetAdaptor.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem.mjs';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor.mjs';\n\n\"use strict\";\nclass GpuRenderTargetSystem extends RenderTargetSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GpuRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGpuRenderTargetSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"renderTarget\"\n};\n\nexport { GpuRenderTargetSystem };\n//# sourceMappingURL=GpuRenderTargetSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuShaderSystem {\n  constructor() {\n    this._gpuProgramData = /* @__PURE__ */ Object.create(null);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getProgramData(program) {\n    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n  }\n  _createGPUProgramData(program) {\n    const device = this._gpu.device;\n    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n    this._gpuProgramData[program._layoutKey] = {\n      bindGroups,\n      pipeline: device.createPipelineLayout(pipelineLayoutDesc)\n    };\n    return this._gpuProgramData[program._layoutKey];\n  }\n  destroy() {\n    this._gpu = null;\n    this._gpuProgramData = null;\n  }\n}\n/** @ignore */\nGpuShaderSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"shader\"\n};\n\nexport { GpuShaderSystem };\n//# sourceMappingURL=GpuShaderSystem.mjs.map\n","\"use strict\";\nconst GpuBlendModesToPixi = {};\nGpuBlendModesToPixi.normal = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.add = {\n  alpha: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.multiply = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"dst\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.screen = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.overlay = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.none = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"zero\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"normal-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"add-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"screen-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.erase = {\n  alpha: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.min = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"min\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"min\"\n  }\n};\nGpuBlendModesToPixi.max = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"max\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"max\"\n  }\n};\n\nexport { GpuBlendModesToPixi };\n//# sourceMappingURL=GpuBlendModesToPixi.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { State } from '../../shared/state/State.mjs';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi.mjs';\n\n\"use strict\";\nclass GpuStateSystem {\n  constructor() {\n    this.defaultState = new State();\n    this.defaultState.blend = true;\n  }\n  contextChange(gpu) {\n    this.gpu = gpu;\n  }\n  /**\n   * Gets the blend mode data for the current state\n   * @param state - The state to get the blend mode from\n   * @param count - The number of color targets to create\n   */\n  getColorTargets(state, count) {\n    const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n    const targets = [];\n    const target = {\n      format: \"bgra8unorm\",\n      writeMask: 0,\n      blend\n    };\n    for (let i = 0; i < count; i++) {\n      targets[i] = target;\n    }\n    return targets;\n  }\n  destroy() {\n    this.gpu = null;\n  }\n}\n/** @ignore */\nGpuStateSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"state\"\n};\n\nexport { GpuStateSystem };\n//# sourceMappingURL=GpuStateSystem.mjs.map\n","\"use strict\";\nconst gpuUploadBufferImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n    const bytesPerPixel = resource.byteLength / total;\n    gpu.device.queue.writeTexture(\n      { texture: gpuTexture },\n      resource,\n      {\n        offset: 0,\n        rowsPerImage: source.pixelHeight,\n        bytesPerRow: source.pixelWidth * bytesPerPixel\n      },\n      {\n        width: source.pixelWidth,\n        height: source.pixelHeight,\n        depthOrArrayLayers: 1\n      }\n    );\n  }\n};\n\nexport { gpuUploadBufferImageResource };\n//# sourceMappingURL=gpuUploadBufferImageResource.mjs.map\n","\"use strict\";\nconst blockDataMap = {\n  \"bc1-rgba-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"bc2-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc3-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc7-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"etc1-rgb-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"etc2-rgba8unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"astc-4x4-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }\n};\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\nconst gpuUploadCompressedTextureResource = {\n  type: \"compressed\",\n  upload(source, gpuTexture, gpu) {\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const blockData = blockDataMap[source.format] || defaultBlockData;\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n      gpu.device.queue.writeTexture(\n        {\n          texture: gpuTexture,\n          mipLevel: i\n        },\n        levelBuffer,\n        {\n          offset: 0,\n          bytesPerRow\n        },\n        {\n          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n          depthOrArrayLayers: 1\n        }\n      );\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\nexport { blockDataMap, gpuUploadCompressedTextureResource };\n//# sourceMappingURL=gpuUploadCompressedTextureResource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst gpuUploadImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    if (!resource)\n      return;\n    if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement) {\n      const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(resource, 0, 0, resource.width, resource.height);\n      source.resource = canvas;\n      warn(\"ImageSource: Image element passed, converting to canvas and replacing resource.\");\n    }\n    const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n    const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n    const premultipliedAlpha = source.alphaMode === \"premultiply-alpha-on-upload\";\n    gpu.device.queue.copyExternalImageToTexture(\n      { source: resource },\n      { texture: gpuTexture, premultipliedAlpha },\n      {\n        width,\n        height\n      }\n    );\n  }\n};\n\nexport { gpuUploadImageResource };\n//# sourceMappingURL=gpuUploadImageSource.mjs.map\n","import { gpuUploadImageResource } from './gpuUploadImageSource.mjs';\n\n\"use strict\";\nconst gpuUploadVideoResource = {\n  type: \"video\",\n  upload(source, gpuTexture, gpu) {\n    gpuUploadImageResource.upload(source, gpuTexture, gpu);\n  }\n};\n\nexport { gpuUploadVideoResource };\n//# sourceMappingURL=gpuUploadVideoSource.mjs.map\n","\"use strict\";\nclass GpuMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({ minFilter: \"linear\" });\n    this.pipelines = {};\n  }\n  _getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      if (!this.mipmapShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: (\n            /* wgsl */\n            `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `\n          )\n        });\n      }\n      pipeline = this.device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"vertexMain\"\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"fragmentMain\",\n          targets: [{ format }]\n        }\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture) {\n    const pipeline = this._getMipmapPipeline(texture.format);\n    if (texture.dimension === \"3d\" || texture.dimension === \"1d\") {\n      throw new Error(\"Generating mipmaps for non-2d textures is currently unsupported!\");\n    }\n    let mipTexture = texture;\n    const arrayLayerCount = texture.depthOrArrayLayers || 1;\n    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(texture.width / 2),\n          height: Math.ceil(texture.height / 2),\n          depthOrArrayLayers: arrayLayerCount\n        },\n        format: texture.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: texture.mipLevelCount - 1\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: \"2d\",\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1\n      });\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: \"2d\",\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1\n        });\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            storeOp: \"store\",\n            loadOp: \"clear\",\n            clearValue: { r: 0, g: 0, b: 0, a: 0 }\n          }]\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler\n          }, {\n            binding: 1,\n            resource: srcView\n          }]\n        });\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n        srcView = dstView;\n      }\n    }\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(texture.width / 2),\n        height: Math.ceil(texture.height / 2),\n        depthOrArrayLayers: arrayLayerCount\n      };\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i - 1\n        }, {\n          texture,\n          mipLevel: i\n        }, mipLevelSize);\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n    return texture;\n  }\n}\n\nexport { GpuMipmapGenerator };\n//# sourceMappingURL=GpuMipmapGenerator.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash.mjs';\nimport { UniformGroup } from '../../shared/shader/UniformGroup.mjs';\nimport { CanvasPool } from '../../shared/texture/CanvasPool.mjs';\nimport { BindGroup } from '../shader/BindGroup.mjs';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource.mjs';\nimport { gpuUploadCompressedTextureResource, blockDataMap } from './uploaders/gpuUploadCompressedTextureResource.mjs';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource.mjs';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource.mjs';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator.mjs';\n\n\"use strict\";\nclass GPUTextureGpuData {\n  constructor(gpuTexture) {\n    this.textureView = null;\n    this.gpuTexture = gpuTexture;\n  }\n  /** Destroys this GPU data instance. */\n  destroy() {\n    this.gpuTexture.destroy();\n    this.textureView = null;\n    this.gpuTexture = null;\n  }\n}\nclass GpuTextureSystem {\n  constructor(renderer) {\n    this._gpuSamplers = /* @__PURE__ */ Object.create(null);\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._uploads = {\n      image: gpuUploadImageResource,\n      buffer: gpuUploadBufferImageResource,\n      video: gpuUploadVideoResource,\n      compressed: gpuUploadCompressedTextureResource\n    };\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_bindGroupHash\");\n    this._managedTextures = new GCManagedHash({\n      renderer,\n      type: \"resource\",\n      onUnload: this.onSourceUnload.bind(this),\n      name: \"gpuTextureSource\"\n    });\n  }\n  /**\n   * @deprecated since 8.15.0\n   */\n  get managedTextures() {\n    return Object.values(this._managedTextures.items);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  /**\n   * Initializes a texture source, if it has already been initialized nothing will happen.\n   * @param source - The texture source to initialize.\n   * @returns The initialized texture source.\n   */\n  initSource(source) {\n    return source._gpuData[this._renderer.uid]?.gpuTexture || this._initSource(source);\n  }\n  _initSource(source) {\n    if (source.autoGenerateMipmaps) {\n      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (source.uploadMethodId !== \"compressed\") {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n      usage |= GPUTextureUsage.COPY_SRC;\n    }\n    const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n    const textureDescriptor = {\n      label: source.label,\n      size: { width, height },\n      format: source.format,\n      sampleCount: source.sampleCount,\n      mipLevelCount: source.mipLevelCount,\n      dimension: source.dimension,\n      usage\n    };\n    const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n    source._gpuData[this._renderer.uid] = new GPUTextureGpuData(gpuTexture);\n    const added = this._managedTextures.add(source);\n    if (added) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceResize, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    }\n    this.onSourceUpdate(source);\n    return gpuTexture;\n  }\n  onSourceUpdate(source) {\n    const gpuTexture = this.getGpuSource(source);\n    if (!gpuTexture)\n      return;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source);\n    }\n  }\n  onUpdateMipmaps(source) {\n    if (!this._mipmapGenerator) {\n      this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n    }\n    const gpuTexture = this.getGpuSource(source);\n    this._mipmapGenerator.generateMipmap(gpuTexture);\n  }\n  onSourceUnload(source) {\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"resize\", this.onSourceResize, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n  }\n  onSourceResize(source) {\n    source._gcLastUsed = this._renderer.gc.now;\n    const gpuData = source._gpuData[this._renderer.uid];\n    const gpuTexture = gpuData?.gpuTexture;\n    if (!gpuTexture) {\n      this.initSource(source);\n    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {\n      gpuData.destroy();\n      this._bindGroupHash[source.uid] = null;\n      source._gpuData[this._renderer.uid] = null;\n      this.initSource(source);\n    }\n  }\n  _initSampler(sampler) {\n    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n    return this._gpuSamplers[sampler._resourceId];\n  }\n  getGpuSampler(sampler) {\n    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGpuSource(source) {\n    source._gcLastUsed = this._renderer.gc.now;\n    return source._gpuData[this._renderer.uid]?.gpuTexture || this.initSource(source);\n  }\n  /**\n   * this returns s bind group for a specific texture, the bind group contains\n   * - the texture source\n   * - the texture style\n   * - the texture matrix\n   * This is cached so the bind group should only be created once per texture\n   * @param texture - the texture you want the bindgroup for\n   * @returns the bind group for the texture\n   */\n  getTextureBindGroup(texture) {\n    return this._bindGroupHash[texture.uid] || this._createTextureBindGroup(texture);\n  }\n  _createTextureBindGroup(texture) {\n    const source = texture.source;\n    this._bindGroupHash[texture.uid] = new BindGroup({\n      0: source,\n      1: source.style,\n      2: new UniformGroup({\n        uTextureMatrix: { type: \"mat3x3<f32>\", value: texture.textureMatrix.mapCoord }\n      })\n    });\n    return this._bindGroupHash[texture.uid];\n  }\n  getTextureView(texture) {\n    const source = texture.source;\n    source._gcLastUsed = this._renderer.gc.now;\n    let gpuData = source._gpuData[this._renderer.uid];\n    let textureView = null;\n    if (!gpuData) {\n      this.initSource(source);\n      gpuData = source._gpuData[this._renderer.uid];\n    }\n    textureView = gpuData.textureView || gpuData.gpuTexture.createView();\n    return textureView;\n  }\n  generateCanvas(texture) {\n    const renderer = this._renderer;\n    const commandEncoder = renderer.gpu.device.createCommandEncoder();\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = texture.source.pixelWidth;\n    canvas.height = texture.source.pixelHeight;\n    const context = canvas.getContext(\"webgpu\");\n    context.configure({\n      device: renderer.gpu.device,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n      format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n      alphaMode: \"premultiplied\"\n    });\n    commandEncoder.copyTextureToTexture({\n      texture: renderer.texture.getGpuSource(texture.source),\n      origin: {\n        x: 0,\n        y: 0\n      }\n    }, {\n      texture: context.getCurrentTexture()\n    }, {\n      width: canvas.width,\n      height: canvas.height\n    });\n    renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    return canvas;\n  }\n  getPixels(texture) {\n    const webGPUCanvas = this.generateCanvas(texture);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n    const context = canvasAndContext.context;\n    context.drawImage(webGPUCanvas, 0, 0);\n    const { width, height } = webGPUCanvas;\n    const imageData = context.getImageData(0, 0, width, height);\n    const pixels = new Uint8ClampedArray(imageData.data.buffer);\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n    return { pixels, width, height };\n  }\n  destroy() {\n    this._managedTextures.destroy();\n    for (const k of Object.keys(this._bindGroupHash)) {\n      const key = Number(k);\n      const bindGroup = this._bindGroupHash[key];\n      bindGroup?.destroy();\n    }\n    this._renderer = null;\n    this._gpu = null;\n    this._mipmapGenerator = null;\n    this._gpuSamplers = null;\n    this._bindGroupHash = null;\n  }\n}\n/** @ignore */\nGpuTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"texture\"\n};\n\nexport { GPUTextureGpuData, GpuTextureSystem };\n//# sourceMappingURL=GpuTextureSystem.mjs.map\n","import { extensions, ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor.mjs';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter.mjs';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor.mjs';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer.mjs';\nimport { SharedSystems, SharedRenderPipes } from '../shared/system/SharedSystems.mjs';\nimport { RendererType } from '../types.mjs';\nimport { BindGroupSystem } from './BindGroupSystem.mjs';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem.mjs';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem.mjs';\nimport { GpuDeviceSystem } from './GpuDeviceSystem.mjs';\nimport { GpuEncoderSystem } from './GpuEncoderSystem.mjs';\nimport { GpuLimitsSystem } from './GpuLimitsSystem.mjs';\nimport { GpuStencilSystem } from './GpuStencilSystem.mjs';\nimport { GpuUboSystem } from './GpuUboSystem.mjs';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe.mjs';\nimport { PipelineSystem } from './pipeline/PipelineSystem.mjs';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem.mjs';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem.mjs';\nimport { GpuStateSystem } from './state/GpuStateSystem.mjs';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem.mjs';\n\n\"use strict\";\nconst DefaultWebGPUSystems = [\n  ...SharedSystems,\n  GpuUboSystem,\n  GpuEncoderSystem,\n  GpuDeviceSystem,\n  GpuLimitsSystem,\n  GpuBufferSystem,\n  GpuTextureSystem,\n  GpuRenderTargetSystem,\n  GpuShaderSystem,\n  GpuStateSystem,\n  PipelineSystem,\n  GpuColorMaskSystem,\n  GpuStencilSystem,\n  BindGroupSystem\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\nclass WebGPURenderer extends AbstractRenderer {\n  constructor() {\n    const systemConfig = {\n      name: \"webgpu\",\n      type: RendererType.WEBGPU,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\nexport { WebGPURenderer };\n//# sourceMappingURL=WebGPURenderer.mjs.map\n"],"names":["GpuGraphicsAdaptor","constructor","this","_maxTextures","contextChange","renderer","localUniforms","UniformGroup","uTransformMatrix","value","Matrix","type","uColor","Float32Array","uRound","limits","maxBatchableTextures","gpuProgram","name","bits","colorBit","generateTextureBatchBit","localUniformBit","roundPixelsBit","shader","Shader","resources","execute","graphicsPipe","renderable","context","customShader","contextSystem","graphicsContext","batcher","instructions","getContextRenderData","encoder","setGeometry","geometry","globalUniformsBindGroup","globalUniforms","bindGroup","setBindGroup","localBindGroup","renderPipes","uniformBatch","getUniformBindGroup","batches","topology","i","instructionSize","batch","setPipelineFromGeometryProgramAndState","state","groups","gpuBindGroup","textureBatch","textures","getTextureBatchBindGroup","count","getBindGroup","renderPassEncoder","drawIndexed","size","start","destroy","extension","WebGPUPipesAdaptor","GpuMeshAdapter","init","textureBit","_shader","uTexture","Texture","EMPTY","_source","uSampler","style","textureUniforms","uTextureMatrix","meshPipe","mesh","warn","texture","getTextureBindGroup","autoAssignGlobalUniforms","autoAssignLocalUniforms","draw","_geometry","tempState","State","for2d","GpuBatchAdaptor","batchPipe","program","blendMode","pipeline","getPipeline","resetBindGroup","_touch","gc","now","tick","setPipeline","BindGroupSystem","_hash","Object","create","_renderer","gpu","_gpu","groupIndex","_updateKey","_key","_createBindGroup","group","device","groupLayout","layout","entries","j","resource","gpuResource","_resourceType","uniformGroup","ubo","updateUniformGroup","buffer","getGPUBuffer","offset","descriptor","bufferResource","sampler","getGpuSampler","getGpuSource","createView","push","binding","getProgramData","bindGroups","createBindGroup","WebGPUSystem","GpuBufferData","gpuBuffer","GpuBufferSystem","_managedBuffers","GCManagedHash","onUnload","onBufferUnload","bind","_gcLastUsed","_gpuData","uid","createGPUBuffer","updateBuffer","data","_updateID","queue","writeBuffer","_updateSize","byteLength","destroyAll","removeAll","off","onBufferChange","createBuffer","_resourceId","fastCopy","getMappedRange","unmap","add","on","remove","GpuColorMaskSystem","_colorMaskCache","setMask","colorMask","setColorMask","GpuDeviceSystem","options","_initPromise","Promise","resolve","_createDeviceAndAdaptor","then","runners","emit","adapter","get","getNavigator","requestAdapter","powerPreference","forceFallbackAdapter","requiredFeatures","filter","feature","features","has","requestDevice","defaultOptions","GpuEncoderSystem","_boundBindGroup","_boundVertexBuffer","renderStart","commandFinished","_resolveCommandFinished","commandEncoder","createCommandEncoder","beginRenderPass","gpuRenderTarget","endRenderPass","_clearCache","end","setViewport","viewport","x","y","width","height","_boundPipeline","_setVertexBuffer","index","setVertexBuffer","_setIndexBuffer","_boundIndexBuffer","indexFormat","BYTES_PER_ELEMENT","setIndexBuffer","buffersToBind","getBufferNamesToBind","parseInt","attributes","indexBuffer","_setShaderBindGroups","skipSync","_syncBindGroup","isUniformGroup","instanceCount","length","getSize","finishRenderPass","postrender","submit","finish","restoreRenderPass","renderTarget","adaptor","getDescriptor","boundPipeline","boundVertexBuffer","boundIndexBuffer","boundBindGroup","priority","GpuLimitsSystem","maxTextures","maxSampledTexturesPerShaderStage","GpuStencilSystem","_renderTargetStencilState","onRenderTargetChange","stencilState","stencilMode","DISABLED","stencilReference","_activeRenderTarget","setStencilMode","setStencilReference","WGSL_ALIGN_SIZE_DATA","i32","align","u32","f32","f16","createUboElementsWGSL","uniformData","uboElements","map","uboElement","Error","Math","max","ceil","generateArraySyncWGSL","offsetToAdd","remainder","indexOf","createUboSyncFunctionWGSL","createUboSyncFunction","uboSyncFunctions","GpuUboSystem","UboSystem","super","createUboElements","generateUboSync","UboBatch","minUniformOffsetAlignment","_minUniformOffsetAlignment","byteIndex","clear","addEmptyGroup","newSize","addGroup","array","GpuUniformBatchPipe","_bindGroupHash","_buffers","_bindGroups","_bufferResources","_batchBuffer","usage","UNIFORM","COPY_DST","COPY_SRC","Buffer","renderEnd","_uploadBindGroups","_resetBindGroups","duplicate","ensureUniformGroup","syncUniformGroup","_getBindGroup","getUboResource","_getBufferResource","getArrayBindGroup","getArrayBufferResource","BufferResource","BindGroup","bufferSystem","firstBuffer","update","copyBufferToBuffer","WebGPUPipes","topologyStringToId","PipelineSystem","_moduleCache","_bufferLayoutsCache","_bindingNamesCache","_pipeCache","_pipeStateCaches","_colorMask","_multisampleCount","_colorTargetCount","_updatePipeHash","setMultisampleCount","multisampleCount","setRenderTarget","msaaSamples","_depthStencilAttachment","depthStencilAttachment","colorTargetCount","_stencilMode","_stencilState","GpuStencilModesToPixi","passEncoder","_layoutKey","ensureAttributes","attributeData","_generateBufferKey","key","geometryLayout","shaderKey","getGraphicsStateKey","_blendModeId","_createPipeline","buffers","_createVertexBufferLayouts","blendModes","getColorTargets","writeMask","RENDERING_MASK_ADD","vertex","module","_getModule","source","entryPoint","fragment","targets","primitive","cullMode","multisample","label","depthStencil","format","depthWriteEnabled","depthTest","depthCompare","createRenderPipeline","code","_createModule","createShaderModule","keyGen","attributeKeys","keys","sort","attribute","stride","instance","stringKey","join","createIdFromString","_generateAttributeLocationsKey","location","_attributeLocationsKey","bufferNamesToBind","shaderLocation","values","vertexBuffersLayout","forEach","bufferEntry","arrayStride","stepMode","bufferEntryAttributes","divisor","stencilStateId","multiSampleCount","GpuRenderTarget","contexts","msaaTextures","GpuRenderTargetAdaptor","renderTargetSystem","_renderTargetSystem","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","baseGpuTexture","_getGpuColorTexture","backGpuTexture","copyTextureToTexture","origin","startRenderPass","clearColor","getGpuRenderTarget","getCurrentTexture","colorTextures","clearValue","ALL","NONE","colorAttachments","view","resolveTarget","mipLevelCount","getTextureView","loadOp","COLOR","defaultClearColor","storeOp","stencil","depth","depthStencilTexture","ensureDepthStencilTexture","sampleCount","msaa","stencilLoadOp","STENCIL","depthLoadOp","DEPTH","stencilStoreOp","depthClearValue","depthStoreOp","renderPassDescriptor","gpuCommands","initGpuRenderTarget","isRoot","colorTexture","CanvasSource","getContext","alphaMode","transparent","configure","GPUTextureUsage","TEXTURE_BINDING","RENDER_ATTACHMENT","e","console","error","antialias","msaaTexture","TextureSource","destroyGpuRenderTarget","unconfigure","resizeGpuRenderTarget","resize","_resolution","GpuRenderTargetSystem","RenderTargetSystem","GpuShaderSystem","_gpuProgramData","_createGPUProgramData","gpuLayout","createBindGroupLayout","pipelineLayoutDesc","bindGroupLayouts","createPipelineLayout","GpuBlendModesToPixi","alpha","srcFactor","dstFactor","operation","color","GpuStateSystem","defaultState","blend","target","normal","gpuUploadBufferImageResource","upload","gpuTexture","total","pixelWidth","pixelHeight","bytesPerPixel","writeTexture","rowsPerImage","bytesPerRow","depthOrArrayLayers","blockDataMap","blockBytes","blockWidth","blockHeight","defaultBlockData","gpuUploadCompressedTextureResource","mipWidth","mipHeight","blockData","levelBuffer","mipLevel","gpuUploadImageResource","globalThis","HTMLImageElement","canvas","createCanvas","drawImage","min","resourceWidth","resourceHeight","premultipliedAlpha","copyExternalImageToTexture","gpuUploadVideoResource","GpuMipmapGenerator","createSampler","minFilter","pipelines","_getMipmapPipeline","mipmapShaderModule","generateMipmap","dimension","mipTexture","arrayLayerCount","renderToSource","mipTextureDescriptor","createTexture","bindGroupLayout","getBindGroupLayout","arrayLayer","srcView","baseMipLevel","baseArrayLayer","dstMipLevel","dstView","r","g","b","a","mipLevelSize","GPUTextureGpuData","textureView","GpuTextureSystem","_gpuSamplers","_uploads","image","video","compressed","renderableGC","addManagedHash","_managedTextures","onSourceUnload","managedTextures","items","initSource","_initSource","autoGenerateMipmaps","biggestDimension","floor","log2","uploadMethodId","textureDescriptor","onSourceUpdate","onSourceResize","onUpdateMipmaps","_mipmapGenerator","gpuData","_initSampler","_createTextureBindGroup","textureMatrix","mapCoord","generateCanvas","getPreferredCanvasFormat","getPixels","webGPUCanvas","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","imageData","getImageData","pixels","Uint8ClampedArray","returnCanvasAndContext","k","Number","DefaultWebGPUSystems","SharedSystems","DefaultWebGPUPipes","DefaultWebGPUAdapters","systems","renderPipeAdaptors","handleByNamedList","WebGPURenderer","AbstractRenderer","WEBGPU"],"ignoreList":[],"sourceRoot":""}