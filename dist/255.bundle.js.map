{"version":3,"file":"255.bundle.js","mappings":"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","sources":["webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text/init.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/utils/browser/isSafari.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-html/init.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/FilterPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/defaults/passthrough/PassthroughFilter.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/FilterSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/init.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/text-bitmap/init.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/app/ResizePlugin.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/app/TickerPlugin.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/app/init.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/mesh/init.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/Filter.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/graphics/init.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/particle-container/init.mjs"],"sourcesContent":["\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","import { BatchableSprite } from '../../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass BatchableText extends BatchableSprite {\n}\n\nexport { BatchableText };\n//# sourceMappingURL=BatchableText.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash.mjs';\nimport { updateTextBounds } from '../utils/updateTextBounds.mjs';\nimport { BatchableText } from './BatchableText.mjs';\n\n\"use strict\";\nclass CanvasTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n    this._managedTexts = new GCManagedHash({\n      renderer,\n      type: \"renderable\",\n      onUnload: this.onTextUnload.bind(this),\n      name: \"canvasText\"\n    });\n  }\n  resolutionChange() {\n    for (const key in this._managedTexts.items) {\n      const text = this._managedTexts.items[key];\n      if (text?._autoResolution)\n        text.onViewUpdate();\n    }\n  }\n  validateRenderable(text) {\n    const gpuText = this._getGpuText(text);\n    const newKey = text.styleKey;\n    if (gpuText.currentKey !== newKey)\n      return true;\n    return text._didTextUpdate;\n  }\n  addRenderable(text, instructionSet) {\n    const batchableText = this._getGpuText(text);\n    if (text._didTextUpdate) {\n      const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n      if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution) {\n        this._updateGpuText(text);\n      }\n      text._didTextUpdate = false;\n      updateTextBounds(batchableText, text);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n  }\n  updateRenderable(text) {\n    const batchableText = this._getGpuText(text);\n    batchableText._batcher.updateElement(batchableText);\n  }\n  _updateGpuText(text) {\n    const batchableText = this._getGpuText(text);\n    if (batchableText.texture) {\n      this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);\n    }\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    batchableText.texture = this._renderer.canvasText.getManagedTexture(text);\n    batchableText.currentKey = text.styleKey;\n  }\n  _getGpuText(text) {\n    return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n  }\n  initGpuText(text) {\n    const batchableText = new BatchableText();\n    batchableText.currentKey = \"--\";\n    batchableText.renderable = text;\n    batchableText.transform = text.groupTransform;\n    batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableText.roundPixels = this._renderer._roundPixels | text._roundPixels;\n    text._gpuData[this._renderer.uid] = batchableText;\n    this._managedTexts.add(text);\n    return batchableText;\n  }\n  onTextUnload(text) {\n    const gpuData = text._gpuData[this._renderer.uid];\n    if (!gpuData)\n      return;\n    const { canvasText } = this._renderer;\n    const refCount = canvasText.getReferenceCount(gpuData.currentKey);\n    if (refCount > 0) {\n      canvasText.decreaseReferenceCount(gpuData.currentKey);\n    } else if (gpuData.texture) {\n      canvasText.returnTexture(gpuData.texture);\n    }\n  }\n  destroy() {\n    this._managedTexts.destroy();\n    this._renderer = null;\n  }\n}\n/** @ignore */\nCanvasTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"text\"\n};\n\nexport { CanvasTextPipe };\n//# sourceMappingURL=CanvasTextPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport { deprecation } from '../../../utils/logging/deprecation.mjs';\nimport { TextStyle } from '../TextStyle.mjs';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource.mjs';\nimport { CanvasTextGenerator } from './CanvasTextGenerator.mjs';\n\n\"use strict\";\nclass CanvasTextSystem {\n  constructor(_renderer) {\n    this._activeTextures = {};\n    this._renderer = _renderer;\n  }\n  getTexture(options, _resolution, _style, _textKey) {\n    if (typeof options === \"string\") {\n      deprecation(\"8.0.0\", \"CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments\");\n      options = {\n        text: options,\n        style: _style,\n        resolution: _resolution\n      };\n    }\n    if (!(options.style instanceof TextStyle)) {\n      options.style = new TextStyle(options.style);\n    }\n    if (!(options.textureStyle instanceof TextureStyle)) {\n      options.textureStyle = new TextureStyle(options.textureStyle);\n    }\n    if (typeof options.text !== \"string\") {\n      options.text = options.text.toString();\n    }\n    const { text, style, textureStyle } = options;\n    const resolution = options.resolution ?? this._renderer.resolution;\n    const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n      text,\n      style,\n      resolution\n    });\n    const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (style.trim) {\n      frame.pad(style.padding);\n      texture.frame.copyFrom(frame);\n      texture.frame.scale(1 / resolution);\n      texture.updateUvs();\n    }\n    if (style.filters) {\n      const filteredTexture = this._applyFilters(texture, style.filters);\n      this.returnTexture(texture);\n      CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n      return filteredTexture;\n    }\n    this._renderer.texture.initSource(texture._source);\n    CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n    return texture;\n  }\n  /**\n   * Returns a texture that was created wit the above `getTexture` function.\n   * Handy if you are done with a texture and want to return it to the pool.\n   * @param texture - The texture to be returned.\n   */\n  returnTexture(texture) {\n    const source = texture.source;\n    source.resource = null;\n    source.uploadMethodId = \"unknown\";\n    source.alphaMode = \"no-premultiply-alpha\";\n    TexturePool.returnTexture(texture, true);\n  }\n  /**\n   * Renders text to its canvas, and updates its texture.\n   * @deprecated since 8.10.0\n   */\n  renderTextToCanvas() {\n    deprecation(\n      \"8.10.0\",\n      \"CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead\"\n    );\n  }\n  /**\n   * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.\n   * @param text - The Text object that needs a texture\n   * @returns A Texture instance that represents the rendered text\n   * @remarks\n   * This method performs the following:\n   * 1. Sets the appropriate resolution based on auto-resolution settings\n   * 2. Checks if a texture already exists for the text's style\n   * 3. Creates a new texture if needed or returns an existing one\n   * 4. Manages reference counting for texture reuse\n   */\n  getManagedTexture(text) {\n    text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n    const textKey = text.styleKey;\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].texture;\n    }\n    const texture = this.getTexture({\n      text: text.text,\n      style: text.style,\n      resolution: text._resolution,\n      textureStyle: text.textureStyle\n    });\n    this._activeTextures[textKey] = {\n      texture,\n      usageCount: 1\n    };\n    return texture;\n  }\n  /**\n   * Decreases the reference count for a texture associated with a text key.\n   * When the reference count reaches zero, the texture is returned to the pool.\n   * @param textKey - The unique key identifying the text style configuration\n   * @remarks\n   * This method is crucial for memory management, ensuring textures are properly\n   * cleaned up when they are no longer needed by any Text instances.\n   */\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      this.returnTexture(activeTexture.texture);\n      this._activeTextures[textKey] = null;\n    }\n  }\n  /**\n   * Gets the current reference count for a texture associated with a text key.\n   * @param textKey - The unique key identifying the text style configuration\n   * @returns The number of Text instances currently using this texture\n   */\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey]?.usageCount ?? 0;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  /**\n   * Applies the specified filters to the given texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n   * texture is set to 'premultiplied-alpha'.\n   * @param {Texture} texture - The texture to which the filters will be applied.\n   * @param {Filter[]} filters - The filters to apply to the texture.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   */\n  _applyFilters(texture, filters) {\n    const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n    const resultTexture = this._renderer.filter.generateFilteredTexture({\n      texture,\n      filters\n    });\n    this._renderer.renderTarget.bind(currentRenderTarget, false);\n    return resultTexture;\n  }\n  destroy() {\n    this._renderer = null;\n    for (const key in this._activeTextures) {\n      if (this._activeTextures[key])\n        this.returnTexture(this._activeTextures[key].texture);\n    }\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nCanvasTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"canvasText\"\n};\n\nexport { CanvasTextSystem };\n//# sourceMappingURL=CanvasTextSystem.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe.mjs';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem.mjs';\n\n\"use strict\";\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { updateQuadBounds } from '../../../utils/data/updateQuadBounds.mjs';\n\n\"use strict\";\nfunction updateTextBounds(batchableSprite, text) {\n  const { texture, bounds } = batchableSprite;\n  const padding = text._style._getFinalPadding();\n  updateQuadBounds(bounds, text._anchor, texture);\n  const paddingOffset = text._anchor._x * padding * 2;\n  const paddingOffsetY = text._anchor._y * padding * 2;\n  bounds.minX -= padding - paddingOffset;\n  bounds.minY -= padding - paddingOffsetY;\n  bounds.maxX -= padding - paddingOffset;\n  bounds.maxY -= padding - paddingOffsetY;\n}\n\nexport { updateTextBounds };\n//# sourceMappingURL=updateTextBounds.mjs.map\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { Bounds } from '../../container/bounds/Bounds.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nfunction getPo2TextureFromSource(image, width, height, resolution) {\n  const bounds = tempBounds;\n  bounds.minX = 0;\n  bounds.minY = 0;\n  bounds.maxX = image.width / resolution | 0;\n  bounds.maxY = image.height / resolution | 0;\n  const texture = TexturePool.getOptimalTexture(\n    bounds.width,\n    bounds.height,\n    resolution,\n    false\n  );\n  texture.source.uploadMethodId = \"image\";\n  texture.source.resource = image;\n  texture.source.alphaMode = \"premultiply-alpha-on-upload\";\n  texture.frame.width = width / resolution;\n  texture.frame.height = height / resolution;\n  texture.source.emit(\"update\", texture.source);\n  texture.updateUvs();\n  return texture;\n}\n\nexport { getPo2TextureFromSource };\n//# sourceMappingURL=getPo2TextureFromSource.mjs.map\n","import { BatchableSprite } from '../sprite/BatchableSprite.mjs';\n\n\"use strict\";\nclass BatchableHTMLText extends BatchableSprite {\n  constructor() {\n    super(...arguments);\n    this.generatingTexture = false;\n    this.currentKey = \"--\";\n  }\n  /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n  destroy() {\n    this.texturePromise = null;\n    this.generatingTexture = false;\n    this.currentKey = \"--\";\n    super.destroy();\n  }\n}\n\nexport { BatchableHTMLText };\n//# sourceMappingURL=BatchableHTMLText.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash.mjs';\nimport { updateTextBounds } from '../text/utils/updateTextBounds.mjs';\nimport { BatchableHTMLText } from './BatchableHTMLText.mjs';\n\n\"use strict\";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n    renderer.runners.resolutionChange.add(this);\n    this._managedTexts = new GCManagedHash({\n      renderer,\n      type: \"renderable\",\n      onUnload: this.onTextUnload.bind(this),\n      name: \"htmlText\"\n    });\n  }\n  resolutionChange() {\n    for (const key in this._managedTexts.items) {\n      const text = this._managedTexts.items[key];\n      if (text?._autoResolution) {\n        text.onViewUpdate();\n      }\n    }\n  }\n  validateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const newKey = htmlText.styleKey;\n    if (gpuText.currentKey !== newKey) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(htmlText, instructionSet) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (htmlText._didTextUpdate) {\n      const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n      if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution) {\n        this._updateGpuText(htmlText).catch((e) => {\n          console.error(e);\n        });\n      }\n      htmlText._didTextUpdate = false;\n      updateTextBounds(batchableHTMLText, htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n  }\n  updateRenderable(htmlText) {\n    const batchableHTMLText = this._getGpuText(htmlText);\n    batchableHTMLText._batcher.updateElement(batchableHTMLText);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const batchableHTMLText = this._getGpuText(htmlText);\n    if (batchableHTMLText.generatingTexture)\n      return;\n    const oldTexturePromise = batchableHTMLText.texturePromise;\n    batchableHTMLText.texturePromise = null;\n    batchableHTMLText.generatingTexture = true;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n    if (oldTexturePromise) {\n      texturePromise = texturePromise.finally(() => {\n        this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);\n        this._renderer.htmlText.returnTexturePromise(oldTexturePromise);\n      });\n    }\n    batchableHTMLText.texturePromise = texturePromise;\n    batchableHTMLText.currentKey = htmlText.styleKey;\n    batchableHTMLText.texture = await texturePromise;\n    const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    batchableHTMLText.generatingTexture = false;\n    updateTextBounds(batchableHTMLText, htmlText);\n  }\n  _getGpuText(htmlText) {\n    return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const batchableHTMLText = new BatchableHTMLText();\n    batchableHTMLText.renderable = htmlText;\n    batchableHTMLText.transform = htmlText.groupTransform;\n    batchableHTMLText.texture = Texture.EMPTY;\n    batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    batchableHTMLText.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n    this._managedTexts.add(htmlText);\n    return batchableHTMLText;\n  }\n  onTextUnload(text) {\n    const gpuData = text._gpuData[this._renderer.uid];\n    if (!gpuData)\n      return;\n    const { htmlText } = this._renderer;\n    htmlText.getReferenceCount(gpuData.currentKey) === null ? htmlText.returnTexturePromise(gpuData.texturePromise) : htmlText.decreaseReferenceCount(gpuData.currentKey);\n  }\n  destroy() {\n    this._managedTexts.destroy();\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextPipe };\n//# sourceMappingURL=HTMLTextPipe.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nconst nssvg = \"http://www.w3.org/2000/svg\";\nconst nsxhtml = \"http://www.w3.org/1999/xhtml\";\nclass HTMLTextRenderData {\n  constructor() {\n    this.svgRoot = document.createElementNS(nssvg, \"svg\");\n    this.foreignObject = document.createElementNS(nssvg, \"foreignObject\");\n    this.domElement = document.createElementNS(nsxhtml, \"div\");\n    this.styleElement = document.createElementNS(nsxhtml, \"style\");\n    const { foreignObject, svgRoot, styleElement, domElement } = this;\n    foreignObject.setAttribute(\"width\", \"10000\");\n    foreignObject.setAttribute(\"height\", \"10000\");\n    foreignObject.style.overflow = \"hidden\";\n    svgRoot.appendChild(foreignObject);\n    foreignObject.appendChild(styleElement);\n    foreignObject.appendChild(domElement);\n    this.image = DOMAdapter.get().createImage();\n  }\n  destroy() {\n    this.svgRoot.remove();\n    this.foreignObject.remove();\n    this.styleElement.remove();\n    this.domElement.remove();\n    this.image.src = \"\";\n    this.image.remove();\n    this.svgRoot = null;\n    this.foreignObject = null;\n    this.styleElement = null;\n    this.domElement = null;\n    this.image = null;\n    this.canvasAndContext = null;\n  }\n}\n\nexport { HTMLTextRenderData };\n//# sourceMappingURL=HTMLTextRenderData.mjs.map\n","import { Cache } from '../../../assets/cache/Cache.mjs';\nimport { loadFontCSS } from './loadFontCSS.mjs';\n\n\"use strict\";\nconst FontStylePromiseCache = /* @__PURE__ */ new Map();\nasync function getFontCss(fontFamilies) {\n  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily) => {\n    if (!FontStylePromiseCache.has(fontFamily)) {\n      const { entries } = Cache.get(`${fontFamily}-and-url`);\n      const promises = [];\n      entries.forEach((entry) => {\n        const url = entry.url;\n        const faces = entry.faces;\n        const out = faces.map((face) => ({ weight: face.weight, style: face.style }));\n        promises.push(\n          ...out.map(\n            (style) => loadFontCSS(\n              {\n                fontWeight: style.weight,\n                fontStyle: style.style,\n                fontFamily\n              },\n              url\n            )\n          )\n        );\n      });\n      FontStylePromiseCache.set(\n        fontFamily,\n        Promise.all(promises).then((css) => css.join(\"\\n\"))\n      );\n    }\n    return FontStylePromiseCache.get(fontFamily);\n  });\n  return (await Promise.all(fontPromises)).join(\"\\n\");\n}\n\nexport { FontStylePromiseCache, getFontCss };\n//# sourceMappingURL=getFontCss.mjs.map\n","import { HTMLTextRenderData } from '../HTMLTextRenderData.mjs';\n\n\"use strict\";\nlet tempHTMLTextRenderData;\nfunction measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {\n  htmlTextRenderData || (htmlTextRenderData = tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData()));\n  const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n  domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n  domElement.setAttribute(\"style\", \"transform-origin: top left; display: inline-block\");\n  if (fontStyleCSS) {\n    styleElement.textContent = fontStyleCSS;\n  }\n  document.body.appendChild(svgRoot);\n  const contentBounds = domElement.getBoundingClientRect();\n  svgRoot.remove();\n  const doublePadding = style.padding * 2;\n  return {\n    width: contentBounds.width - doublePadding,\n    height: contentBounds.height - doublePadding\n  };\n}\n\nexport { measureHtmlText };\n//# sourceMappingURL=measureHtmlText.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { isSafari } from '../../utils/browser/isSafari.mjs';\nimport { warn } from '../../utils/logging/warn.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource.mjs';\nimport { HTMLTextRenderData } from './HTMLTextRenderData.mjs';\nimport { extractFontFamilies } from './utils/extractFontFamilies.mjs';\nimport { getFontCss } from './utils/getFontCss.mjs';\nimport { getSVGUrl } from './utils/getSVGUrl.mjs';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage.mjs';\nimport { loadSVGImage } from './utils/loadSVGImage.mjs';\nimport { measureHtmlText } from './utils/measureHtmlText.mjs';\n\n\"use strict\";\nclass HTMLTextSystem {\n  constructor(renderer) {\n    this._activeTextures = {};\n    this._renderer = renderer;\n    this._createCanvas = renderer.type === RendererType.WEBGPU;\n  }\n  /**\n   * @param options\n   * @deprecated Use getTexturePromise instead\n   */\n  getTexture(options) {\n    return this.getTexturePromise(options);\n  }\n  /**\n   * Increases the reference count for a texture.\n   * @param text - The HTMLText instance associated with the texture.\n   */\n  getManagedTexture(text) {\n    const textKey = text.styleKey;\n    if (this._activeTextures[textKey]) {\n      this._increaseReferenceCount(textKey);\n      return this._activeTextures[textKey].promise;\n    }\n    const promise = this._buildTexturePromise(text).then((texture) => {\n      this._activeTextures[textKey].texture = texture;\n      return texture;\n    });\n    this._activeTextures[textKey] = {\n      texture: null,\n      promise,\n      usageCount: 1\n    };\n    return promise;\n  }\n  /**\n   * Gets the current reference count for a texture associated with a text key.\n   * @param textKey - The unique key identifying the text style configuration\n   * @returns The number of Text instances currently using this texture\n   */\n  getReferenceCount(textKey) {\n    return this._activeTextures[textKey]?.usageCount ?? null;\n  }\n  _increaseReferenceCount(textKey) {\n    this._activeTextures[textKey].usageCount++;\n  }\n  /**\n   * Decreases the reference count for a texture.\n   * If the count reaches zero, the texture is cleaned up.\n   * @param textKey - The key associated with the HTMLText instance.\n   */\n  decreaseReferenceCount(textKey) {\n    const activeTexture = this._activeTextures[textKey];\n    if (!activeTexture)\n      return;\n    activeTexture.usageCount--;\n    if (activeTexture.usageCount === 0) {\n      if (activeTexture.texture) {\n        this._cleanUp(activeTexture.texture);\n      } else {\n        activeTexture.promise.then((texture) => {\n          activeTexture.texture = texture;\n          this._cleanUp(activeTexture.texture);\n        }).catch(() => {\n          warn(\"HTMLTextSystem: Failed to clean texture\");\n        });\n      }\n      this._activeTextures[textKey] = null;\n    }\n  }\n  /**\n   * Returns a promise that resolves to a texture for the given HTMLText options.\n   * @param options - The options for the HTMLText.\n   * @returns A promise that resolves to a Texture.\n   */\n  getTexturePromise(options) {\n    return this._buildTexturePromise(options);\n  }\n  async _buildTexturePromise(options) {\n    const { text, style, resolution, textureStyle } = options;\n    const htmlTextData = BigPool.get(HTMLTextRenderData);\n    const fontFamilies = extractFontFamilies(text, style);\n    const fontCSS = await getFontCss(fontFamilies);\n    const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);\n    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);\n    const image = htmlTextData.image;\n    const uvSafeOffset = 2;\n    image.width = (width | 0) + uvSafeOffset;\n    image.height = (height | 0) + uvSafeOffset;\n    const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n    await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n    const resource = image;\n    let canvasAndContext;\n    if (this._createCanvas) {\n      canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n    }\n    const texture = getPo2TextureFromSource(\n      canvasAndContext ? canvasAndContext.canvas : resource,\n      image.width - uvSafeOffset,\n      image.height - uvSafeOffset,\n      resolution\n    );\n    if (textureStyle)\n      texture.source.style = textureStyle;\n    if (this._createCanvas) {\n      this._renderer.texture.initSource(texture.source);\n      CanvasPool.returnCanvasAndContext(canvasAndContext);\n    }\n    BigPool.return(htmlTextData);\n    return texture;\n  }\n  returnTexturePromise(texturePromise) {\n    texturePromise.then((texture) => {\n      this._cleanUp(texture);\n    }).catch(() => {\n      warn(\"HTMLTextSystem: Failed to clean texture\");\n    });\n  }\n  _cleanUp(texture) {\n    TexturePool.returnTexture(texture, true);\n    texture.source.resource = null;\n    texture.source.uploadMethodId = \"unknown\";\n  }\n  destroy() {\n    this._renderer = null;\n    for (const key in this._activeTextures) {\n      if (this._activeTextures[key])\n        this.returnTexturePromise(this._activeTextures[key].promise);\n    }\n    this._activeTextures = null;\n  }\n}\n/** @ignore */\nHTMLTextSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"htmlText\"\n};\n\nexport { HTMLTextSystem };\n//# sourceMappingURL=HTMLTextSystem.mjs.map\n","\"use strict\";\nfunction extractFontFamilies(text, style) {\n  const fontFamily = style.fontFamily;\n  const fontFamilies = [];\n  const dedupe = {};\n  const regex = /font-family:([^;\"\\s]+)/g;\n  const matches = text.match(regex);\n  function addFontFamily(fontFamily2) {\n    if (!dedupe[fontFamily2]) {\n      fontFamilies.push(fontFamily2);\n      dedupe[fontFamily2] = true;\n    }\n  }\n  if (Array.isArray(fontFamily)) {\n    for (let i = 0; i < fontFamily.length; i++) {\n      addFontFamily(fontFamily[i]);\n    }\n  } else {\n    addFontFamily(fontFamily);\n  }\n  if (matches) {\n    matches.forEach((match) => {\n      const fontFamily2 = match.split(\":\")[1].trim();\n      addFontFamily(fontFamily2);\n    });\n  }\n  for (const i in style.tagStyles) {\n    const fontFamily2 = style.tagStyles[i].fontFamily;\n    addFontFamily(fontFamily2);\n  }\n  return fontFamilies;\n}\n\nexport { extractFontFamilies };\n//# sourceMappingURL=extractFontFamilies.mjs.map\n","import { loadFontAsBase64 } from './loadFontAsBase64.mjs';\n\n\"use strict\";\nasync function loadFontCSS(style, url) {\n  const dataSrc = await loadFontAsBase64(url);\n  return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n        src: url('${dataSrc}');\n    }`;\n}\n\nexport { loadFontCSS };\n//# sourceMappingURL=loadFontCSS.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\n\n\"use strict\";\nasync function loadFontAsBase64(url) {\n  const response = await DOMAdapter.get().fetch(url);\n  const blob = await response.blob();\n  const reader = new FileReader();\n  const dataSrc = await new Promise((resolve, reject) => {\n    reader.onloadend = () => resolve(reader.result);\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n  return dataSrc;\n}\n\nexport { loadFontAsBase64 };\n//# sourceMappingURL=loadFontAsBase64.mjs.map\n","\"use strict\";\nfunction getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {\n  const { domElement, styleElement, svgRoot } = htmlTextData;\n  domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n  domElement.setAttribute(\"style\", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n  styleElement.textContent = fontCSS;\n  const { width, height } = htmlTextData.image;\n  svgRoot.setAttribute(\"width\", width.toString());\n  svgRoot.setAttribute(\"height\", height.toString());\n  return new XMLSerializer().serializeToString(svgRoot);\n}\n\nexport { getSVGUrl };\n//# sourceMappingURL=getSVGUrl.mjs.map\n","\"use strict\";\nfunction loadSVGImage(image, url, delay) {\n  return new Promise(async (resolve) => {\n    if (delay) {\n      await new Promise((resolve2) => setTimeout(resolve2, 100));\n    }\n    image.onload = () => {\n      resolve();\n    };\n    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n    image.crossOrigin = \"anonymous\";\n  });\n}\n\nexport { loadSVGImage };\n//# sourceMappingURL=loadSVGImage.mjs.map\n","import { DOMAdapter } from '../../environment/adapter.mjs';\n\n\"use strict\";\nfunction isSafari() {\n  const { userAgent } = DOMAdapter.get().getNavigator();\n  return /^((?!chrome|android).)*safari/i.test(userAgent);\n}\n\nexport { isSafari };\n//# sourceMappingURL=isSafari.mjs.map\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool.mjs';\n\n\"use strict\";\nfunction getTemporaryCanvasFromImage(image, resolution) {\n  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n    image.width,\n    image.height,\n    resolution\n  );\n  const { context } = canvasAndContext;\n  context.clearRect(0, 0, image.width, image.height);\n  context.drawImage(image, 0, 0);\n  return canvasAndContext;\n}\n\nexport { getTemporaryCanvasFromImage };\n//# sourceMappingURL=getTemporaryCanvasFromImage.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { HTMLTextPipe } from './HTMLTextPipe.mjs';\nimport { HTMLTextSystem } from './HTMLTextSystem.mjs';\n\n\"use strict\";\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass FilterPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  push(filterEffect, container, instructionSet) {\n    const renderPipes = this._renderer.renderPipes;\n    renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      canBundle: false,\n      action: \"pushFilter\",\n      container,\n      filterEffect\n    });\n  }\n  pop(_filterEffect, _container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    if (instruction.action === \"pushFilter\") {\n      this._renderer.filter.push(instruction);\n    } else if (instruction.action === \"popFilter\") {\n      this._renderer.filter.pop();\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nFilterPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"filter\"\n};\n\nexport { FilterPipe };\n//# sourceMappingURL=FilterPipe.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize: vec4<f32>,\\n  uInputPixel: vec4<f32>,\\n  uInputClamp: vec4<f32>,\\n  uOutputFrame: vec4<f32>,\\n  uGlobalFrame: vec4<f32>,\\n  uOutputTexture: vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler: sampler;\\n\\nstruct VSOutput {\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv: vec2<f32>\\n};\\n\\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition: vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n    return textureSample(uTexture, uSampler, uv);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=passthrough.wgsl.mjs.map\n","import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Filter } from '../../Filter.mjs';\nimport vertex from '../defaultFilter.vert.mjs';\nimport fragment from './passthrough.frag.mjs';\nimport source from './passthrough.wgsl.mjs';\n\n\"use strict\";\nclass PassthroughFilter extends Filter {\n  constructor() {\n    const gpuProgram = GpuProgram.from({\n      vertex: { source, entryPoint: \"mainVertex\" },\n      fragment: { source, entryPoint: \"mainFragment\" },\n      name: \"passthrough-filter\"\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"passthrough-filter\"\n    });\n    super({\n      gpuProgram,\n      glProgram\n    });\n  }\n}\n\nexport { PassthroughFilter };\n//# sourceMappingURL=PassthroughFilter.mjs.map\n","var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=defaultFilter.vert.mjs.map\n","var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\nuniform sampler2D uTexture;\\nvoid main() {\\n    finalColor = texture(uTexture, vTextureCoord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=passthrough.frag.mjs.map\n","import '../../../maths/index.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\n\n\"use strict\";\nconst tempProjectionMatrix = new Matrix();\nfunction getGlobalRenderableBounds(renderables, bounds) {\n  bounds.clear();\n  const actualMatrix = bounds.matrix;\n  for (let i = 0; i < renderables.length; i++) {\n    const renderable = renderables[i];\n    if (renderable.globalDisplayStatus < 7) {\n      continue;\n    }\n    const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n    if (renderGroup?.isCachedAsTexture) {\n      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform).append(renderable.worldTransform);\n    } else if (renderGroup?._parentCacheAsTextureRenderGroup) {\n      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(renderable.groupTransform);\n    } else {\n      bounds.matrix = renderable.worldTransform;\n    }\n    bounds.addBounds(renderable.bounds);\n  }\n  bounds.matrix = actualMatrix;\n  return bounds;\n}\n\nexport { getGlobalRenderableBounds };\n//# sourceMappingURL=getRenderableBounds.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { PassthroughFilter } from './defaults/passthrough/PassthroughFilter.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterData {\n  constructor() {\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    this.skip = false;\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    this.inputTexture = null;\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    this.backTexture = null;\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    this.filters = null;\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    this.bounds = new Bounds();\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    this.container = null;\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    this.blendRequired = false;\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    this.outputRenderSurface = null;\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n    /** The first enabled filter index in the current filter list. */\n    this.firstEnabledIndex = -1;\n    /** The last enabled filter index in the current filter list. */\n    this.lastEnabledIndex = -1;\n  }\n}\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputPixel: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uInputClamp: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uGlobalFrame: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uOutputTexture: { value: new Float32Array(4), type: \"vec4<f32>\" }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  /**\n   * Pushes a filter instruction onto the filter stack.\n   * @param instruction - The instruction containing the filter effect and container.\n   * @internal\n   */\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    const filterData = this._pushFilterData();\n    filterData.skip = false;\n    filterData.filters = filters;\n    filterData.container = instruction.container;\n    filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.every((filter) => !filter.enabled)) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    this._calculateFilterArea(instruction, bounds);\n    this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n    if (filterData.skip) {\n      return;\n    }\n    const previousFilterData = this._getPreviousFilterData();\n    const globalResolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (previousFilterData) {\n      offsetX = previousFilterData.bounds.minX;\n      offsetY = previousFilterData.bounds.minY;\n    }\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n  }\n  /**\n   * Applies filters to a texture.\n   *\n   * This method takes a texture and a list of filters, applies the filters to the texture,\n   * and returns the resulting texture.\n   * @param {object} params - The parameters for applying filters.\n   * @param {Texture} params.texture - The texture to apply filters to.\n   * @param {Filter[]} params.filters - The filters to apply.\n   * @returns {Texture} The resulting texture after all filters have been applied.\n   * @example\n   *\n   * ```ts\n   * // Create a texture and a list of filters\n   * const texture = new Texture(...);\n   * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n   *\n   * // Apply the filters to the texture\n   * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n   *\n   * // Use the resulting texture\n   * sprite.texture = resultTexture;\n   * ```\n   *\n   * Key Points:\n   * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n   * 2. If all filters are disabled or skipped, the original texture is returned.\n   */\n  generateFilteredTexture({ texture, filters }) {\n    const filterData = this._pushFilterData();\n    this._activeFilterData = filterData;\n    filterData.skip = false;\n    filterData.filters = filters;\n    const colorTextureSource = texture.source;\n    const rootResolution = colorTextureSource.resolution;\n    const rootAntialias = colorTextureSource.antialias;\n    if (filters.every((filter) => !filter.enabled)) {\n      filterData.skip = true;\n      return texture;\n    }\n    const bounds = filterData.bounds;\n    bounds.addRect(texture.frame);\n    this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n    if (filterData.skip) {\n      return texture;\n    }\n    const globalResolution = rootResolution;\n    const offsetX = 0;\n    const offsetY = 0;\n    this._calculateGlobalFrame(\n      filterData,\n      offsetX,\n      offsetY,\n      globalResolution,\n      colorTextureSource.width,\n      colorTextureSource.height\n    );\n    filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = texture;\n    const renderer = this.renderer;\n    renderer.renderTarget.finishRenderPass();\n    this._applyFiltersToTexture(filterData, true);\n    const outputTexture = filterData.outputRenderSurface;\n    outputTexture.source.alphaMode = \"premultiplied-alpha\";\n    return outputTexture;\n  }\n  /** @internal */\n  pop() {\n    const renderer = this.renderer;\n    const filterData = this._popFilterData();\n    if (filterData.skip) {\n      return;\n    }\n    renderer.globalUniforms.pop();\n    renderer.renderTarget.finishRenderPass();\n    this._activeFilterData = filterData;\n    this._applyFiltersToTexture(filterData, false);\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(filterData.backTexture);\n    }\n    TexturePool.returnTexture(filterData.inputTexture);\n  }\n  /**\n   * Copies the last render surface to a texture.\n   * @param lastRenderSurface - The last render surface to copy from.\n   * @param bounds - The bounds of the area to copy.\n   * @param previousBounds - The previous bounds to use for offsetting the copy.\n   */\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      backgroundResolution,\n      false\n    );\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(\n      lastRenderSurface,\n      backTexture,\n      { x, y },\n      { width, height },\n      { x: 0, y: 0 }\n    );\n    return backTexture;\n  }\n  /**\n   * Applies a filter to a texture.\n   * @param filter - The filter to apply.\n   * @param input - The input texture.\n   * @param output - The output render surface.\n   * @param clear - Whether to clear the output surface before applying the filter.\n   */\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._activeFilterData;\n    const outputRenderSurface = filterData.outputRenderSurface;\n    const isFinalTarget = outputRenderSurface === output;\n    const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    const resolution = this._findFilterResolution(rootResolution);\n    let offsetX = 0;\n    let offsetY = 0;\n    if (isFinalTarget) {\n      const offset = this._findPreviousFilterOffset();\n      offsetX = offset.x;\n      offsetY = offset.y;\n    }\n    this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n    const filterToApply = filter.enabled ? filter : this._getPassthroughFilter();\n    this._setupBindGroupsAndRender(filterToApply, input, renderer);\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(\n      data.inputTexture._source.width,\n      0,\n      0,\n      data.inputTexture._source.height,\n      data.bounds.minX,\n      data.bounds.minY\n    );\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n    if (renderGroup && renderGroup.cacheToLocalTransform) {\n      worldTransform.prepend(renderGroup.cacheToLocalTransform);\n    }\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(\n      1 / sprite.texture.orig.width,\n      1 / sprite.texture.orig.height\n    );\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n  destroy() {\n    this._passthroughFilter?.destroy(true);\n    this._passthroughFilter = null;\n  }\n  _getPassthroughFilter() {\n    this._passthroughFilter ?? (this._passthroughFilter = new PassthroughFilter());\n    return this._passthroughFilter;\n  }\n  /**\n   * Sets up the bind groups and renders the filter.\n   * @param filter - The filter to apply\n   * @param input - The input texture\n   * @param renderer - The renderer instance\n   */\n  _setupBindGroupsAndRender(filter, input, renderer) {\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  /**\n   * Sets up the filter textures including input texture and back texture if needed.\n   * @param filterData - The filter data to update\n   * @param bounds - The bounds for the texture\n   * @param renderer - The renderer instance\n   * @param previousFilterData - The previous filter data for back texture calculation\n   */\n  _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {\n    filterData.backTexture = Texture.EMPTY;\n    filterData.inputTexture = TexturePool.getOptimalTexture(\n      bounds.width,\n      bounds.height,\n      filterData.resolution,\n      filterData.antialias\n    );\n    if (filterData.blendRequired) {\n      renderer.renderTarget.finishRenderPass();\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n      filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n    }\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  /**\n   * Calculates and sets the global frame for the filter.\n   * @param filterData - The filter data to update\n   * @param offsetX - The X offset\n   * @param offsetY - The Y offset\n   * @param globalResolution - The global resolution\n   * @param sourceWidth - The source texture width\n   * @param sourceHeight - The source texture height\n   */\n  _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {\n    const globalFrame = filterData.globalFrame;\n    globalFrame.x = offsetX * globalResolution;\n    globalFrame.y = offsetY * globalResolution;\n    globalFrame.width = sourceWidth * globalResolution;\n    globalFrame.height = sourceHeight * globalResolution;\n  }\n  /**\n   * Updates the filter uniforms with the current filter state.\n   * @param input - The input texture\n   * @param output - The output render surface\n   * @param filterData - The current filter data\n   * @param offsetX - The X offset for positioning\n   * @param offsetY - The Y offset for positioning\n   * @param resolution - The current resolution\n   * @param isFinalTarget - Whether this is the final render target\n   * @param clear - Whether to clear the output surface\n   */\n  _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {\n    const uniforms = this._filterGlobalUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      outputFrame[0] = filterData.bounds.minX - offsetX;\n      outputFrame[1] = filterData.bounds.minY - offsetY;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offsetX * resolution;\n    globalFrame[1] = offsetY * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    if (output instanceof Texture)\n      output.source.resource = null;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    this.renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    this._filterGlobalUniforms.update();\n  }\n  /**\n   * Finds the correct resolution by looking back through the filter stack.\n   * @param rootResolution - The fallback root resolution to use\n   * @returns The resolution from the previous filter or root resolution\n   */\n  _findFilterResolution(rootResolution) {\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;\n  }\n  /**\n   * Finds the offset from the previous non-skipped filter in the stack.\n   * @returns The offset coordinates from the previous filter\n   */\n  _findPreviousFilterOffset() {\n    let offsetX = 0;\n    let offsetY = 0;\n    let lastIndex = this._filterStackIndex;\n    while (lastIndex > 0) {\n      lastIndex--;\n      const prevFilterData = this._filterStack[lastIndex];\n      if (!prevFilterData.skip) {\n        offsetX = prevFilterData.bounds.minX;\n        offsetY = prevFilterData.bounds.minY;\n        break;\n      }\n    }\n    return { x: offsetX, y: offsetY };\n  }\n  /**\n   * Calculates the filter area bounds based on the instruction type.\n   * @param instruction - The filter instruction\n   * @param bounds - The bounds object to populate\n   */\n  _calculateFilterArea(instruction, bounds) {\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      instruction.container.getFastGlobalBounds(true, bounds);\n    }\n    if (instruction.container) {\n      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n      const filterFrameTransform = renderGroup.cacheToLocalTransform;\n      if (filterFrameTransform) {\n        bounds.applyMatrix(filterFrameTransform);\n      }\n    }\n  }\n  _applyFiltersToTexture(filterData, clear) {\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    const firstEnabled = filterData.firstEnabledIndex;\n    const lastEnabled = filterData.lastEnabledIndex;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n    if (firstEnabled === lastEnabled) {\n      filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n    } else {\n      let flip = filterData.inputTexture;\n      const tempTexture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        flip.source._resolution,\n        false\n      );\n      let flop = tempTexture;\n      for (let i = firstEnabled; i < lastEnabled; i++) {\n        const filter = filters[i];\n        if (!filter.enabled)\n          continue;\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);\n      TexturePool.returnTexture(tempTexture);\n    }\n  }\n  _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {\n    const renderer = this.renderer;\n    const bounds = filterData.bounds;\n    const filters = filterData.filters;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    let clipToViewport = true;\n    let firstEnabledIndex = -1;\n    let lastEnabledIndex = -1;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      if (!filter.enabled)\n        continue;\n      if (firstEnabledIndex === -1)\n        firstEnabledIndex = i;\n      lastEnabledIndex = i;\n      resolution = Math.min(resolution, filter.resolution === \"inherit\" ? rootResolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === \"off\") {\n        antialias = false;\n      } else if (filter.antialias === \"inherit\") {\n        antialias && (antialias = rootAntialias);\n      }\n      if (!filter.clipToViewport) {\n        clipToViewport = false;\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = true;\n      blendRequired || (blendRequired = filter.blendRequired);\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    if (clipToViewport) {\n      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n    }\n    bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.antialias = antialias;\n    filterData.resolution = resolution;\n    filterData.blendRequired = blendRequired;\n    filterData.firstEnabledIndex = firstEnabledIndex;\n    filterData.lastEnabledIndex = lastEnabledIndex;\n  }\n  _popFilterData() {\n    this._filterStackIndex--;\n    return this._filterStack[this._filterStackIndex];\n  }\n  _getPreviousFilterData() {\n    let previousFilterData;\n    let index = this._filterStackIndex - 1;\n    while (index > 0) {\n      index--;\n      previousFilterData = this._filterStack[index];\n      if (!previousFilterData.skip) {\n        break;\n      }\n    }\n    return previousFilterData;\n  }\n  _pushFilterData() {\n    let filterData = this._filterStack[this._filterStackIndex];\n    if (!filterData) {\n      filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n    }\n    this._filterStackIndex++;\n    return filterData;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"filter\"\n};\n\nexport { FilterSystem };\n//# sourceMappingURL=FilterSystem.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { FilterPipe } from './FilterPipe.mjs';\nimport { FilterSystem } from './FilterSystem.mjs';\n\n\"use strict\";\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n//# sourceMappingURL=init.mjs.map\n","import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../../view/ViewContainer.mjs';\nimport { GraphicsContext } from './GraphicsContext.mjs';\n\n\"use strict\";\nclass Graphics extends ViewContainer {\n  /**\n   * Creates a new Graphics object.\n   * @param options - Options for the Graphics.\n   */\n  constructor(options) {\n    if (options instanceof GraphicsContext) {\n      options = { context: options };\n    }\n    const { context, roundPixels, ...rest } = options || {};\n    super({\n      label: \"Graphics\",\n      ...rest\n    });\n    /** @internal */\n    this.renderPipeId = \"graphics\";\n    if (!context) {\n      this.context = this._ownedContext = new GraphicsContext();\n      this.context.autoGarbageCollect = this.autoGarbageCollect;\n    } else {\n      this.context = context;\n    }\n    this.didViewUpdate = true;\n    this.allowChildren = false;\n    this.roundPixels = roundPixels ?? false;\n  }\n  set context(context) {\n    if (context === this._context)\n      return;\n    if (this._context) {\n      this._context.off(\"update\", this.onViewUpdate, this);\n      this._context.off(\"unload\", this.unload, this);\n    }\n    this._context = context;\n    this._context.on(\"update\", this.onViewUpdate, this);\n    this._context.on(\"unload\", this.unload, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The underlying graphics context used for drawing operations.\n   * Controls how shapes and paths are rendered.\n   * @example\n   * ```ts\n   * // Create a shared context\n   * const sharedContext = new GraphicsContext();\n   *\n   * // Create graphics objects sharing the same context\n   * const graphics1 = new Graphics();\n   * const graphics2 = new Graphics();\n   *\n   * // Assign shared context\n   * graphics1.context = sharedContext;\n   * graphics2.context = sharedContext;\n   *\n   * // Both graphics will show the same shapes\n   * sharedContext\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @see {@link GraphicsContext} For drawing operations\n   * @see {@link GraphicsOptions} For context configuration\n   */\n  get context() {\n    return this._context;\n  }\n  /**\n   * The local bounds of the graphics object.\n   * Returns the boundaries after all graphical operations but before any transforms.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Get bounds information\n   * const bounds = graphics.bounds;\n   * console.log(bounds.width);  // 100\n   * console.log(bounds.height); // 100\n   * ```\n   * @readonly\n   * @see {@link Bounds} For bounds operations\n   * @see {@link Container#getBounds} For transformed bounds\n   */\n  get bounds() {\n    return this._context.bounds;\n  }\n  /**\n   * Graphics objects do not need to update their bounds as the context handles this.\n   * @private\n   */\n  updateBounds() {\n  }\n  /**\n   * Checks if the object contains the given point.\n   * Returns true if the point lies within the Graphics object's rendered area.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw a shape\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Check point intersection\n   * if (graphics.containsPoint({ x: 50, y: 50 })) {\n   *     console.log('Point is inside rectangle!');\n   * }\n   * ```\n   * @param point - The point to check in local coordinates\n   * @returns True if the point is inside the Graphics object\n   * @see {@link Graphics#bounds} For bounding box checks\n   * @see {@link PointData} For point data structure\n   */\n  containsPoint(point) {\n    return this._context.containsPoint(point);\n  }\n  /**\n   * Destroys this graphics renderable and optionally its context.\n   * @param options - Options parameter. A boolean will act as if all options\n   *\n   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n   * then the context will still be destroyed.\n   *\n   * If you want to explicitly not destroy this context that this graphics created,\n   * then you should pass destroy({ context: false })\n   *\n   * If the context was passed in as an argument to the constructor then it will not be destroyed\n   * @example\n   * ```ts\n   * // Destroy the graphics and its context\n   * graphics.destroy();\n   * graphics.destroy(true);\n   * graphics.destroy({ context: true, texture: true, textureSource: true });\n   * ```\n   */\n  destroy(options) {\n    if (this._ownedContext && !options) {\n      this._ownedContext.destroy(options);\n    } else if (options === true || options?.context === true) {\n      this._context.destroy(options);\n    }\n    this._ownedContext = null;\n    this._context = null;\n    super.destroy(options);\n  }\n  /**\n   * @param now - The current time in milliseconds.\n   * @internal\n   */\n  _onTouch(now) {\n    this._gcLastUsed = now;\n    this._context._gcLastUsed = now;\n  }\n  _callContextMethod(method, args) {\n    this.context[method](...args);\n    return this;\n  }\n  // --------------------------------------- GraphicsContext methods ---------------------------------------\n  /**\n   * Sets the current fill style of the graphics context.\n   * The fill style can be a color, gradient, pattern, or a complex style object.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics\n   *     .setFillStyle({ color: 0xff0000 }) // Red fill\n   *     .rect(0, 0, 100, 100)\n   *     .fill();\n   *\n   * // Gradient fill\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setFillStyle(gradient)\n   *     .circle(100, 100, 50)\n   *     .fill();\n   *\n   * // Pattern fill\n   * const pattern = new FillPattern(texture);\n   * graphics\n   *     .setFillStyle({\n   *         fill: pattern,\n   *         alpha: 0.5\n   *     })\n   *     .rect(0, 0, 200, 200)\n   *     .fill();\n   * ```\n   * @param {FillInput} args - The fill style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link FillStyle} For fill style options\n   * @see {@link FillGradient} For gradient fills\n   * @see {@link FillPattern} For pattern fills\n   */\n  setFillStyle(...args) {\n    return this._callContextMethod(\"setFillStyle\", args);\n  }\n  /**\n   * Sets the current stroke style of the graphics context.\n   * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color stroke\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 2,\n   *         color: 0x000000\n   *     })\n   *     .rect(0, 0, 100, 100)\n   *     .stroke();\n   *\n   * // Complex stroke style\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 4,\n   *         color: 0xff0000,\n   *         alpha: 0.5,\n   *         join: 'round',\n   *         cap: 'round',\n   *         alignment: 0.5\n   *     })\n   *     .circle(100, 100, 50)\n   *     .stroke();\n   *\n   * // Gradient stroke\n   * const gradient = new FillGradient({\n   *    end: { x: 1, y: 0 },\n   *    colorStops: [\n   *         { offset: 0, color: 0xff0000 }, // Red at start\n   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n   *         { offset: 1, color: 0x0000ff }, // Blue at end\n   *    ],\n   * });\n   *\n   * graphics\n   *     .setStrokeStyle({\n   *         width: 10,\n   *         fill: gradient\n   *     })\n   *     .poly([0,0, 100,50, 0,100])\n   *     .stroke();\n   * ```\n   * @param {StrokeInput} args - The stroke style to apply\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link FillPattern} For pattern strokes\n   */\n  setStrokeStyle(...args) {\n    return this._callContextMethod(\"setStrokeStyle\", args);\n  }\n  fill(...args) {\n    return this._callContextMethod(\"fill\", args);\n  }\n  /**\n   * Strokes the current path with the current stroke style or specified style.\n   * Outlines the shape using the stroke settings.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Stroke with direct color\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .stroke({\n   *         width: 2,\n   *         color: 0xff0000\n   *     }); // 2px red stroke\n   *\n   * // Fill with texture\n   * graphics\n   *    .rect(0, 0, 100, 100)\n   *    .stroke(myTexture); // Fill with texture\n   *\n   * // Stroke with gradient\n   * const gradient = new FillGradient({\n   *     end: { x: 1, y: 0 },\n   *     colorStops: [\n   *         { offset: 0, color: 0xff0000 },\n   *         { offset: 0.5, color: 0x00ff00 },\n   *         { offset: 1, color: 0x0000ff },\n   *     ],\n   * });\n   *\n   * graphics\n   *     .rect(0, 0, 100, 100)\n   *     .stroke({\n   *         width: 4,\n   *         fill: gradient,\n   *         alignment: 0.5,\n   *         join: 'round'\n   *     });\n   * ```\n   * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n   * - A stroke style object with width, color, etc.\n   * - A gradient\n   * - A pattern\n   * If omitted, uses current stroke style.\n   * @returns The Graphics instance for chaining\n   * @see {@link StrokeStyle} For stroke style options\n   * @see {@link FillGradient} For gradient strokes\n   * @see {@link setStrokeStyle} For setting default stroke style\n   */\n  stroke(...args) {\n    return this._callContextMethod(\"stroke\", args);\n  }\n  texture(...args) {\n    return this._callContextMethod(\"texture\", args);\n  }\n  /**\n   * Resets the current path. Any previous path and its commands are discarded and a new path is\n   * started. This is typically called before beginning a new shape or series of drawing commands.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   * graphics\n   *     .circle(150, 150, 50)\n   *     .fill({ color: 0x00ff00 })\n   *     .beginPath() // Starts a new path\n   *     .circle(250, 150, 50)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for chaining\n   * @see {@link Graphics#moveTo} For starting a new subpath\n   * @see {@link Graphics#closePath} For closing the current path\n   */\n  beginPath() {\n    return this._callContextMethod(\"beginPath\", []);\n  }\n  /**\n   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n   * subtracting a path from the previously drawn path.\n   *\n   * If a hole is not completely in a shape, it will fail to cut correctly.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw outer circle\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *     .circle(100, 100, 25) // Inner circle\n   *     .cut() // Cuts out the inner circle from the outer circle\n   * ```\n   */\n  cut() {\n    return this._callContextMethod(\"cut\", []);\n  }\n  arc(...args) {\n    return this._callContextMethod(\"arc\", args);\n  }\n  arcTo(...args) {\n    return this._callContextMethod(\"arcTo\", args);\n  }\n  arcToSvg(...args) {\n    return this._callContextMethod(\"arcToSvg\", args);\n  }\n  bezierCurveTo(...args) {\n    return this._callContextMethod(\"bezierCurveTo\", args);\n  }\n  /**\n   * Closes the current path by drawing a straight line back to the start point.\n   *\n   * This is useful for completing shapes and ensuring they are properly closed for fills.\n   * @example\n   * ```ts\n   * // Create a triangle with closed path\n   * const graphics = new Graphics();\n   * graphics\n   *     .moveTo(50, 50)\n   *     .lineTo(100, 100)\n   *     .lineTo(0, 100)\n   *     .closePath()\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path\n   * @see {@link Graphics#fill} For filling closed paths\n   * @see {@link Graphics#stroke} For stroking paths\n   */\n  closePath() {\n    return this._callContextMethod(\"closePath\", []);\n  }\n  ellipse(...args) {\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  circle(...args) {\n    return this._callContextMethod(\"circle\", args);\n  }\n  path(...args) {\n    return this._callContextMethod(\"path\", args);\n  }\n  lineTo(...args) {\n    return this._callContextMethod(\"lineTo\", args);\n  }\n  moveTo(...args) {\n    return this._callContextMethod(\"moveTo\", args);\n  }\n  quadraticCurveTo(...args) {\n    return this._callContextMethod(\"quadraticCurveTo\", args);\n  }\n  rect(...args) {\n    return this._callContextMethod(\"rect\", args);\n  }\n  roundRect(...args) {\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  poly(...args) {\n    return this._callContextMethod(\"poly\", args);\n  }\n  regularPoly(...args) {\n    return this._callContextMethod(\"regularPoly\", args);\n  }\n  roundPoly(...args) {\n    return this._callContextMethod(\"roundPoly\", args);\n  }\n  roundShape(...args) {\n    return this._callContextMethod(\"roundShape\", args);\n  }\n  filletRect(...args) {\n    return this._callContextMethod(\"filletRect\", args);\n  }\n  chamferRect(...args) {\n    return this._callContextMethod(\"chamferRect\", args);\n  }\n  star(...args) {\n    return this._callContextMethod(\"star\", args);\n  }\n  svg(...args) {\n    return this._callContextMethod(\"svg\", args);\n  }\n  restore(...args) {\n    return this._callContextMethod(\"restore\", args);\n  }\n  /**\n   * Saves the current graphics state onto a stack. The state includes:\n   * - Current transformation matrix\n   * - Current fill style\n   * - Current stroke style\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Save state before complex operations\n   * graphics.save();\n   *\n   * // Create transformed and styled shape\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4)\n   *     .setFillStyle({\n   *         color: 0xff0000,\n   *         alpha: 0.5\n   *     })\n   *     .rect(-25, -25, 50, 50)\n   *     .fill();\n   *\n   * // Restore to original state\n   * graphics.restore();\n   *\n   * // Continue drawing with previous state\n   * graphics\n   *     .circle(50, 50, 25)\n   *     .fill();\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#restore} For restoring the saved state\n   * @see {@link Graphics#setTransform} For setting transformations\n   */\n  save() {\n    return this._callContextMethod(\"save\", []);\n  }\n  /**\n   * Returns the current transformation matrix of the graphics context.\n   * This matrix represents all accumulated transformations including translate, scale, and rotate.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply some transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .rotateTransform(Math.PI / 4);\n   *\n   * // Get the current transform matrix\n   * const matrix = graphics.getTransform();\n   * console.log(matrix.tx, matrix.ty); // 100, 100\n   *\n   * // Use the matrix for other operations\n   * graphics\n   *     .setTransform(matrix)\n   *     .circle(0, 0, 50)\n   *     .fill({ color: 0xff0000 });\n   * ```\n   * @returns The current transformation matrix.\n   * @see {@link Graphics#setTransform} For setting the transform matrix\n   * @see {@link Matrix} For matrix operations\n   */\n  getTransform() {\n    return this.context.getTransform();\n  }\n  /**\n   * Resets the current transformation matrix to the identity matrix, effectively removing\n   * any transformations (rotation, scaling, translation) previously applied.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Apply transformations\n   * graphics\n   *     .translateTransform(100, 100)\n   *     .scaleTransform(2, 2)\n   *     .circle(0, 0, 25)\n   *     .fill({ color: 0xff0000 });\n   * // Reset transform to default state\n   * graphics\n   *     .resetTransform()\n   *     .circle(50, 50, 25) // Will draw at actual coordinates\n   *     .fill({ color: 0x00ff00 });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#getTransform} For getting the current transform\n   * @see {@link Graphics#setTransform} For setting a specific transform\n   * @see {@link Graphics#save} For saving the current transform state\n   * @see {@link Graphics#restore} For restoring a previous transform state\n   */\n  resetTransform() {\n    return this._callContextMethod(\"resetTransform\", []);\n  }\n  rotateTransform(...args) {\n    return this._callContextMethod(\"rotate\", args);\n  }\n  scaleTransform(...args) {\n    return this._callContextMethod(\"scale\", args);\n  }\n  setTransform(...args) {\n    return this._callContextMethod(\"setTransform\", args);\n  }\n  transform(...args) {\n    return this._callContextMethod(\"transform\", args);\n  }\n  translateTransform(...args) {\n    return this._callContextMethod(\"translate\", args);\n  }\n  /**\n   * Clears all drawing commands from the graphics context, effectively resetting it.\n   * This includes clearing the current path, fill style, stroke style, and transformations.\n   *\n   * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n   * > Instead, they are intended to be used for static or semi-static graphics that\n   * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Draw some shapes\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 })\n   *     .rect(200, 100, 100, 50)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Clear all graphics\n   * graphics.clear();\n   *\n   * // Start fresh with new shapes\n   * graphics\n   *     .circle(150, 150, 30)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @returns The Graphics instance for method chaining\n   * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n   * @see {@link Graphics#save} For saving the current state\n   * @see {@link Graphics#restore} For restoring a previous state\n   */\n  clear() {\n    return this._callContextMethod(\"clear\", []);\n  }\n  /**\n   * Gets or sets the current fill style for the graphics context. The fill style determines\n   * how shapes are filled when using the fill() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic color fill\n   * graphics.fillStyle = {\n   *     color: 0xff0000,  // Red\n   *     alpha: 1\n   * };\n   *\n   * // Using gradients\n   * const gradient = new FillGradient({\n   *     end: { x: 0, y: 1 }, // Vertical gradient\n   *     stops: [\n   *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n   *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n   *     ]\n   * });\n   *\n   * graphics.fillStyle = {\n   *     fill: gradient,\n   *     alpha: 0.8\n   * };\n   *\n   * // Using patterns\n   * graphics.fillStyle = {\n   *     texture: myTexture,\n   *     alpha: 1,\n   *     matrix: new Matrix()\n   *         .scale(0.5, 0.5)\n   *         .rotate(Math.PI / 4)\n   * };\n   * ```\n   * @type {ConvertedFillStyle}\n   * @see {@link FillStyle} For all available fill style options\n   * @see {@link FillGradient} For creating gradient fills\n   * @see {@link Graphics#fill} For applying the fill to paths\n   */\n  get fillStyle() {\n    return this._context.fillStyle;\n  }\n  set fillStyle(value) {\n    this._context.fillStyle = value;\n  }\n  /**\n   * Gets or sets the current stroke style for the graphics context. The stroke style determines\n   * how paths are outlined when using the stroke() method.\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Basic stroke style\n   * graphics.strokeStyle = {\n   *     width: 2,\n   *     color: 0xff0000,\n   *     alpha: 1\n   * };\n   *\n   * // Using with gradients\n   * const gradient = new FillGradient({\n   *   end: { x: 0, y: 1 },\n   *   stops: [\n   *       { offset: 0, color: 0xff0000, alpha: 1 },\n   *       { offset: 1, color: 0x0000ff, alpha: 1 }\n   *   ]\n   * });\n   *\n   * graphics.strokeStyle = {\n   *     width: 4,\n   *     fill: gradient,\n   *     alignment: 0.5,\n   *     join: 'round',\n   *     cap: 'round'\n   * };\n   *\n   * // Complex stroke settings\n   * graphics.strokeStyle = {\n   *     width: 6,\n   *     color: 0x00ff00,\n   *     alpha: 0.5,\n   *     join: 'miter',\n   *     miterLimit: 10,\n   * };\n   * ```\n   * @see {@link StrokeStyle} For all available stroke style options\n   * @see {@link Graphics#stroke} For applying the stroke to paths\n   */\n  get strokeStyle() {\n    return this._context.strokeStyle;\n  }\n  set strokeStyle(value) {\n    this._context.strokeStyle = value;\n  }\n  /**\n   * Creates a new Graphics object that copies the current graphics content.\n   * The clone can either share the same context (shallow clone) or have its own independent\n   * context (deep clone).\n   * @example\n   * ```ts\n   * const graphics = new Graphics();\n   *\n   * // Create original graphics content\n   * graphics\n   *     .circle(100, 100, 50)\n   *     .fill({ color: 0xff0000 });\n   *\n   * // Create a shallow clone (shared context)\n   * const shallowClone = graphics.clone();\n   *\n   * // Changes to original affect the clone\n   * graphics\n   *     .circle(200, 100, 30)\n   *     .fill({ color: 0x00ff00 });\n   *\n   * // Create a deep clone (independent context)\n   * const deepClone = graphics.clone(true);\n   *\n   * // Modify deep clone independently\n   * deepClone\n   *     .translateTransform(100, 100)\n   *     .circle(0, 0, 40)\n   *     .fill({ color: 0x0000ff });\n   * ```\n   * @param deep - Whether to create a deep clone of the graphics object.\n   *              If false (default), the context will be shared between objects.\n   *              If true, creates an independent copy of the context.\n   * @returns A new Graphics instance with either shared or copied context\n   * @see {@link Graphics#context} For accessing the underlying graphics context\n   * @see {@link GraphicsContext} For understanding the shared context behavior\n   */\n  clone(deep = false) {\n    if (deep) {\n      return new Graphics(this._context.clone());\n    }\n    this._ownedContext = null;\n    const clone = new Graphics(this._context);\n    return clone;\n  }\n  // -------- v7 deprecations ---------\n  /**\n   * @param width\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n   */\n  lineStyle(width, color, alpha) {\n    deprecation(v8_0_0, \"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.\");\n    const strokeStyle = {};\n    width && (strokeStyle.width = width);\n    color && (strokeStyle.color = color);\n    alpha && (strokeStyle.alpha = alpha);\n    this.context.strokeStyle = strokeStyle;\n    return this;\n  }\n  /**\n   * @param color\n   * @param alpha\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  beginFill(color, alpha) {\n    deprecation(v8_0_0, \"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    const fillStyle = {};\n    if (color !== void 0)\n      fillStyle.color = color;\n    if (alpha !== void 0)\n      fillStyle.alpha = alpha;\n    this.context.fillStyle = fillStyle;\n    return this;\n  }\n  /**\n   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n   */\n  endFill() {\n    deprecation(v8_0_0, \"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.\");\n    this.context.fill();\n    const strokeStyle = this.context.strokeStyle;\n    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {\n      this.context.stroke();\n    }\n    return this;\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n   */\n  drawCircle(...args) {\n    deprecation(v8_0_0, \"Graphics#drawCircle has been renamed to Graphics#circle\");\n    return this._callContextMethod(\"circle\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n   */\n  drawEllipse(...args) {\n    deprecation(v8_0_0, \"Graphics#drawEllipse has been renamed to Graphics#ellipse\");\n    return this._callContextMethod(\"ellipse\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n   */\n  drawPolygon(...args) {\n    deprecation(v8_0_0, \"Graphics#drawPolygon has been renamed to Graphics#poly\");\n    return this._callContextMethod(\"poly\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n   */\n  drawRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRect has been renamed to Graphics#rect\");\n    return this._callContextMethod(\"rect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n   */\n  drawRoundedRect(...args) {\n    deprecation(v8_0_0, \"Graphics#drawRoundedRect has been renamed to Graphics#roundRect\");\n    return this._callContextMethod(\"roundRect\", args);\n  }\n  /**\n   * @param {...any} args\n   * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n   */\n  drawStar(...args) {\n    deprecation(v8_0_0, \"Graphics#drawStar has been renamed to Graphics#star\");\n    return this._callContextMethod(\"star\", args);\n  }\n}\n\nexport { Graphics };\n//# sourceMappingURL=Graphics.mjs.map\n","\"use strict\";\nconst localUniformMSDFBit = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n    )\n  }\n};\nconst localUniformMSDFBitGl = {\n  name: \"local-uniform-msdf-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform float uDistance;\n         `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n    )\n  }\n};\n\nexport { localUniformMSDFBit, localUniformMSDFBitGl };\n//# sourceMappingURL=localUniformMSDFBit.mjs.map\n","\"use strict\";\nconst mSDFBit = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `\n    )\n  }\n};\n\nexport { mSDFBit, mSDFBitGl };\n//# sourceMappingURL=mSDFBit.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit.mjs';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass SdfShader extends Shader {\n  constructor(maxTextures) {\n    const uniforms = new UniformGroup({\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uDistance: { value: 4, type: \"f32\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(maxTextures),\n        localUniformMSDFBit,\n        mSDFBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"sdf-shader\",\n      bits: [\n        colorBitGl,\n        generateTextureBatchBitGl(maxTextures),\n        localUniformMSDFBitGl,\n        mSDFBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: uniforms,\n        batchSamplers: getBatchSamplersUniformGroup(maxTextures)\n      }\n    });\n  }\n}\n\nexport { SdfShader };\n//# sourceMappingURL=SdfShader.mjs.map\n","import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash.mjs';\nimport { Graphics } from '../graphics/shared/Graphics.mjs';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics.mjs';\nimport { SdfShader } from '../text/sdfShader/SdfShader.mjs';\nimport { BitmapFontManager } from './BitmapFontManager.mjs';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout.mjs';\n\n\"use strict\";\nclass BitmapTextGraphics extends Graphics {\n  destroy() {\n    if (this.context.customShader) {\n      this.context.customShader.destroy();\n    }\n    super.destroy();\n  }\n}\nclass BitmapTextPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._managedBitmapTexts = new GCManagedHash({ renderer, type: \"renderable\", priority: -2, name: \"bitmapText\" });\n  }\n  validateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n  }\n  addRenderable(bitmapText, instructionSet) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    if (bitmapText._didTextUpdate) {\n      bitmapText._didTextUpdate = false;\n      this._updateContext(bitmapText, graphicsRenderable);\n    }\n    this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  updateRenderable(bitmapText) {\n    const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n    syncWithProxy(bitmapText, graphicsRenderable);\n    this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n    if (graphicsRenderable.context.customShader) {\n      this._updateDistanceField(bitmapText);\n    }\n  }\n  _updateContext(bitmapText, proxyGraphics) {\n    const { context } = proxyGraphics;\n    const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n    context.clear();\n    if (bitmapFont.distanceField.type !== \"none\") {\n      if (!context.customShader) {\n        context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n      }\n    }\n    const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n    const style = bitmapText._style;\n    let currentY = bitmapFont.baseLineOffset;\n    const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n    const padding = style.padding;\n    const scale = bitmapTextLayout.scale;\n    let tx = bitmapTextLayout.width;\n    let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n    if (style._stroke) {\n      tx += style._stroke.width / scale;\n      ty += style._stroke.width / scale;\n    }\n    context.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);\n    const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;\n    let fontSize = bitmapFont.fontMetrics.fontSize;\n    let lineHeight = bitmapFont.lineHeight;\n    if (style.lineHeight) {\n      fontSize = style.fontSize / scale;\n      lineHeight = style.lineHeight / scale;\n    }\n    let linePositionYShift = (lineHeight - fontSize) / 2;\n    if (linePositionYShift - bitmapFont.baseLineOffset < 0) {\n      linePositionYShift = 0;\n    }\n    for (let i = 0; i < bitmapTextLayout.lines.length; i++) {\n      const line = bitmapTextLayout.lines[i];\n      for (let j = 0; j < line.charPositions.length; j++) {\n        const char = line.chars[j];\n        const charData = bitmapFont.chars[char];\n        if (charData?.texture) {\n          const texture = charData.texture;\n          context.texture(\n            texture,\n            tint ? tint : \"black\",\n            Math.round(line.charPositions[j] + charData.xOffset),\n            Math.round(currentY + charData.yOffset + linePositionYShift),\n            texture.orig.width,\n            texture.orig.height\n          );\n        }\n      }\n      currentY += lineHeight;\n    }\n  }\n  _getGpuBitmapText(bitmapText) {\n    return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n  }\n  initGpuText(bitmapText) {\n    const proxyRenderable = new BitmapTextGraphics();\n    bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n    this._updateContext(bitmapText, proxyRenderable);\n    this._managedBitmapTexts.add(bitmapText);\n    return proxyRenderable;\n  }\n  _updateDistanceField(bitmapText) {\n    const context = this._getGpuBitmapText(bitmapText).context;\n    const fontFamily = bitmapText._style.fontFamily;\n    const dynamicFont = Cache.get(`${fontFamily}-bitmap`);\n    const { a, b, c, d } = bitmapText.groupTransform;\n    const dx = Math.sqrt(a * a + b * b);\n    const dy = Math.sqrt(c * c + d * d);\n    const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n    const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n    const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n    context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n  }\n  destroy() {\n    this._managedBitmapTexts.destroy();\n    this._renderer = null;\n    this._managedBitmapTexts = null;\n  }\n}\n/** @ignore */\nBitmapTextPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"bitmapText\"\n};\nfunction syncWithProxy(container, proxy) {\n  proxy.groupTransform = container.groupTransform;\n  proxy.groupColorAlpha = container.groupColorAlpha;\n  proxy.groupColor = container.groupColor;\n  proxy.groupBlendMode = container.groupBlendMode;\n  proxy.globalDisplayStatus = container.globalDisplayStatus;\n  proxy.groupTransform = container.groupTransform;\n  proxy.localDisplayStatus = container.localDisplayStatus;\n  proxy.groupAlpha = container.groupAlpha;\n  proxy._roundPixels = container._roundPixels;\n}\n\nexport { BitmapTextGraphics, BitmapTextPipe };\n//# sourceMappingURL=BitmapTextPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { BitmapTextPipe } from './BitmapTextPipe.mjs';\n\n\"use strict\";\nextensions.add(BitmapTextPipe);\n//# sourceMappingURL=init.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ResizePlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    Object.defineProperty(\n      this,\n      \"resizeTo\",\n      {\n        configurable: true,\n        set(dom) {\n          globalThis.removeEventListener(\"resize\", this.queueResize);\n          this._resizeTo = dom;\n          if (dom) {\n            globalThis.addEventListener(\"resize\", this.queueResize);\n            this.resize();\n          }\n        },\n        get() {\n          return this._resizeTo;\n        }\n      }\n    );\n    this.queueResize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      this._resizeId = requestAnimationFrame(() => this.resize());\n    };\n    this._cancelResize = () => {\n      if (this._resizeId) {\n        cancelAnimationFrame(this._resizeId);\n        this._resizeId = null;\n      }\n    };\n    this.resize = () => {\n      if (!this._resizeTo) {\n        return;\n      }\n      this._cancelResize();\n      let width;\n      let height;\n      if (this._resizeTo === globalThis.window) {\n        width = globalThis.innerWidth;\n        height = globalThis.innerHeight;\n      } else {\n        const { clientWidth, clientHeight } = this._resizeTo;\n        width = clientWidth;\n        height = clientHeight;\n      }\n      this.renderer.resize(width, height);\n      this.render();\n    };\n    this._resizeId = null;\n    this._resizeTo = null;\n    this.resizeTo = options.resizeTo || null;\n  }\n  /**\n   * Clean up the ticker, scoped to application\n   * @private\n   */\n  static destroy() {\n    globalThis.removeEventListener(\"resize\", this.queueResize);\n    this._cancelResize();\n    this._cancelResize = null;\n    this.queueResize = null;\n    this.resizeTo = null;\n    this.resize = null;\n  }\n}\n/** @ignore */\nResizePlugin.extension = ExtensionType.Application;\n\nexport { ResizePlugin };\n//# sourceMappingURL=ResizePlugin.mjs.map\n","import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { UPDATE_PRIORITY } from '../ticker/const.mjs';\nimport { Ticker } from '../ticker/Ticker.mjs';\n\n\"use strict\";\nclass TickerPlugin {\n  /**\n   * Initialize the plugin with scope of application instance\n   * @private\n   * @param {object} [options] - See application options\n   */\n  static init(options) {\n    options = Object.assign({\n      autoStart: true,\n      sharedTicker: false\n    }, options);\n    Object.defineProperty(\n      this,\n      \"ticker\",\n      {\n        configurable: true,\n        set(ticker) {\n          if (this._ticker) {\n            this._ticker.remove(this.render, this);\n          }\n          this._ticker = ticker;\n          if (ticker) {\n            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n          }\n        },\n        get() {\n          return this._ticker;\n        }\n      }\n    );\n    this.stop = () => {\n      this._ticker.stop();\n    };\n    this.start = () => {\n      this._ticker.start();\n    };\n    this._ticker = null;\n    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n    if (options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Clean up the ticker, scoped to application.\n   * @private\n   */\n  static destroy() {\n    if (this._ticker) {\n      const oldTicker = this._ticker;\n      this.ticker = null;\n      oldTicker.destroy();\n    }\n  }\n}\n/** @ignore */\nTickerPlugin.extension = ExtensionType.Application;\n\nexport { TickerPlugin };\n//# sourceMappingURL=TickerPlugin.mjs.map\n","import { extensions } from '../extensions/Extensions.mjs';\nimport { ResizePlugin } from './ResizePlugin.mjs';\nimport { TickerPlugin } from './TickerPlugin.mjs';\n\n\"use strict\";\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n//# sourceMappingURL=init.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _MeshGeometry = class _MeshGeometry extends Geometry {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      deprecation(v8_0_0, \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    let uvs = options.uvs;\n    if (!uvs) {\n      if (options.positions) {\n        uvs = new Float32Array(positions.length);\n      } else {\n        uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n      }\n    }\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new Buffer({\n      data: positions,\n      label: \"attribute-mesh-positions\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const uvBuffer = new Buffer({\n      data: uvs,\n      label: \"attribute-mesh-uvs\",\n      shrinkToFit,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    const indexBuffer = new Buffer({\n      data: indices,\n      label: \"index-mesh-buffer\",\n      shrinkToFit,\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = \"auto\";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  /**\n   * Set the positions of the mesh.\n   * When setting the positions, its important that the uvs array is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The positions of the mesh.\n   */\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  /**\n   * Set the UVs of the mesh.\n   * Its important that the uvs array you set is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The UVs of the mesh.\n   */\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: \"triangle-list\",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\nexport { MeshGeometry };\n//# sourceMappingURL=MeshGeometry.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from './BatchableMesh.mjs';\n\n\"use strict\";\nclass MeshGpuData {\n  destroy() {\n  }\n}\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this.localUniformsBindGroup = new BindGroup({\n      0: this.localUniforms\n    });\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      if (batchableMesh.texture.uid !== mesh._texture.uid) {\n        batchableMesh._textureMatrixUpdateId = -1;\n      }\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        mesh._texture\n      );\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const meshData = this._getMeshData(mesh);\n    if (mesh.didViewUpdate) {\n      meshData.indexSize = mesh._geometry.indices?.length;\n      meshData.vertexSize = mesh._geometry.positions?.length;\n    }\n    if (meshData.batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add(mesh);\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.setTexture(mesh._texture);\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  execute(mesh) {\n    if (!mesh.isRenderable)\n      return;\n    mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    color32BitToUniform(\n      mesh.groupColorAlpha,\n      localUniforms.uniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    mesh._gpuData[this.renderer.uid].meshData = {\n      batched: mesh.batched,\n      indexSize: 0,\n      vertexSize: 0\n    };\n    return mesh._gpuData[this.renderer.uid].meshData;\n  }\n  _getBatchableMesh(mesh) {\n    var _a, _b;\n    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());\n    return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = new BatchableMesh();\n    gpuMesh.renderable = mesh;\n    gpuMesh.setTexture(mesh._texture);\n    gpuMesh.transform = mesh.groupTransform;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n    return gpuMesh;\n  }\n  destroy() {\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"mesh\"\n};\n\nexport { MeshGpuData, MeshPipe };\n//# sourceMappingURL=MeshPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { MeshPipe } from './shared/MeshPipe.mjs';\n\n\"use strict\";\nextensions.add(MeshPipe);\n//# sourceMappingURL=init.mjs.map\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    this._state = State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n    if (options.blendRequired) {\n      this.addResource(\"uBackTexture\", 0, 3);\n    }\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/** The default filter settings */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nconst _PlaneGeometry = class _PlaneGeometry extends MeshGeometry {\n  constructor(...args) {\n    super({});\n    let options = args[0] ?? {};\n    if (typeof options === \"number\") {\n      deprecation(v8_0_0, \"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead\");\n      options = {\n        width: options,\n        height: args[1],\n        verticesX: args[2],\n        verticesY: args[3]\n      };\n    }\n    this.build(options);\n  }\n  /**\n   * Refreshes plane coordinates\n   * @param options - Options to be applied to plane geometry\n   */\n  build(options) {\n    options = { ..._PlaneGeometry.defaultOptions, ...options };\n    this.verticesX = this.verticesX ?? options.verticesX;\n    this.verticesY = this.verticesY ?? options.verticesY;\n    this.width = this.width ?? options.width;\n    this.height = this.height ?? options.height;\n    const total = this.verticesX * this.verticesY;\n    const verts = [];\n    const uvs = [];\n    const indices = [];\n    const verticesX = this.verticesX - 1;\n    const verticesY = this.verticesY - 1;\n    const sizeX = this.width / verticesX;\n    const sizeY = this.height / verticesY;\n    for (let i = 0; i < total; i++) {\n      const x = i % this.verticesX;\n      const y = i / this.verticesX | 0;\n      verts.push(x * sizeX, y * sizeY);\n      uvs.push(x / verticesX, y / verticesY);\n    }\n    const totalSub = verticesX * verticesY;\n    for (let i = 0; i < totalSub; i++) {\n      const xpos = i % verticesX;\n      const ypos = i / verticesX | 0;\n      const value = ypos * this.verticesX + xpos;\n      const value2 = ypos * this.verticesX + xpos + 1;\n      const value3 = (ypos + 1) * this.verticesX + xpos;\n      const value4 = (ypos + 1) * this.verticesX + xpos + 1;\n      indices.push(\n        value,\n        value2,\n        value3,\n        value2,\n        value4,\n        value3\n      );\n    }\n    this.buffers[0].data = new Float32Array(verts);\n    this.buffers[1].data = new Float32Array(uvs);\n    this.indexBuffer.data = new Uint32Array(indices);\n    this.buffers[0].update();\n    this.buffers[1].update();\n    this.indexBuffer.update();\n  }\n};\n_PlaneGeometry.defaultOptions = {\n  width: 100,\n  height: 100,\n  verticesX: 10,\n  verticesY: 10\n};\nlet PlaneGeometry = _PlaneGeometry;\n\nexport { PlaneGeometry };\n//# sourceMappingURL=PlaneGeometry.mjs.map\n","import { PlaneGeometry } from '../mesh-plane/PlaneGeometry.mjs';\n\n\"use strict\";\nconst _NineSliceGeometry = class _NineSliceGeometry extends PlaneGeometry {\n  constructor(options = {}) {\n    options = { ..._NineSliceGeometry.defaultOptions, ...options };\n    super({\n      width: options.width,\n      height: options.height,\n      verticesX: 4,\n      verticesY: 4\n    });\n    this.update(options);\n  }\n  /**\n   * Updates the NineSliceGeometry with the options.\n   * @param options - The options of the NineSliceGeometry.\n   */\n  update(options) {\n    this.width = options.width ?? this.width;\n    this.height = options.height ?? this.height;\n    this._originalWidth = options.originalWidth ?? this._originalWidth;\n    this._originalHeight = options.originalHeight ?? this._originalHeight;\n    this._leftWidth = options.leftWidth ?? this._leftWidth;\n    this._rightWidth = options.rightWidth ?? this._rightWidth;\n    this._topHeight = options.topHeight ?? this._topHeight;\n    this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n    this._anchorX = options.anchor?.x;\n    this._anchorY = options.anchor?.y;\n    this.updateUvs();\n    this.updatePositions();\n  }\n  /** Updates the positions of the vertices. */\n  updatePositions() {\n    const p = this.positions;\n    const {\n      width,\n      height,\n      _leftWidth,\n      _rightWidth,\n      _topHeight,\n      _bottomHeight,\n      _anchorX,\n      _anchorY\n    } = this;\n    const w = _leftWidth + _rightWidth;\n    const scaleW = width > w ? 1 : width / w;\n    const h = _topHeight + _bottomHeight;\n    const scaleH = height > h ? 1 : height / h;\n    const scale = Math.min(scaleW, scaleH);\n    const anchorOffsetX = _anchorX * width;\n    const anchorOffsetY = _anchorY * height;\n    p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n    p[2] = p[10] = p[18] = p[26] = _leftWidth * scale - anchorOffsetX;\n    p[4] = p[12] = p[20] = p[28] = width - _rightWidth * scale - anchorOffsetX;\n    p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n    p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n    p[9] = p[11] = p[13] = p[15] = _topHeight * scale - anchorOffsetY;\n    p[17] = p[19] = p[21] = p[23] = height - _bottomHeight * scale - anchorOffsetY;\n    p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n    this.getBuffer(\"aPosition\").update();\n  }\n  /** Updates the UVs of the vertices. */\n  updateUvs() {\n    const uvs = this.uvs;\n    uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n    uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n    const _uvw = 1 / this._originalWidth;\n    const _uvh = 1 / this._originalHeight;\n    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;\n    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;\n    this.getBuffer(\"aUV\").update();\n  }\n};\n/** The default options for the NineSliceGeometry. */\n_NineSliceGeometry.defaultOptions = {\n  /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  width: 100,\n  /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n  height: 100,\n  /** The width of the left column. */\n  leftWidth: 10,\n  /** The height of the top row. */\n  topHeight: 10,\n  /** The width of the right column. */\n  rightWidth: 10,\n  /** The height of the bottom row. */\n  bottomHeight: 10,\n  /** The original width of the texture */\n  originalWidth: 100,\n  /** The original height of the texture */\n  originalHeight: 100\n};\nlet NineSliceGeometry = _NineSliceGeometry;\n\nexport { NineSliceGeometry };\n//# sourceMappingURL=NineSliceGeometry.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { NineSliceGeometry } from './NineSliceGeometry.mjs';\n\n\"use strict\";\nclass NineSliceSpriteGpuData extends BatchableMesh {\n  constructor() {\n    super();\n    this.geometry = new NineSliceGeometry();\n  }\n  destroy() {\n    this.geometry.destroy();\n  }\n}\nclass NineSliceSpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._managedSprites = new GCManagedHash({ renderer, type: \"renderable\", name: \"nineSliceSprite\" });\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.geometry.update(sprite);\n    batchableSprite.setTexture(sprite._texture);\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n    const batchableMesh = gpuData;\n    batchableMesh.renderable = sprite;\n    batchableMesh.transform = sprite.groupTransform;\n    batchableMesh.texture = sprite._texture;\n    batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._managedSprites.add(sprite);\n    if (!sprite.didViewUpdate) {\n      this._updateBatchableSprite(sprite, batchableMesh);\n    }\n    return gpuData;\n  }\n  destroy() {\n    this._managedSprites.destroy();\n    this._renderer = null;\n  }\n}\n/** @ignore */\nNineSliceSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"nineSliceSprite\"\n};\n\nexport { NineSliceSpriteGpuData, NineSliceSpritePipe };\n//# sourceMappingURL=NineSliceSpritePipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(NineSliceSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n  destroy() {\n    this.reset();\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","\"use strict\";\nconst tilingBit = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    )\n  }\n};\nconst tilingBitGl = {\n  name: \"tiling-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    )\n  }\n};\n\nexport { tilingBit, tilingBitGl };\n//# sourceMappingURL=tilingBit.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram, compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { tilingBit, tilingBitGl } from './tilingBit.mjs';\n\n\"use strict\";\nlet gpuProgram;\nlet glProgram;\nclass TilingSpriteShader extends Shader {\n  constructor() {\n    gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBit,\n        tilingBit,\n        roundPixelsBit\n      ]\n    }));\n    glProgram ?? (glProgram = compileHighShaderGlProgram({\n      name: \"tiling-sprite-shader\",\n      bits: [\n        localUniformBitGl,\n        tilingBitGl,\n        roundPixelsBitGl\n      ]\n    }));\n    const tilingUniforms = new UniformGroup({\n      uMapCoord: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: \"vec4<f32>\" },\n      uClampOffset: { value: new Float32Array([0, 0]), type: \"vec2<f32>\" },\n      uTextureTransform: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: \"vec4<f32>\" }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        localUniforms: new UniformGroup({\n          uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n          uRound: { value: 0, type: \"f32\" }\n        }),\n        tilingUniforms,\n        uTexture: Texture.EMPTY.source,\n        uSampler: Texture.EMPTY.source.style\n      }\n    });\n  }\n  updateUniforms(width, height, matrix, anchorX, anchorY, texture) {\n    const tilingUniforms = this.resources.tilingUniforms;\n    const textureWidth = texture.width;\n    const textureHeight = texture.height;\n    const textureMatrix = texture.textureMatrix;\n    const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n    uTextureTransform.set(\n      matrix.a * textureWidth / width,\n      matrix.b * textureWidth / height,\n      matrix.c * textureHeight / width,\n      matrix.d * textureHeight / height,\n      matrix.tx / width,\n      matrix.ty / height\n    );\n    uTextureTransform.invert();\n    tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n    tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n    tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n    tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n    tilingUniforms.uniforms.uSizeAnchor[0] = width;\n    tilingUniforms.uniforms.uSizeAnchor[1] = height;\n    tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n    tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n    if (texture) {\n      this.resources.uTexture = texture.source;\n      this.resources.uSampler = texture.source.style;\n    }\n  }\n}\n\nexport { TilingSpriteShader };\n//# sourceMappingURL=TilingSpriteShader.mjs.map\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry.mjs';\n\n\"use strict\";\nclass QuadGeometry extends MeshGeometry {\n  constructor() {\n    super({\n      positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      indices: new Uint32Array([0, 1, 2, 0, 2, 3])\n    });\n  }\n}\n\nexport { QuadGeometry };\n//# sourceMappingURL=QuadGeometry.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { State } from '../../rendering/renderers/shared/state/State.mjs';\nimport { RendererType } from '../../rendering/renderers/types.mjs';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash.mjs';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh.mjs';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry.mjs';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader.mjs';\nimport { QuadGeometry } from './utils/QuadGeometry.mjs';\nimport { setPositions } from './utils/setPositions.mjs';\nimport { setUvs } from './utils/setUvs.mjs';\n\n\"use strict\";\nconst sharedQuad = new QuadGeometry();\nclass TilingSpriteGpuData {\n  constructor() {\n    this.canBatch = true;\n    this.geometry = new MeshGeometry({\n      indices: sharedQuad.indices.slice(),\n      positions: sharedQuad.positions.slice(),\n      uvs: sharedQuad.uvs.slice()\n    });\n  }\n  destroy() {\n    this.geometry.destroy();\n    this.shader?.destroy();\n  }\n}\nclass TilingSpritePipe {\n  constructor(renderer) {\n    this._state = State.default2d;\n    this._renderer = renderer;\n    this._managedTilingSprites = new GCManagedHash({ renderer, type: \"renderable\", name: \"tilingSprite\" });\n  }\n  validateRenderable(renderable) {\n    const tilingSpriteData = this._getTilingSpriteData(renderable);\n    const couldBatch = tilingSpriteData.canBatch;\n    this._updateCanBatch(renderable);\n    const canBatch = tilingSpriteData.canBatch;\n    if (canBatch && canBatch === couldBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      return !batchableMesh._batcher.checkAndUpdateTexture(\n        batchableMesh,\n        renderable.texture\n      );\n    }\n    return couldBatch !== canBatch;\n  }\n  addRenderable(tilingSprite, instructionSet) {\n    const batcher = this._renderer.renderPipes.batch;\n    this._updateCanBatch(tilingSprite);\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { geometry, canBatch } = tilingSpriteData;\n    if (canBatch) {\n      tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());\n      const batchableMesh = tilingSpriteData.batchableMesh;\n      if (tilingSprite.didViewUpdate) {\n        this._updateBatchableMesh(tilingSprite);\n        batchableMesh.geometry = geometry;\n        batchableMesh.renderable = tilingSprite;\n        batchableMesh.transform = tilingSprite.groupTransform;\n        batchableMesh.setTexture(tilingSprite._texture);\n      }\n      batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;\n      batcher.addToBatch(batchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());\n      this.updateRenderable(tilingSprite);\n      instructionSet.add(tilingSprite);\n    }\n  }\n  execute(tilingSprite) {\n    const { shader } = this._getTilingSpriteData(tilingSprite);\n    shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n    localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n    color32BitToUniform(\n      tilingSprite.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n    this._renderer.encoder.draw({\n      geometry: sharedQuad,\n      shader,\n      state: this._state\n    });\n  }\n  updateRenderable(tilingSprite) {\n    const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n    const { canBatch } = tilingSpriteData;\n    if (canBatch) {\n      const { batchableMesh } = tilingSpriteData;\n      if (tilingSprite.didViewUpdate)\n        this._updateBatchableMesh(tilingSprite);\n      batchableMesh._batcher.updateElement(batchableMesh);\n    } else if (tilingSprite.didViewUpdate) {\n      const { shader } = tilingSpriteData;\n      shader.updateUniforms(\n        tilingSprite.width,\n        tilingSprite.height,\n        tilingSprite._tileTransform.matrix,\n        tilingSprite.anchor.x,\n        tilingSprite.anchor.y,\n        tilingSprite.texture\n      );\n    }\n  }\n  _getTilingSpriteData(renderable) {\n    return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n  }\n  _initTilingSpriteData(tilingSprite) {\n    const gpuData = new TilingSpriteGpuData();\n    gpuData.renderable = tilingSprite;\n    tilingSprite._gpuData[this._renderer.uid] = gpuData;\n    this._managedTilingSprites.add(tilingSprite);\n    return gpuData;\n  }\n  _updateBatchableMesh(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const { geometry } = renderableData;\n    const style = tilingSprite.texture.source.style;\n    if (style.addressMode !== \"repeat\") {\n      style.addressMode = \"repeat\";\n      style.update();\n    }\n    setUvs(tilingSprite, geometry.uvs);\n    setPositions(tilingSprite, geometry.positions);\n  }\n  destroy() {\n    this._managedTilingSprites.destroy();\n    this._renderer = null;\n  }\n  _updateCanBatch(tilingSprite) {\n    const renderableData = this._getTilingSpriteData(tilingSprite);\n    const texture = tilingSprite.texture;\n    let _nonPowOf2wrapping = true;\n    if (this._renderer.type === RendererType.WEBGL) {\n      _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;\n    }\n    renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n    return renderableData.canBatch;\n  }\n}\n/** @ignore */\nTilingSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"tilingSprite\"\n};\n\nexport { TilingSpriteGpuData, TilingSpritePipe };\n//# sourceMappingURL=TilingSpritePipe.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { applyMatrix } from './applyMatrix.mjs';\n\n\"use strict\";\nfunction setUvs(tilingSprite, uvs) {\n  const texture = tilingSprite.texture;\n  const width = texture.frame.width;\n  const height = texture.frame.height;\n  let anchorX = 0;\n  let anchorY = 0;\n  if (tilingSprite.applyAnchorToTexture) {\n    anchorX = tilingSprite.anchor.x;\n    anchorY = tilingSprite.anchor.y;\n  }\n  uvs[0] = uvs[6] = -anchorX;\n  uvs[2] = uvs[4] = 1 - anchorX;\n  uvs[1] = uvs[3] = -anchorY;\n  uvs[5] = uvs[7] = 1 - anchorY;\n  const textureMatrix = Matrix.shared;\n  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n  textureMatrix.tx /= tilingSprite.width;\n  textureMatrix.ty /= tilingSprite.height;\n  textureMatrix.invert();\n  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n  applyMatrix(uvs, 2, 0, textureMatrix);\n}\n\nexport { setUvs };\n//# sourceMappingURL=setUvs.mjs.map\n","\"use strict\";\nfunction applyMatrix(array, stride, offset, matrix) {\n  let index = 0;\n  const size = array.length / (stride || 2);\n  const a = matrix.a;\n  const b = matrix.b;\n  const c = matrix.c;\n  const d = matrix.d;\n  const tx = matrix.tx;\n  const ty = matrix.ty;\n  offset *= stride;\n  while (index < size) {\n    const x = array[offset];\n    const y = array[offset + 1];\n    array[offset] = a * x + c * y + tx;\n    array[offset + 1] = b * x + d * y + ty;\n    offset += stride;\n    index++;\n  }\n}\n\nexport { applyMatrix };\n//# sourceMappingURL=applyMatrix.mjs.map\n","\"use strict\";\nfunction setPositions(tilingSprite, positions) {\n  const anchorX = tilingSprite.anchor.x;\n  const anchorY = tilingSprite.anchor.y;\n  positions[0] = -anchorX * tilingSprite.width;\n  positions[1] = -anchorY * tilingSprite.height;\n  positions[2] = (1 - anchorX) * tilingSprite.width;\n  positions[3] = -anchorY * tilingSprite.height;\n  positions[4] = (1 - anchorX) * tilingSprite.width;\n  positions[5] = (1 - anchorY) * tilingSprite.height;\n  positions[6] = -anchorX * tilingSprite.width;\n  positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n\nexport { setPositions };\n//# sourceMappingURL=setPositions.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { TilingSpritePipe } from './TilingSpritePipe.mjs';\n\n\"use strict\";\nextensions.add(TilingSpritePipe);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nclass BatchableMesh {\n  constructor() {\n    this.batcherName = \"default\";\n    this.packAsQuad = false;\n    this.indexOffset = 0;\n    this.attributeOffset = 0;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n    this._textureMatrixUpdateId = -1;\n    this._uvUpdateId = -1;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get topology() {\n    return this._topology || this.geometry.topology;\n  }\n  set topology(value) {\n    this._topology = value;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.geometry = null;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  /**\n   * Sets the texture for the batchable mesh.\n   * As it does so, it resets the texture matrix update ID.\n   * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n   * @param value - The texture to set.\n   */\n  setTexture(value) {\n    if (this.texture === value)\n      return;\n    this.texture = value;\n    this._textureMatrixUpdateId = -1;\n  }\n  get uvs() {\n    const geometry = this.geometry;\n    const uvBuffer = geometry.getBuffer(\"aUV\");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    return transformedUvs;\n  }\n  get positions() {\n    return this.geometry.positions;\n  }\n  get indices() {\n    return this.geometry.indices;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  get groupTransform() {\n    return this.renderable.groupTransform;\n  }\n  get attributeSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\n\nexport { BatchableMesh };\n//# sourceMappingURL=BatchableMesh.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../gpu/colorToUniform.mjs';\nimport { BatchableGraphics } from './BatchableGraphics.mjs';\n\n\"use strict\";\nclass GraphicsGpuData {\n  constructor() {\n    this.batches = [];\n    this.batched = false;\n  }\n  destroy() {\n    this.batches.forEach((batch) => {\n      BigPool.return(batch);\n    });\n    this.batches.length = 0;\n  }\n}\nclass GraphicsPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this.renderer.runners.contextChange.add(this);\n    this._managedGraphics = new GCManagedHash({ renderer, type: \"renderable\", priority: -1, name: \"graphics\" });\n  }\n  contextChange() {\n    this._adaptor.contextChange(this.renderer);\n  }\n  validateRenderable(graphics) {\n    const context = graphics.context;\n    const wasBatched = !!graphics._gpuData;\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(graphics, instructionSet) {\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    if (graphics.didViewUpdate) {\n      this._rebuild(graphics);\n    }\n    if (gpuContext.isBatchable) {\n      this._addToBatcher(graphics, instructionSet);\n    } else {\n      this.renderer.renderPipes.batch.break(instructionSet);\n      instructionSet.add(graphics);\n    }\n  }\n  updateRenderable(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const batches = gpuData.batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batch._batcher.updateElement(batch);\n    }\n  }\n  execute(graphics) {\n    if (!graphics.isRenderable)\n      return;\n    const renderer = this.renderer;\n    const context = graphics.context;\n    const contextSystem = renderer.graphicsContext;\n    if (!contextSystem.getGpuContext(context).batches.length) {\n      return;\n    }\n    const shader = context.customShader || this._adaptor.shader;\n    this.state.blendMode = graphics.groupBlendMode;\n    const localUniforms = shader.resources.localUniforms.uniforms;\n    localUniforms.uTransformMatrix = graphics.groupTransform;\n    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n    color32BitToUniform(\n      graphics.groupColorAlpha,\n      localUniforms.uColor,\n      0\n    );\n    this._adaptor.execute(this, graphics);\n  }\n  _rebuild(graphics) {\n    const gpuData = this._getGpuDataForRenderable(graphics);\n    const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n    gpuData.destroy();\n    if (gpuContext.isBatchable) {\n      this._updateBatchesForRenderable(graphics, gpuData);\n    }\n  }\n  _addToBatcher(graphics, instructionSet) {\n    const batchPipe = this.renderer.renderPipes.batch;\n    const batches = this._getGpuDataForRenderable(graphics).batches;\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batchPipe.addToBatch(batch, instructionSet);\n    }\n  }\n  _getGpuDataForRenderable(graphics) {\n    return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n  }\n  _initGpuDataForRenderable(graphics) {\n    const gpuData = new GraphicsGpuData();\n    graphics._gpuData[this.renderer.uid] = gpuData;\n    this._managedGraphics.add(graphics);\n    return gpuData;\n  }\n  _updateBatchesForRenderable(graphics, gpuData) {\n    const context = graphics.context;\n    const gpuContext = this.renderer.graphicsContext.getGpuContext(context);\n    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;\n    gpuData.batches = gpuContext.batches.map((batch) => {\n      const batchClone = BigPool.get(BatchableGraphics);\n      batch.copyTo(batchClone);\n      batchClone.renderable = graphics;\n      batchClone.roundPixels = roundPixels;\n      return batchClone;\n    });\n  }\n  destroy() {\n    this._managedGraphics.destroy();\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.state = null;\n  }\n}\n/** @ignore */\nGraphicsPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"graphics\"\n};\n\nexport { GraphicsGpuData, GraphicsPipe };\n//# sourceMappingURL=GraphicsPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem.mjs';\nimport { GraphicsPipe } from './shared/GraphicsPipe.mjs';\n\n\"use strict\";\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n//# sourceMappingURL=init.mjs.map\n","\"use strict\";\nclass GlParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const state = particleContainerPipe.state;\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.resources.uTexture = container.texture._source;\n    shader.resources.uniforms = particleContainerPipe.localUniforms;\n    const gl = renderer.gl;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.shader.bind(shader);\n    renderer.state.set(state);\n    renderer.geometry.bind(buffer.geometry, shader.glProgram);\n    const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n    const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n    gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n  }\n}\n\nexport { GlParticleContainerAdaptor };\n//# sourceMappingURL=GlParticleContainerAdaptor.mjs.map\n","\"use strict\";\nfunction createIndicesForQuads(size, outBuffer = null) {\n  const totalIndices = size * 6;\n  if (totalIndices > 65535) {\n    outBuffer || (outBuffer = new Uint32Array(totalIndices));\n  } else {\n    outBuffer || (outBuffer = new Uint16Array(totalIndices));\n  }\n  if (outBuffer.length !== totalIndices) {\n    throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n  }\n  for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4) {\n    outBuffer[i + 0] = j + 0;\n    outBuffer[i + 1] = j + 1;\n    outBuffer[i + 2] = j + 2;\n    outBuffer[i + 3] = j + 0;\n    outBuffer[i + 4] = j + 2;\n    outBuffer[i + 5] = j + 3;\n  }\n  return outBuffer;\n}\n\nexport { createIndicesForQuads };\n//# sourceMappingURL=createIndicesForQuads.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction generateParticleUpdateFunction(properties) {\n  return {\n    dynamicUpdate: generateUpdateFunction(properties, true),\n    staticUpdate: generateUpdateFunction(properties, false)\n  };\n}\nfunction generateUpdateFunction(properties, dynamic) {\n  const funcFragments = [];\n  funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n  let offset = 0;\n  for (const i in properties) {\n    const property = properties[i];\n    if (dynamic !== property.dynamic)\n      continue;\n    funcFragments.push(`offset = index + ${offset}`);\n    funcFragments.push(property.code);\n    const attributeInfo = getAttributeInfoFromFormat(property.format);\n    offset += attributeInfo.stride / 4;\n  }\n  funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n  funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n  const functionSource = funcFragments.join(\"\\n\");\n  return new Function(\"ps\", \"f32v\", \"u32v\", functionSource);\n}\n\nexport { generateParticleUpdateFunction };\n//# sourceMappingURL=generateParticleUpdateFunction.mjs.map\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads.mjs';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction.mjs';\n\n\"use strict\";\nclass ParticleBuffer {\n  constructor(options) {\n    this._size = 0;\n    this._generateParticleUpdateCache = {};\n    const size = this._size = options.size ?? 1e3;\n    const properties = options.properties;\n    let staticVertexSize = 0;\n    let dynamicVertexSize = 0;\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        dynamicVertexSize += attributeInfo.stride;\n      } else {\n        staticVertexSize += attributeInfo.stride;\n      }\n    }\n    this._dynamicStride = dynamicVertexSize / 4;\n    this._staticStride = staticVertexSize / 4;\n    this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n    this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n    this.indexBuffer = createIndicesForQuads(size);\n    const geometry = new Geometry();\n    let dynamicOffset = 0;\n    let staticOffset = 0;\n    this._staticBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"static-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    this._dynamicBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"dynamic-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._dynamicBuffer,\n          stride: this._dynamicStride * 4,\n          offset: dynamicOffset * 4,\n          format: property.format\n        });\n        dynamicOffset += attributeInfo.size;\n      } else {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._staticBuffer,\n          stride: this._staticStride * 4,\n          offset: staticOffset * 4,\n          format: property.format\n        });\n        staticOffset += attributeInfo.size;\n      }\n    }\n    geometry.addIndex(this.indexBuffer);\n    const uploadFunction = this.getParticleUpdate(properties);\n    this._dynamicUpload = uploadFunction.dynamicUpdate;\n    this._staticUpload = uploadFunction.staticUpdate;\n    this.geometry = geometry;\n  }\n  getParticleUpdate(properties) {\n    const key = getParticleSyncKey(properties);\n    if (this._generateParticleUpdateCache[key]) {\n      return this._generateParticleUpdateCache[key];\n    }\n    this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n    return this._generateParticleUpdateCache[key];\n  }\n  generateParticleUpdate(properties) {\n    return generateParticleUpdateFunction(properties);\n  }\n  update(particles, uploadStatic) {\n    if (particles.length > this._size) {\n      uploadStatic = true;\n      this._size = Math.max(particles.length, this._size * 1.5 | 0);\n      this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n      this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n      this.indexBuffer = createIndicesForQuads(this._size);\n      this.geometry.indexBuffer.setDataWithSize(\n        this.indexBuffer,\n        this.indexBuffer.byteLength,\n        true\n      );\n    }\n    const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n    this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n    this._dynamicBuffer.setDataWithSize(\n      this.dynamicAttributeBuffer.float32View,\n      particles.length * this._dynamicStride * 4,\n      true\n    );\n    if (uploadStatic) {\n      const staticAttributeBuffer = this.staticAttributeBuffer;\n      this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n      this._staticBuffer.setDataWithSize(\n        staticAttributeBuffer.float32View,\n        particles.length * this._staticStride * 4,\n        true\n      );\n    }\n  }\n  destroy() {\n    this._staticBuffer.destroy();\n    this._dynamicBuffer.destroy();\n    this.geometry.destroy();\n  }\n}\nfunction getParticleSyncKey(properties) {\n  const keyGen = [];\n  for (const key in properties) {\n    const property = properties[key];\n    keyGen.push(key, property.code, property.dynamic ? \"d\" : \"s\");\n  }\n  return keyGen.join(\"_\");\n}\n\nexport { ParticleBuffer };\n//# sourceMappingURL=ParticleBuffer.mjs.map\n","var wgsl = \"\\nstruct ParticleUniforms {\\n  uTranslationMatrix:mat3x3<f32>,\\n  uColor:vec4<f32>,\\n  uRound:f32,\\n  uResolution:vec2<f32>,\\n};\\n\\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\\n{\\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\\n\\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\\n@group(1) @binding(1) var uSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) color : vec4<f32>,\\n  };\\n@vertex\\nfn mainVertex(\\n  @location(0) aVertex: vec2<f32>,\\n  @location(1) aPosition: vec2<f32>,\\n  @location(2) aUV: vec2<f32>,\\n  @location(3) aColor: vec4<f32>,\\n  @location(4) aRotation: f32,\\n) -> VSOutput {\\n  \\n   let v = vec2(\\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\\n   ) + aPosition;\\n\\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n   if(uniforms.uRound == 1.0) {\\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\\n   }\\n\\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\\n\\n  return VSOutput(\\n   position,\\n   aUV,\\n   vColor,\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) color: vec4<f32>,\\n  @builtin(position) position: vec4<f32>,\\n) -> @location(0) vec4<f32> {\\n\\n    var sample = textureSample(uTexture, uSampler, uv) * color;\\n   \\n    return sample;\\n}\";\n\nexport { wgsl as default };\n//# sourceMappingURL=particles.wgsl.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport fragment from './particles.frag.mjs';\nimport vertex from './particles.vert.mjs';\nimport wgsl from './particles.wgsl.mjs';\n\n\"use strict\";\nclass ParticleShader extends Shader {\n  constructor() {\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment\n    });\n    const gpuProgram = GpuProgram.from({\n      fragment: {\n        source: wgsl,\n        entryPoint: \"mainFragment\"\n      },\n      vertex: {\n        source: wgsl,\n        entryPoint: \"mainVertex\"\n      }\n    });\n    super({\n      glProgram,\n      gpuProgram,\n      resources: {\n        // this will be replaced with the texture from the particle container\n        uTexture: Texture.WHITE.source,\n        // this will be replaced with the texture style from the particle container\n        uSampler: new TextureStyle({}),\n        // this will be replaced with the local uniforms from the particle container\n        uniforms: {\n          uTranslationMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n          uColor: { value: new Color(16777215), type: \"vec4<f32>\" },\n          uRound: { value: 1, type: \"f32\" },\n          uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n        }\n      }\n    });\n  }\n}\n\nexport { ParticleShader };\n//# sourceMappingURL=ParticleShader.mjs.map\n","var vertex = \"attribute vec2 aVertex;\\nattribute vec2 aUV;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPosition;\\nattribute float aRotation;\\n\\nuniform mat3 uTranslationMatrix;\\nuniform float uRound;\\nuniform vec2 uResolution;\\nuniform vec4 uColor;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n\\nvec2 roundPixels(vec2 position, vec2 targetSize)\\n{       \\n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\nvoid main(void){\\n    float cosRotation = cos(aRotation);\\n    float sinRotation = sin(aRotation);\\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPosition;\\n\\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    if(uRound == 1.0)\\n    {\\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\\n    }\\n\\n    vUV = aUV;\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=particles.vert.mjs.map\n","var fragment = \"varying vec2 vUV;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uTexture, vUV) * vColor;\\n    gl_FragColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=particles.frag.mjs.map\n","import { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { ParticleBuffer } from './ParticleBuffer.mjs';\nimport { ParticleShader } from './shader/ParticleShader.mjs';\n\n\"use strict\";\nclass ParticleContainerPipe {\n  /**\n   * @param renderer - The renderer this sprite batch works for.\n   * @param adaptor\n   */\n  constructor(renderer, adaptor) {\n    /** @internal */\n    this.state = State.for2d();\n    /** Local uniforms that are used for rendering particles. */\n    this.localUniforms = new UniformGroup({\n      uTranslationMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uRound: { value: 1, type: \"f32\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    });\n    this.renderer = renderer;\n    this.adaptor = adaptor;\n    this.defaultShader = new ParticleShader();\n    this.state = State.for2d();\n    this._managedContainers = new GCManagedHash({ renderer, type: \"renderable\", name: \"particleContainer\" });\n  }\n  validateRenderable(_renderable) {\n    return false;\n  }\n  addRenderable(renderable, instructionSet) {\n    this.renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(renderable);\n  }\n  getBuffers(renderable) {\n    return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n  }\n  _initBuffer(renderable) {\n    renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n      size: renderable.particleChildren.length,\n      properties: renderable._properties\n    });\n    this._managedContainers.add(renderable);\n    return renderable._gpuData[this.renderer.uid];\n  }\n  updateRenderable(_renderable) {\n  }\n  execute(container) {\n    const children = container.particleChildren;\n    if (children.length === 0) {\n      return;\n    }\n    const renderer = this.renderer;\n    const buffer = this.getBuffers(container);\n    container.texture || (container.texture = children[0].texture);\n    const state = this.state;\n    buffer.update(children, container._childrenDirty);\n    container._childrenDirty = false;\n    state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n    const uniforms = this.localUniforms.uniforms;\n    const transformationMatrix = uniforms.uTranslationMatrix;\n    container.worldTransform.copyTo(transformationMatrix);\n    transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n    uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n    uniforms.uRound = renderer._roundPixels | container._roundPixels;\n    color32BitToUniform(\n      container.groupColorAlpha,\n      uniforms.uColor,\n      0\n    );\n    this.adaptor.execute(this, container);\n  }\n  /** Destroys the ParticleRenderer. */\n  destroy() {\n    this._managedContainers.destroy();\n    this.renderer = null;\n    if (this.defaultShader) {\n      this.defaultShader.destroy();\n      this.defaultShader = null;\n    }\n  }\n}\n\nexport { ParticleContainerPipe };\n//# sourceMappingURL=ParticleContainerPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor.mjs';\nimport { ParticleContainerPipe } from './ParticleContainerPipe.mjs';\n\n\"use strict\";\nclass GlParticleContainerPipe extends ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GlParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGlParticleContainerPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes\n  ],\n  name: \"particle\"\n};\n\nexport { GlParticleContainerPipe };\n//# sourceMappingURL=GlParticleContainerPipe.mjs.map\n","\"use strict\";\nclass GpuParticleContainerAdaptor {\n  execute(particleContainerPipe, container) {\n    const renderer = particleContainerPipe.renderer;\n    const shader = container.shader || particleContainerPipe.defaultShader;\n    shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n    shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n    const state = particleContainerPipe.state;\n    const buffer = particleContainerPipe.getBuffers(container);\n    renderer.encoder.draw({\n      geometry: buffer.geometry,\n      shader: container.shader || particleContainerPipe.defaultShader,\n      state,\n      size: container.particleChildren.length * 6\n    });\n  }\n}\n\nexport { GpuParticleContainerAdaptor };\n//# sourceMappingURL=GpuParticleContainerAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor.mjs';\nimport { ParticleContainerPipe } from './ParticleContainerPipe.mjs';\n\n\"use strict\";\nclass GpuParticleContainerPipe extends ParticleContainerPipe {\n  constructor(renderer) {\n    super(renderer, new GpuParticleContainerAdaptor());\n  }\n}\n/** @ignore */\nGpuParticleContainerPipe.extension = {\n  type: [\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"particle\"\n};\n\nexport { GpuParticleContainerPipe };\n//# sourceMappingURL=GpuParticleContainerPipe.mjs.map\n","import { extensions } from '../../extensions/Extensions.mjs';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe.mjs';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe.mjs';\n\n\"use strict\";\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n//# sourceMappingURL=init.mjs.map\n"],"names":["localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","BatchableText","BatchableSprite","CanvasTextPipe","constructor","renderer","this","_renderer","runners","resolutionChange","add","_managedTexts","GCManagedHash","type","onUnload","onTextUnload","bind","key","items","text","_autoResolution","onViewUpdate","validateRenderable","gpuText","_getGpuText","newKey","styleKey","currentKey","_didTextUpdate","addRenderable","instructionSet","batchableText","resolution","_updateGpuText","updateTextBounds","renderPipes","batch","addToBatch","updateRenderable","_batcher","updateElement","texture","canvasText","decreaseReferenceCount","_resolution","getManagedTexture","_gpuData","uid","initGpuText","renderable","transform","groupTransform","bounds","minX","maxX","minY","maxY","roundPixels","_roundPixels","gpuData","getReferenceCount","returnTexture","destroy","extension","WebGLPipes","WebGPUPipes","CanvasPipes","CanvasTextSystem","_activeTextures","getTexture","options","_style","_textKey","deprecation","style","TextStyle","textureStyle","TextureStyle","toString","frame","canvasAndContext","CanvasTextGenerator","getCanvasAndContext","getPo2TextureFromSource","canvas","width","height","source","trim","pad","padding","copyFrom","scale","updateUvs","filters","filteredTexture","_applyFilters","returnCanvasAndContext","initSource","_source","resource","uploadMethodId","alphaMode","TexturePool","renderTextToCanvas","textKey","_increaseReferenceCount","usageCount","activeTexture","currentRenderTarget","renderTarget","resultTexture","filter","generateFilteredTexture","WebGLSystem","WebGPUSystem","CanvasSystem","batchableSprite","_getFinalPadding","_anchor","paddingOffset","_x","paddingOffsetY","_y","tempBounds","image","getOptimalTexture","emit","BatchableHTMLText","super","arguments","generatingTexture","texturePromise","HTMLTextPipe","htmlText","batchableHTMLText","catch","e","console","error","oldTexturePromise","getTexturePromise","finally","returnTexturePromise","renderGroup","parentRenderGroup","structureDidChange","Texture","EMPTY","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","setAttribute","overflow","appendChild","get","createImage","remove","src","FontStylePromiseCache","Map","tempHTMLTextRenderData","HTMLTextSystem","_createCanvas","WEBGPU","promise","_buildTexturePromise","then","_cleanUp","warn","htmlTextData","fontFamilies","fontFamily","dedupe","matches","match","addFontFamily","fontFamily2","push","Array","isArray","i","length","forEach","split","tagStyles","extractFontFamilies","fontCSS","async","fontPromises","Cache","has","map","entries","promises","entry","url","out","faces","face","weight","dataSrc","response","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","result","onerror","readAsDataURL","loadFontAsBase64","fontWeight","fontStyle","loadFontCSS","set","all","css","join","getFontCss","measured","fontStyleCSS","htmlTextRenderData","innerHTML","cssStyle","textContent","body","contentBounds","getBoundingClientRect","doublePadding","measureHtmlText","Math","ceil","max","svgURL","XMLSerializer","serializeToString","getSVGUrl","delay","resolve2","setTimeout","onload","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","test","isSafari","CanvasPool","getOptimalCanvasAndContext","context","clearRect","drawImage","getTemporaryCanvasFromImage","return","color32BitToUniform","abgr","offset","alpha","FilterPipe","filterEffect","container","break","renderPipeId","canBundle","action","pop","_filterEffect","_container","execute","instruction","PassthroughFilter","Filter","gpuProgram","GpuProgram","from","fragment","glProgram","GlProgram","tempProjectionMatrix","Matrix","quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","format","stride","indexBuffer","Uint32Array","FilterData","skip","inputTexture","backTexture","Bounds","blendRequired","outputRenderSurface","globalFrame","x","y","firstEnabledIndex","lastEnabledIndex","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_activeFilterData","filterData","_pushFilterData","renderSurface","colorTextureSource","colorTexture","rootResolution","rootAntialias","antialias","every","enabled","_calculateFilterArea","_calculateFilterBounds","rootViewPort","previousFilterData","_getPreviousFilterData","globalResolution","_findFilterResolution","offsetX","offsetY","_calculateGlobalFrame","_setupFilterTextures","addRect","rectangle","finishRenderPass","_applyFiltersToTexture","outputTexture","_popFilterData","globalUniforms","getBackTexture","lastRenderSurface","previousBounds","backgroundResolution","floor","copyToTexture","applyFilter","input","output","clear","isFinalTarget","rootRenderTarget","_findPreviousFilterOffset","_updateFilterUniforms","filterToApply","_getPassthroughFilter","_setupBindGroupsAndRender","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","worldTransform","copyTo","shared","cacheToLocalTransform","prepend","invert","orig","translate","anchor","_passthroughFilter","uniformBatch","batchUniforms","getUboResource","setResource","groups","encoder","draw","geometry","shader","state","_state","topology","WEBGL","getRenderTarget","sourceWidth","sourceHeight","uniforms","outputFrame","inputSize","inputPixel","inputClamp","pixelWidth","pixelHeight","rootTexture","isRoot","update","currentIndex","lastIndex","prevFilterData","renderables","actualMatrix","matrix","globalDisplayStatus","isCachedAsTexture","textureOffsetInverseTransform","append","_parentCacheAsTextureRenderGroup","inverseWorldTransform","addBounds","getGlobalRenderableBounds","filterArea","applyMatrix","getFastGlobalBounds","filterFrameTransform","firstEnabled","lastEnabled","apply","flip","tempTexture","flop","t","viewPort","paddingMultiplier","Infinity","clipToViewport","min","compatibleRenderers","backBuffer","useBackBuffer","fitBounds","isPositive","index","Graphics","ViewContainer","GraphicsContext","rest","label","_ownedContext","autoGarbageCollect","didViewUpdate","allowChildren","_context","off","unload","on","updateBounds","containsPoint","point","_onTouch","now","_gcLastUsed","_callContextMethod","method","args","setFillStyle","setStrokeStyle","fill","stroke","beginPath","cut","arc","arcTo","arcToSvg","bezierCurveTo","closePath","ellipse","circle","path","lineTo","moveTo","quadraticCurveTo","rect","roundRect","poly","regularPoly","roundPoly","roundShape","filletRect","chamferRect","star","svg","restore","save","getTransform","resetTransform","rotateTransform","scaleTransform","setTransform","translateTransform","fillStyle","strokeStyle","clone","deep","lineStyle","color","beginFill","endFill","defaultStrokeStyle","drawCircle","drawEllipse","drawPolygon","drawRect","drawRoundedRect","drawStar","localUniformMSDFBit","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","Shader","maxTextures","uColor","uTransformMatrix","uDistance","uRound","bits","colorBit","generateTextureBatchBit","roundPixelsBit","resources","localUniforms","batchSamplers","getBatchSamplersUniformGroup","BitmapTextGraphics","customShader","BitmapTextPipe","_managedBitmapTexts","priority","bitmapText","graphicsRenderable","_getGpuBitmapText","graphics","syncWithProxy","_updateContext","_updateDistanceField","proxyGraphics","bitmapFont","BitmapFontManager","getFont","distanceField","limits","maxBatchableTextures","chars","CanvasTextMetrics","graphemeSegmenter","currentY","baseLineOffset","bitmapTextLayout","getBitmapTextLayout","tx","ty","_stroke","tint","applyFillAsTint","_fill","fontSize","fontMetrics","lineHeight","linePositionYShift","lines","line","j","charPositions","char","charData","round","xOffset","yOffset","proxyRenderable","dynamicFont","a","b","c","d","dx","sqrt","dy","worldScale","abs","fontScale","baseRenderedFontSize","distance","range","proxy","groupColorAlpha","groupColor","groupBlendMode","localDisplayStatus","groupAlpha","ResizePlugin","init","Object","defineProperty","configurable","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","window","innerWidth","innerHeight","clientWidth","clientHeight","render","resizeTo","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","LOW","stop","start","Ticker","oldTicker","_MeshGeometry","positions","uvs","indices","defaultOptions","shrinkToFit","shrinkBuffersToFit","usage","VERTEX","COPY_DST","aUV","INDEX","batchMode","MeshGeometry","MeshGpuData","MeshPipe","adaptor","localUniformsBindGroup","_adaptor","mesh","meshData","_getMeshData","wasBatched","batched","isBatched","_geometry","indexSize","vertexSize","batchableMesh","_getBatchableMesh","_texture","_textureMatrixUpdateId","checkAndUpdateTexture","batcher","gpuBatchableMesh","setTexture","isRenderable","blendMode","getAdjustedBlendModeBlend","_a","_b","_initMeshData","_initBatchableMesh","gpuMesh","BatchableMesh","_Filter","for2d","addResource","filterManager","clearMode","gpu","gl","_PlaneGeometry","verticesX","verticesY","build","total","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","PlaneGeometry","_NineSliceGeometry","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","_anchorX","_anchorY","updatePositions","p","w","scaleW","h","scaleH","anchorOffsetX","anchorOffsetY","getBuffer","_uvw","_uvh","NineSliceGeometry","NineSliceSpriteGpuData","NineSliceSpritePipe","_managedSprites","gpuSprite","_getGpuSprite","_updateBatchableSprite","_initGPUSprite","blendModeIds","normal","multiply","screen","overlay","erase","_State","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","default2d","State","batcherName","attributeSize","packAsQuad","_attributeStart","_batch","reset","tilingBit","tilingBitGl","TilingSpriteShader","tilingUniforms","uMapCoord","uClampFrame","uClampOffset","uTextureTransform","uSizeAnchor","uTexture","uSampler","updateUniforms","anchorX","anchorY","textureWidth","textureHeight","textureMatrix","mapCoord","QuadGeometry","sharedQuad","TilingSpriteGpuData","canBatch","slice","TilingSpritePipe","_managedTilingSprites","tilingSpriteData","_getTilingSpriteData","couldBatch","_updateCanBatch","tilingSprite","_updateBatchableMesh","bindGroup","_tileTransform","_initTilingSpriteData","renderableData","addressMode","applyAnchorToTexture","array","size","setUvs","setPositions","_nonPowOf2wrapping","supports","nonPowOf2wrapping","isSimple","isPowerOfTwo","indexOffset","attributeOffset","_uvUpdateId","_topology","uvBuffer","transformedUvs","_transformedUvs","_updateID","multiplyUvs","GraphicsGpuData","batches","GraphicsPipe","contextChange","_managedGraphics","gpuContext","graphicsContext","updateGpuContext","isBatchable","_rebuild","_addToBatcher","_getGpuDataForRenderable","getGpuContext","_updateBatchesForRenderable","batchPipe","_initGpuDataForRenderable","batchClone","BatchableGraphics","GraphicsContextSystem","GlParticleContainerAdaptor","particleContainerPipe","defaultShader","getBuffers","glType","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","createIndicesForQuads","outBuffer","totalIndices","Uint16Array","Error","generateUpdateFunction","properties","dynamic","funcFragments","property","code","getAttributeInfoFromFormat","unshift","functionSource","Function","ParticleBuffer","_size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","attributeInfo","_dynamicStride","_staticStride","staticAttributeBuffer","ViewableBuffer","dynamicAttributeBuffer","dynamicOffset","staticOffset","_staticBuffer","Buffer","_dynamicBuffer","addAttribute","attributeName","addIndex","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","keyGen","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","setDataWithSize","byteLength","float32View","uint32View","wgsl","ParticleShader","entryPoint","WHITE","uTranslationMatrix","Color","uResolution","ParticleContainerPipe","_managedContainers","_renderable","_initBuffer","_properties","children","_childrenDirty","transformationMatrix","globalUniformData","projectionMatrix","GlParticleContainerPipe","GpuParticleContainerAdaptor","getUniformBindGroup","getTextureBindGroup","GpuParticleContainerPipe"],"ignoreList":[],"sourceRoot":""}