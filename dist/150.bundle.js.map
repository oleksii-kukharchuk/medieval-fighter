{"version":3,"file":"150.bundle.js","mappings":"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","sources":["webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/container/utils/clearList.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/mask/mask.vert.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/mask/mask.frag.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/GCSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/utils/sayHello.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/utils/data/clean.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/filters/Filter.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","webpack://medieval-fighter/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"],"sourcesContent":["import { uid } from '../../../../utils/data/uid.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst _RenderTarget = class _RenderTarget {\n  /**\n   * @param [descriptor] - Options for creating a render target.\n   */\n  constructor(descriptor = {}) {\n    /** unique id for this render target */\n    this.uid = uid(\"renderTarget\");\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    this.colorTextures = [];\n    this.dirtyId = 0;\n    this.isRoot = false;\n    this._size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    this._managedColorTextures = false;\n    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };\n    this.stencil = descriptor.stencil;\n    this.depth = descriptor.depth;\n    this.isRoot = descriptor.isRoot;\n    if (typeof descriptor.colorTextures === \"number\") {\n      this._managedColorTextures = true;\n      for (let i = 0; i < descriptor.colorTextures; i++) {\n        this.colorTextures.push(\n          new TextureSource({\n            width: descriptor.width,\n            height: descriptor.height,\n            resolution: descriptor.resolution,\n            antialias: descriptor.antialias\n          })\n        );\n      }\n    } else {\n      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n      const colorSource = this.colorTexture.source;\n      this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n    }\n    this.colorTexture.source.on(\"resize\", this.onSourceResize, this);\n    if (descriptor.depthStencilTexture || this.stencil) {\n      if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {\n        this.depthStencilTexture = descriptor.depthStencilTexture.source;\n      } else {\n        this.ensureDepthStencilTexture();\n      }\n    }\n  }\n  get size() {\n    const _size = this._size;\n    _size[0] = this.pixelWidth;\n    _size[1] = this.pixelHeight;\n    return _size;\n  }\n  get width() {\n    return this.colorTexture.source.width;\n  }\n  get height() {\n    return this.colorTexture.source.height;\n  }\n  get pixelWidth() {\n    return this.colorTexture.source.pixelWidth;\n  }\n  get pixelHeight() {\n    return this.colorTexture.source.pixelHeight;\n  }\n  get resolution() {\n    return this.colorTexture.source._resolution;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  onSourceResize(source) {\n    this.resize(source.width, source.height, source._resolution, true);\n  }\n  /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   */\n  ensureDepthStencilTexture() {\n    if (!this.depthStencilTexture) {\n      this.depthStencilTexture = new TextureSource({\n        width: this.width,\n        height: this.height,\n        resolution: this.resolution,\n        format: \"depth24plus-stencil8\",\n        autoGenerateMipmaps: false,\n        antialias: false,\n        mipLevelCount: 1\n        // sampleCount: handled by the render target system..\n      });\n    }\n  }\n  resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n    this.dirtyId++;\n    this.colorTextures.forEach((colorTexture, i) => {\n      if (skipColorTexture && i === 0)\n        return;\n      colorTexture.source.resize(width, height, resolution);\n    });\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n  }\n  destroy() {\n    this.colorTexture.source.off(\"resize\", this.onSourceResize, this);\n    if (this._managedColorTextures) {\n      this.colorTextures.forEach((texture) => {\n        texture.destroy();\n      });\n    }\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.destroy();\n      delete this.depthStencilTexture;\n    }\n  }\n};\n/** The default options for a render target */\n_RenderTarget.defaultOptions = {\n  /** the width of the RenderTarget */\n  width: 0,\n  /** the height of the RenderTarget */\n  height: 0,\n  /** the resolution of the RenderTarget */\n  resolution: 1,\n  /** an array of textures, or a number indicating how many color textures there should be */\n  colorTextures: 1,\n  /** should this render target have a stencil buffer? */\n  stencil: false,\n  /** should this render target have a depth buffer? */\n  depth: false,\n  /** should this render target be antialiased? */\n  antialias: false,\n  // save on perf by default!\n  /** is this a root element, true if this is gl context owners render target */\n  isRoot: false\n};\nlet RenderTarget = _RenderTarget;\n\nexport { RenderTarget };\n//# sourceMappingURL=RenderTarget.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass BufferResource extends EventEmitter {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({ buffer, offset, size }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    this._resourceType = \"bufferResource\";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on(\"change\", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit(\"change\", this);\n    this.buffer = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { BufferResource };\n//# sourceMappingURL=BufferResource.mjs.map\n","import { STENCIL_MODES } from '../../shared/state/const.mjs';\n\n\"use strict\";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  }\n};\n\nexport { GpuStencilModesToPixi };\n//# sourceMappingURL=GpuStencilModesToPixi.mjs.map\n","\"use strict\";\nfunction loopMatrix(col, row) {\n  const total = col * row;\n  return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst uboSyncFunctionsSTD40 = {\n  f32: `\n        data[offset] = v;`,\n  i32: `\n        dataInt32[offset] = v;`,\n  \"vec2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n  \"vec3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n  \"vec4<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n  \"vec2<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n  \"vec3<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n  \"vec4<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n  \"mat3x3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n  \"mat4x4<f32>\": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n  \"mat3x2<f32>\": loopMatrix(3, 2),\n  \"mat4x2<f32>\": loopMatrix(4, 2),\n  \"mat2x3<f32>\": loopMatrix(2, 3),\n  \"mat4x3<f32>\": loopMatrix(4, 3),\n  \"mat2x4<f32>\": loopMatrix(2, 4),\n  \"mat3x4<f32>\": loopMatrix(3, 4)\n};\nconst uboSyncFunctionsWGSL = {\n  ...uboSyncFunctionsSTD40,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL };\n//# sourceMappingURL=uboSyncFunctions.mjs.map\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass CustomRenderPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  updateRenderable() {\n  }\n  destroyRenderable() {\n  }\n  validateRenderable() {\n    return false;\n  }\n  addRenderable(container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(container);\n  }\n  execute(container) {\n    if (!container.isRenderable)\n      return;\n    container.render(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nCustomRenderPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"customRender\"\n};\n\nexport { CustomRenderPipe };\n//# sourceMappingURL=CustomRenderPipe.mjs.map\n","\"use strict\";\nfunction executeInstructions(renderGroup, renderer) {\n  const instructionSet = renderGroup.instructionSet;\n  const instructions = instructionSet.instructions;\n  for (let i = 0; i < instructionSet.instructionSize; i++) {\n    const instruction = instructions[i];\n    renderer[instruction.renderPipeId].execute(instruction);\n  }\n}\n\nexport { executeInstructions };\n//# sourceMappingURL=executeInstructions.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../sprite/BatchableSprite.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderGroup(renderGroup, instructionSet) {\n    if (renderGroup.isCachedAsTexture) {\n      this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n    } else {\n      this._addRenderableDirect(renderGroup, instructionSet);\n    }\n  }\n  execute(renderGroup) {\n    if (!renderGroup.isRenderable)\n      return;\n    if (renderGroup.isCachedAsTexture) {\n      this._executeCacheAsTexture(renderGroup);\n    } else {\n      this._executeDirect(renderGroup);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _addRenderableDirect(renderGroup, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    if (renderGroup._batchableRenderGroup) {\n      BigPool.return(renderGroup._batchableRenderGroup);\n      renderGroup._batchableRenderGroup = null;\n    }\n    instructionSet.add(renderGroup);\n  }\n  _addRenderableCacheAsTexture(renderGroup, instructionSet) {\n    const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite));\n    batchableRenderGroup.renderable = renderGroup.root;\n    batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n    batchableRenderGroup.texture = renderGroup.texture;\n    batchableRenderGroup.bounds = renderGroup._textureBounds;\n    instructionSet.add(renderGroup);\n    this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);\n    this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n    this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);\n  }\n  _executeCacheAsTexture(renderGroup) {\n    if (renderGroup.textureNeedsUpdate) {\n      renderGroup.textureNeedsUpdate = false;\n      const worldTransformMatrix = tempMatrix.identity().translate(\n        -renderGroup._textureBounds.x,\n        -renderGroup._textureBounds.y\n      );\n      this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n      this._renderer.globalUniforms.push({\n        worldTransformMatrix,\n        worldColor: 4294967295,\n        offset: { x: 0, y: 0 }\n      });\n      executeInstructions(renderGroup, this._renderer.renderPipes);\n      this._renderer.renderTarget.finishRenderPass();\n      this._renderer.renderTarget.pop();\n      this._renderer.globalUniforms.pop();\n    }\n    renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n    renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n  }\n  _executeDirect(renderGroup) {\n    this._renderer.globalUniforms.push({\n      worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n      worldColor: renderGroup.worldColorAlpha\n    });\n    executeInstructions(renderGroup, this._renderer.renderPipes);\n    this._renderer.globalUniforms.pop();\n  }\n}\nRenderGroupPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupPipe };\n//# sourceMappingURL=RenderGroupPipe.mjs.map\n","\"use strict\";\nfunction clearList(list, index) {\n  index || (index = 0);\n  for (let j = index; j < list.length; j++) {\n    if (list[j]) {\n      list[j] = null;\n    } else {\n      break;\n    }\n  }\n}\n\nexport { clearList };\n//# sourceMappingURL=clearList.mjs.map\n","import { Container, UPDATE_VISIBLE, UPDATE_COLOR, UPDATE_BLEND } from '../Container.mjs';\nimport { clearList } from './clearList.mjs';\nimport { multiplyColors } from './multiplyColors.mjs';\n\n\"use strict\";\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\nfunction updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const renderGroupDepth = Number(j);\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    clearList(list, index);\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(\n      root.relativeGroupTransform,\n      renderGroupParent.worldTransform\n    );\n    renderGroup.worldColor = multiplyColors(\n      root.groupColor,\n      renderGroupParent.worldColor\n    );\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick)\n    return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags |= container._updateFlags;\n    container.relativeGroupTransform.appendFrom(\n      localTransform,\n      parent.relativeGroupTransform\n    );\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    const renderable = container;\n    if (renderable.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(renderable);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & UPDATE_COLOR) {\n    container.groupColor = multiplyColors(\n      container.localColor,\n      parent.groupColor\n    );\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & UPDATE_BLEND) {\n    container.groupBlendMode = container.localBlendMode === \"inherit\" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & UPDATE_VISIBLE) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\n\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren };\n//# sourceMappingURL=updateRenderGroupTransforms.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport { Bounds } from './bounds/Bounds.mjs';\nimport { clearList } from './utils/clearList.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms.mjs';\nimport { validateRenderables } from './utils/validateRenderables.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({ container, transform }) {\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    const originalLocalTransform = tempMatrix;\n    if (transform) {\n      originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    this._updateCachedRenderGroups(container.renderGroup, null);\n    this._updateRenderGroups(container.renderGroup);\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {\n    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n    if (renderGroup.isCachedAsTexture) {\n      if (!renderGroup.textureNeedsUpdate)\n        return;\n      closestCacheAsTexture = renderGroup;\n    }\n    for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--) {\n      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n    }\n    renderGroup.invalidateMatrices();\n    if (renderGroup.isCachedAsTexture) {\n      if (renderGroup.textureNeedsUpdate) {\n        const bounds = renderGroup.root.getLocalBounds();\n        bounds.ceil();\n        const lastTexture = renderGroup.texture;\n        if (renderGroup.texture) {\n          TexturePool.returnTexture(renderGroup.texture, true);\n        }\n        const renderer = this._renderer;\n        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n        const scaleMode = renderGroup.textureOptions.scaleMode ?? \"linear\";\n        const texture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          resolution,\n          antialias\n        );\n        texture._source.style = new TextureStyle({ scaleMode });\n        renderGroup.texture = texture;\n        renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());\n        renderGroup._textureBounds.copyFrom(bounds);\n        if (lastTexture !== renderGroup.texture) {\n          if (renderGroup.renderGroupParent) {\n            renderGroup.renderGroupParent.structureDidChange = true;\n          }\n        }\n      }\n    } else if (renderGroup.texture) {\n      TexturePool.returnTexture(renderGroup.texture, true);\n      renderGroup.texture = null;\n    }\n  }\n  _updateRenderGroups(renderGroup) {\n    const renderer = this._renderer;\n    const renderPipes = renderer.renderPipes;\n    renderGroup.runOnRender(renderer);\n    renderGroup.instructionSet.renderPipes = renderPipes;\n    if (!renderGroup.structureDidChange) {\n      validateRenderables(renderGroup, renderPipes);\n    } else {\n      clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n    }\n    updateRenderGroupTransforms(renderGroup);\n    if (renderGroup.structureDidChange) {\n      renderGroup.structureDidChange = false;\n      this._buildInstructions(renderGroup, renderer);\n    } else {\n      this._updateRenderables(renderGroup);\n    }\n    renderGroup.childrenRenderablesToUpdate.index = 0;\n    renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)\n      return;\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n    }\n  }\n  _updateRenderables(renderGroup) {\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n    for (let i = 0; i < index; i++) {\n      const container = list[i];\n      if (container.didViewUpdate) {\n        renderGroup.updateRenderable(container);\n      }\n    }\n    clearList(list, index);\n  }\n  _buildInstructions(renderGroup, rendererOrPipes) {\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n    instructionSet.reset();\n    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n    const renderPipes = renderer.renderPipes;\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n    if (root.sortableChildren) {\n      root.sortChildren();\n    }\n    root.collectRenderablesWithEffects(instructionSet, renderer, null);\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupSystem };\n//# sourceMappingURL=RenderGroupSystem.mjs.map\n","\"use strict\";\nfunction validateRenderables(renderGroup, renderPipes) {\n  const { list } = renderGroup.childrenRenderablesToUpdate;\n  let rebuildRequired = false;\n  for (let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++) {\n    const container = list[i];\n    const renderable = container;\n    const pipe = renderPipes[renderable.renderPipeId];\n    rebuildRequired = pipe.validateRenderable(container);\n    if (rebuildRequired) {\n      break;\n    }\n  }\n  renderGroup.structureDidChange = rebuildRequired;\n  return rebuildRequired;\n}\n\nexport { validateRenderables };\n//# sourceMappingURL=validateRenderables.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BatchableSprite } from './BatchableSprite.mjs';\n\n\"use strict\";\nclass SpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = new BatchableSprite();\n    batchableSprite.renderable = sprite;\n    batchableSprite.transform = sprite.groupTransform;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    sprite._gpuData[this._renderer.uid] = batchableSprite;\n    return batchableSprite;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"sprite\"\n};\n\nexport { SpritePipe };\n//# sourceMappingURL=SpritePipe.mjs.map\n","import { ExtensionType, extensions } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { DefaultBatcher } from './DefaultBatcher.mjs';\n\n\"use strict\";\nconst _BatcherPipe = class _BatcherPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);\n    /** A record of all active batchers, keyed by their names */\n    this._activeBatches = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init?.(this);\n  }\n  static getBatcher(name) {\n    return new this._availableBatchers[name]();\n  }\n  buildStart(instructionSet) {\n    let batchers = this._batchersByInstructionSet[instructionSet.uid];\n    if (!batchers) {\n      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);\n      batchers.default || (batchers.default = new DefaultBatcher({\n        maxTextures: this.renderer.limits.maxBatchableTextures\n      }));\n    }\n    this._activeBatches = batchers;\n    this._activeBatch = this._activeBatches.default;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].begin();\n    }\n  }\n  addToBatch(batchableObject, instructionSet) {\n    if (this._activeBatch.name !== batchableObject.batcherName) {\n      this._activeBatch.break(instructionSet);\n      let batch = this._activeBatches[batchableObject.batcherName];\n      if (!batch) {\n        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);\n        batch.begin();\n      }\n      this._activeBatch = batch;\n    }\n    this._activeBatch.add(batchableObject);\n  }\n  break(instructionSet) {\n    this._activeBatch.break(instructionSet);\n  }\n  buildEnd(instructionSet) {\n    this._activeBatch.break(instructionSet);\n    const batches = this._activeBatches;\n    for (const i in batches) {\n      const batch = batches[i];\n      const geometry = batch.geometry;\n      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n    }\n  }\n  upload(instructionSet) {\n    const batchers = this._batchersByInstructionSet[instructionSet.uid];\n    for (const i in batchers) {\n      const batcher = batchers[i];\n      const geometry = batcher.geometry;\n      if (batcher.dirty) {\n        batcher.dirty = false;\n        geometry.buffers[0].update(batcher.attributeSize * 4);\n      }\n    }\n  }\n  execute(batch) {\n    if (batch.action === \"startBatch\") {\n      const batcher = batch.batcher;\n      const geometry = batcher.geometry;\n      const shader = batcher.shader;\n      this._adaptor.start(this, geometry, shader);\n    }\n    this._adaptor.execute(this, batch);\n  }\n  destroy() {\n    this.state = null;\n    this.renderer = null;\n    this._adaptor = null;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].destroy();\n    }\n    this._activeBatches = null;\n  }\n};\n/** @ignore */\n_BatcherPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"batch\"\n};\n_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);\nlet BatcherPipe = _BatcherPipe;\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\nextensions.add(DefaultBatcher);\n\nexport { BatcherPipe };\n//# sourceMappingURL=BatcherPipe.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix.mjs';\nimport { Filter } from '../Filter.mjs';\nimport fragment from './mask.frag.mjs';\nimport vertex from './mask.vert.mjs';\nimport source from './mask.wgsl.mjs';\n\n\"use strict\";\nclass MaskFilter extends Filter {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix(sprite.texture);\n    const filterUniforms = new UniformGroup({\n      uFilterMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: \"vec4<f32>\" },\n      uAlpha: { value: 1, type: \"f32\" },\n      uInverse: { value: options.inverse ? 1 : 0, type: \"f32\" }\n    });\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"mask-filter\"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      clipToViewport: false,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  set inverse(value) {\n    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n  }\n  get inverse() {\n    return this.resources.filterUniforms.uniforms.uInverse === 1;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\nexport { MaskFilter };\n//# sourceMappingURL=MaskFilter.mjs.map\n","var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n","var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter.mjs';\nimport { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../renderers/types.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nclass AlphaMaskEffect extends FilterEffect {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite(Texture.EMPTY),\n      inverse: false,\n      resolution: \"inherit\",\n      antialias: \"inherit\"\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n  get inverse() {\n    return this.filters[0].inverse;\n  }\n  set inverse(value) {\n    this.filters[0].inverse = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false,\n      maskedContainer\n    });\n    mask.inverse = maskedContainer._maskOptions.inverse;\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      maskContainer.collectRenderables(\n        instructionSet,\n        renderer,\n        null\n      );\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      maskedContainer,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"popMaskEnd\",\n      mask,\n      inverse: _maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === \"pushMaskBegin\") {\n      const filterEffect = BigPool.get(AlphaMaskEffect);\n      filterEffect.inverse = instruction.inverse;\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const filterTexture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          colorTextureSource._resolution,\n          colorTextureSource.antialias\n        );\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === \"pushMaskEnd\") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        if (renderer.type === RendererType.WEBGL) {\n          renderer.renderTarget.finishRenderPass();\n        }\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: \"filter\",\n        action: \"pushFilter\",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool.returnTexture(maskData.filterTexture);\n      }\n      BigPool.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"alphaMask\"\n};\n\nexport { AlphaMaskPipe };\n//# sourceMappingURL=AlphaMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    renderer.colorMask.setMask(instruction.colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nColorMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"colorMask\"\n};\n\nexport { ColorMaskPipe };\n//# sourceMappingURL=ColorMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { CLEAR } from '../../renderers/gl/const.mjs';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const.mjs';\n\n\"use strict\";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */ new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    maskContainer.collectRenderables(\n      instructionSet,\n      renderer,\n      null\n    );\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskBegin\",\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === \"pushMaskBegin\") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === \"pushMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === \"popMaskBegin\") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, CLEAR.STENCIL);\n        renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === \"popMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"stencilMask\"\n};\n\nexport { StencilMaskPipe };\n//# sourceMappingURL=StencilMaskPipe.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst _BackgroundSystem = class _BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new Color(0);\n    this.color = this._backgroundColor;\n    this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */\n  init(options) {\n    options = { ..._BackgroundSystem.defaultOptions, ...options };\n    this.clearBeforeRender = options.clearBeforeRender;\n    this.color = options.background || options.backgroundColor || this._backgroundColor;\n    this.alpha = options.backgroundAlpha;\n    this._backgroundColor.setAlpha(options.backgroundAlpha);\n  }\n  /** The background color to fill if not transparent */\n  get color() {\n    return this._backgroundColor;\n  }\n  set color(value) {\n    const incoming = Color.shared.setValue(value);\n    if (incoming.alpha < 1 && this._backgroundColor.alpha === 1) {\n      warn(\n        \"Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application.\"\n      );\n    }\n    this._backgroundColor.setValue(value);\n  }\n  /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color as an [R, G, B, A] array. */\n  get colorRgba() {\n    return this._backgroundColor.toArray();\n  }\n  /**\n   * destroys the background system\n   * @internal\n   */\n  destroy() {\n  }\n};\n/** @ignore */\n_BackgroundSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"background\",\n  priority: 0\n};\n/** default options used by the system */\n_BackgroundSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */\n  backgroundColor: 0,\n  /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */\n  clearBeforeRender: true\n};\nlet BackgroundSystem = _BackgroundSystem;\n\nexport { BackgroundSystem };\n//# sourceMappingURL=BackgroundSystem.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../../filters/FilterEffect.mjs';\nimport { RenderGroup } from '../../../../scene/container/RenderGroup.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst BLEND_MODE_FILTERS = {};\nextensions.handle(ExtensionType.BlendMode, (value) => {\n  if (!value.name) {\n    throw new Error(\"BlendMode extension must have a name property\");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value) => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._blendModeStack = [];\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.runners.prerender.add(this);\n  }\n  prerender() {\n    this._activeBlendMode = \"normal\";\n    this._isAdvanced = false;\n  }\n  /**\n   * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n   * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n   * @param blendMode - The blend mode to activate.\n   * @param instructionSet - The instruction set being built.\n   */\n  pushBlendMode(renderable, blendMode, instructionSet) {\n    this._blendModeStack.push(blendMode);\n    this.setBlendMode(renderable, blendMode, instructionSet);\n  }\n  /**\n   * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n   * @param instructionSet - The instruction set being built.\n   */\n  popBlendMode(instructionSet) {\n    this._blendModeStack.pop();\n    const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? \"normal\";\n    this.setBlendMode(null, blendMode, instructionSet);\n  }\n  /**\n   * Ensure a blend mode switch is added to the instruction set when the mode changes.\n   * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n   * rendered within a single filter pass.\n   * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n   * @param blendMode - The target blend mode.\n   * @param instructionSet - The instruction set being built.\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    const isRenderGroup = renderable instanceof RenderGroup;\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced && renderable && !isRenderGroup) {\n        this._renderableList?.push(renderable);\n      }\n      return;\n    }\n    if (this._isAdvanced)\n      this._endAdvancedBlendMode(instructionSet);\n    this._activeBlendMode = blendMode;\n    if (!renderable)\n      return;\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced)\n      this._beginAdvancedBlendMode(renderable, instructionSet);\n  }\n  _beginAdvancedBlendMode(renderable, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);\n      return;\n    }\n    const filterEffect = this._ensureFilterEffect(blendMode);\n    const isRenderGroup = renderable instanceof RenderGroup;\n    const instruction = {\n      renderPipeId: \"filter\",\n      action: \"pushFilter\",\n      filterEffect,\n      renderables: isRenderGroup ? null : [renderable],\n      container: isRenderGroup ? renderable.root : null,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _ensureFilterEffect(blendMode) {\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    return filterEffect;\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._isAdvanced = false;\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   */\n  buildEnd(instructionSet) {\n    if (!this._isAdvanced)\n      return;\n    this._endAdvancedBlendMode(instructionSet);\n  }\n  /** @internal */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"blendMode\"\n};\n\nexport { BlendModePipe };\n//# sourceMappingURL=BlendModePipe.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst imageTypes = {\n  png: \"image/png\",\n  jpg: \"image/jpeg\",\n  webp: \"image/webp\"\n};\nconst _ExtractSystem = class _ExtractSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  _normalizeOptions(options, defaults = {}) {\n    if (options instanceof Container || options instanceof Texture) {\n      return {\n        target: options,\n        ...defaults\n      };\n    }\n    return {\n      ...defaults,\n      ...options\n    };\n  }\n  /**\n   * Creates an IImage from a display object or texture.\n   * @param options - Options for creating the image, or the target to extract\n   * @returns Promise that resolves with the generated IImage\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const image = await renderer.extract.image(sprite);\n   * document.body.appendChild(image);\n   *\n   * // Advanced usage with options\n   * const image = await renderer.extract.image({\n   *     target: container,\n   *     format: 'webp',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2,\n   *     clearColor: '#ff0000',\n   *     antialias: true\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from('myTexture.png');\n   * const image = await renderer.extract.image(texture);\n   * ```\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.base64} For base64 string output\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ImageLike} For the image interface\n   * @category rendering\n   */\n  async image(options) {\n    const image = DOMAdapter.get().createImage();\n    image.src = await this.base64(options);\n    return image;\n  }\n  /**\n   * Converts the target into a base64 encoded string.\n   *\n   * This method works by first creating\n   * a canvas using `Extract.canvas` and then converting it to a base64 string.\n   * @param options - The options for creating the base64 string, or the target to extract\n   * @returns Promise that resolves with the base64 encoded string\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const base64 = await renderer.extract.base64(sprite);\n   * console.log(base64); // data:image/png;base64,...\n   *\n   * // Advanced usage with options\n   * const base64 = await renderer.extract.base64({\n   *     target: container,\n   *     format: 'webp',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2\n   * });\n   * ```\n   * @throws Will throw an error if the platform doesn't support any of:\n   * - ICanvas.toDataURL\n   * - ICanvas.toBlob\n   * - ICanvas.convertToBlob\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @category rendering\n   */\n  async base64(options) {\n    options = this._normalizeOptions(\n      options,\n      _ExtractSystem.defaultImageOptions\n    );\n    const { format, quality } = options;\n    const canvas = this.canvas(options);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error(\"ICanvas.toBlob failed!\"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, imageTypes[format], quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(imageTypes[format], quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n  }\n  /**\n   * Creates a Canvas element, renders the target to it and returns it.\n   * This method is useful for creating static images or when you need direct canvas access.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns A Canvas element with the texture rendered on\n   * @example\n   * ```ts\n   * // Basic canvas extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const canvas = renderer.extract.canvas(sprite);\n   * document.body.appendChild(canvas);\n   *\n   * // Extract with custom region\n   * const canvas = renderer.extract.canvas({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const canvas = renderer.extract.canvas({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from('myTexture.png');\n   * const canvas = renderer.extract.canvas(texture);\n   *\n   * // Extract with anti-aliasing\n   * const canvas = renderer.extract.canvas({\n   *     target: graphics,\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   */\n  canvas(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    if (target instanceof Texture) {\n      return renderer.texture.generateCanvas(target);\n    }\n    const texture = renderer.textureGenerator.generateTexture(options);\n    const canvas = renderer.texture.generateCanvas(texture);\n    texture.destroy(true);\n    return canvas;\n  }\n  /**\n   * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n   * with integer values between 0 and 255 (inclusive).\n   * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n   * @example\n   * ```ts\n   * // Basic pixel extraction\n   * const sprite = new Sprite(texture);\n   * const pixels = renderer.extract.pixels(sprite);\n   * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n   *\n   * // Extract with custom region\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     resolution: 2\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For image output\n   * @category rendering\n   */\n  pixels(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);\n    const pixelInfo = renderer.texture.getPixels(texture);\n    if (target instanceof Container) {\n      texture.destroy(true);\n    }\n    return pixelInfo;\n  }\n  /**\n   * Creates a texture from a display object or existing texture.\n   *\n   * This is useful for creating\n   * reusable textures from rendered content or making copies of existing textures.\n   * > [!NOTE] The returned texture should be destroyed when no longer needed\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns A new texture containing the extracted content\n   * @example\n   * ```ts\n   * // Basic texture extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const extractedTexture = renderer.extract.texture(sprite);\n   *\n   * // Extract with custom region\n   * const regionTexture = renderer.extract.texture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const hiResTexture = renderer.extract.texture({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Create a new sprite from extracted texture\n   * const newSprite = new Sprite(\n   *     renderer.extract.texture({\n   *         target: graphics,\n   *         antialias: true\n   *     })\n   * );\n   *\n   * // Clean up when done\n   * extractedTexture.destroy(true);\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link Texture} For texture management\n   * @see {@link GenerateTextureSystem} For texture generation\n   * @category rendering\n   */\n  texture(options) {\n    options = this._normalizeOptions(options);\n    if (options.target instanceof Texture)\n      return options.target;\n    return this._renderer.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Extracts and downloads content from the renderer as an image file.\n   * This is a convenient way to save screenshots or export rendered content.\n   * > [!NOTE] The download will use PNG format regardless of the filename extension\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   * @example\n   * ```ts\n   * // Basic download with default filename\n   * const sprite = new Sprite(texture);\n   * renderer.extract.download(sprite); // Downloads as 'image.png'\n   *\n   * // Download with custom filename\n   * renderer.extract.download({\n   *     target: sprite,\n   *     filename: 'screenshot.png'\n   * });\n   *\n   * // Download with custom region\n   * renderer.extract.download({\n   *     target: container,\n   *     filename: 'region.png',\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Download with high resolution and background\n   * renderer.extract.download({\n   *     target: stage,\n   *     filename: 'hd-screenshot.png',\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Download with anti-aliasing\n   * renderer.extract.download({\n   *     target: graphics,\n   *     filename: 'smooth.png',\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractDownloadOptions} For detailed options\n   * @see {@link ExtractSystem.image} For creating images without download\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @category rendering\n   */\n  download(options) {\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const link = document.createElement(\"a\");\n    link.download = options.filename ?? \"image.png\";\n    link.href = canvas.toDataURL(\"image/png\");\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  }\n  /**\n   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n   * The image will be displayed in the browser's console using CSS background images.\n   * @param options - The options for logging the image, or the target to log\n   * @param options.width - The width of the logged image preview in the console (in pixels)\n   * @example\n   * ```ts\n   * // Basic usage\n   * const sprite = new Sprite(texture);\n   * renderer.extract.log(sprite);\n   * ```\n   * @see {@link ExtractSystem.canvas} For getting raw canvas output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   * @advanced\n   */\n  log(options) {\n    const width = options.width ?? 200;\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const base64 = canvas.toDataURL();\n    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n    const style = [\n      \"font-size: 1px;\",\n      `padding: ${width}px ${300}px;`,\n      `background: url(${base64}) no-repeat;`,\n      \"background-size: contain;\"\n    ].join(\" \");\n    console.log(\"%c \", style);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_ExtractSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"extract\"\n};\n/**\n * Default options for image extraction.\n * @example\n * ```ts\n * // Customize default options\n * ExtractSystem.defaultImageOptions.format = 'webp';\n * ExtractSystem.defaultImageOptions.quality = 0.8;\n *\n * // Use defaults\n * const image = await renderer.extract.image(sprite);\n * ```\n */\n_ExtractSystem.defaultImageOptions = {\n  format: \"png\",\n  quality: 1\n};\nlet ExtractSystem = _ExtractSystem;\n\nexport { ExtractSystem };\n//# sourceMappingURL=ExtractSystem.mjs.map\n","import { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nclass RenderTexture extends Texture {\n  /**\n   * Creates a RenderTexture. Pass `dynamic: true` in options to allow resizing after creation.\n   * @param options - Options for the RenderTexture, including width, height, and dynamic.\n   * @returns A new RenderTexture instance.\n   * @example\n   * const rt = RenderTexture.create({ width: 100, height: 100, dynamic: true });\n   * rt.resize(500, 500);\n   */\n  static create(options) {\n    const { dynamic, ...rest } = options;\n    return new RenderTexture({\n      source: new TextureSource(rest),\n      dynamic: dynamic ?? false\n    });\n  }\n  /**\n   * Resizes the render texture.\n   * @param width - The new width of the render texture.\n   * @param height - The new height of the render texture.\n   * @param resolution - The new resolution of the render texture.\n   * @returns This texture.\n   */\n  resize(width, height, resolution) {\n    this.source.resize(width, height, resolution);\n    return this;\n  }\n}\n\nexport { RenderTexture };\n//# sourceMappingURL=RenderTexture.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { RenderTexture } from '../texture/RenderTexture.mjs';\n\n\"use strict\";\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * Creates a texture from a display object that can be used for creating sprites and other textures.\n   * This is particularly useful for optimizing performance when a complex container needs to be reused.\n   * @param options - Generate texture options or a container to convert to texture\n   * @returns A new RenderTexture containing the rendered display object\n   * @example\n   * ```ts\n   * // Basic usage with a container\n   * const container = new Container();\n   * container.addChild(\n   *     new Graphics()\n   *         .circle(0, 0, 50)\n   *         .fill('red')\n   * );\n   *\n   * const texture = renderer.textureGenerator.generateTexture(container);\n   *\n   * // Advanced usage with options\n   * const texture = renderer.textureGenerator.generateTexture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n   *     resolution: 2,                        // High DPI\n   *     clearColor: '#ff0000',               // Red background\n   *     antialias: true                      // Smooth edges\n   * });\n   *\n   * // Create a sprite from the generated texture\n   * const sprite = new Sprite(texture);\n   *\n   * // Clean up when done\n   * texture.destroy(true);\n   * ```\n   * @see {@link GenerateTextureOptions} For detailed texture generation options\n   * @see {@link RenderTexture} For the type of texture created\n   * @category rendering\n   */\n  generateTexture(options) {\n    if (options instanceof Container) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || getLocalBounds(container, tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    target.source.updateMipmaps();\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGenerator\"\n};\n\nexport { GenerateTextureSystem };\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst _GCSystem = class _GCSystem {\n  /**\n   * Creates a new GCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */\n  constructor(renderer) {\n    /** Array of resources being tracked for garbage collection */\n    this._managedResources = [];\n    this._managedResourceHashes = [];\n    this._ready = false;\n    this._renderer = renderer;\n  }\n  /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options\n   */\n  init(options) {\n    options = { ..._GCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.gcMaxUnusedTime;\n    this._frequency = options.gcFrequency;\n    this.enabled = options.gcActive;\n    this.now = performance.now();\n  }\n  /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */\n  get enabled() {\n    return !!this._handler;\n  }\n  /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */\n  set enabled(value) {\n    if (this.enabled === value)\n      return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => {\n          this._ready = true;\n        },\n        this._frequency,\n        false\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n      this._handler = 0;\n    }\n  }\n  /**\n   * Called before rendering. Updates the current timestamp.\n   * @param options - The render options\n   * @param options.container - The container to render\n   */\n  prerender({ container }) {\n    this.now = performance.now();\n    container.renderGroup.gcTick = this._renderer.tick++;\n    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n  }\n  /** Performs garbage collection after rendering. */\n  postrender() {\n    if (!this._ready || !this.enabled)\n      return;\n    this.run();\n    this._ready = false;\n  }\n  /**\n   * Updates the GC tick counter for a render group and its children.\n   * @param renderGroup - The render group to update\n   * @param gcTick - The new tick value\n   */\n  _updateInstructionGCTick(renderGroup, gcTick) {\n    renderGroup.instructionSet.gcTick = gcTick;\n    for (const child of renderGroup.renderGroupChildren) {\n      this._updateInstructionGCTick(child, gcTick);\n    }\n  }\n  /**\n   * Registers a resource for garbage collection tracking.\n   * @param resource - The resource to track\n   * @param type - The type of resource to track\n   */\n  addResource(resource, type) {\n    if (resource._gcLastUsed !== -1) {\n      resource._gcLastUsed = this.now;\n      resource._onTouch?.(this.now);\n      return;\n    }\n    const index = this._managedResources.length;\n    resource._gcData = {\n      index,\n      type\n    };\n    resource._gcLastUsed = this.now;\n    resource._onTouch?.(this.now);\n    resource.once(\"unload\", this.removeResource, this);\n    this._managedResources.push(resource);\n  }\n  /**\n   * Removes a resource from garbage collection tracking.\n   * Call this when manually destroying a resource.\n   * @param resource - The resource to stop tracking\n   */\n  removeResource(resource) {\n    const gcData = resource._gcData;\n    if (!gcData)\n      return;\n    const index = gcData.index;\n    const last = this._managedResources.length - 1;\n    if (index !== last) {\n      const lastResource = this._managedResources[last];\n      this._managedResources[index] = lastResource;\n      lastResource._gcData.index = index;\n    }\n    this._managedResources.length--;\n    resource._gcData = null;\n    resource._gcLastUsed = -1;\n  }\n  /**\n   * Registers a hash-based resource collection for garbage collection tracking.\n   * Resources in the hash will be automatically tracked and cleaned up when unused.\n   * @param context - The object containing the hash property\n   * @param hash - The property name on context that holds the resource hash\n   * @param type - The type of resources in the hash ('resource' or 'renderable')\n   * @param priority - Processing priority (lower values are processed first)\n   */\n  addResourceHash(context, hash, type, priority = 0) {\n    this._managedResourceHashes.push({\n      context,\n      hash,\n      type,\n      priority\n    });\n    this._managedResourceHashes.sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Performs garbage collection by cleaning up unused resources.\n   * Removes resources that haven't been used for longer than maxUnusedTime.\n   */\n  run() {\n    const now = performance.now();\n    const managedResourceHashes = this._managedResourceHashes;\n    for (const hashEntry of managedResourceHashes) {\n      this.runOnHash(hashEntry, now);\n    }\n    let writeIndex = 0;\n    for (let i = 0; i < this._managedResources.length; i++) {\n      const resource = this._managedResources[i];\n      writeIndex = this.runOnResource(resource, now, writeIndex);\n    }\n    this._managedResources.length = writeIndex;\n  }\n  updateRenderableGCTick(renderable, now) {\n    const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n    const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n    if ((renderGroup?.gcTick ?? 0) === currentTick) {\n      renderable._gcLastUsed = now;\n      renderable._onTouch?.(now);\n    }\n  }\n  runOnResource(resource, now, writeIndex) {\n    const gcData = resource._gcData;\n    if (gcData.type === \"renderable\") {\n      this.updateRenderableGCTick(resource, now);\n    }\n    const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n    if (isRecentlyUsed || !resource.autoGarbageCollect) {\n      this._managedResources[writeIndex] = resource;\n      gcData.index = writeIndex;\n      writeIndex++;\n    } else {\n      resource.unload();\n      resource._gcData = null;\n      resource._gcLastUsed = -1;\n      resource.off(\"unload\", this.removeResource, this);\n    }\n    return writeIndex;\n  }\n  /**\n   * Creates a clone of the hash, copying all non-null entries up to (but not including) the stop key.\n   * @param hashValue - The original hash to clone from\n   * @param stopKey - The key to stop at (exclusive)\n   * @returns A new hash object with copied entries\n   */\n  _createHashClone(hashValue, stopKey) {\n    const hashClone = /* @__PURE__ */ Object.create(null);\n    for (const k in hashValue) {\n      if (k === stopKey)\n        break;\n      if (hashValue[k] !== null)\n        hashClone[k] = hashValue[k];\n    }\n    return hashClone;\n  }\n  runOnHash(hashEntry, now) {\n    const { context, hash, type } = hashEntry;\n    const hashValue = context[hash];\n    let hashClone = null;\n    let nullCount = 0;\n    for (const key in hashValue) {\n      const resource = hashValue[key];\n      if (resource === null) {\n        nullCount++;\n        if (nullCount === 1e4 && !hashClone) {\n          hashClone = this._createHashClone(hashValue, key);\n        }\n        continue;\n      }\n      if (resource._gcLastUsed === -1) {\n        resource._gcLastUsed = now;\n        resource._onTouch?.(now);\n        if (hashClone)\n          hashClone[key] = resource;\n        continue;\n      }\n      if (type === \"renderable\") {\n        this.updateRenderableGCTick(resource, now);\n      }\n      const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n      if (!isRecentlyUsed && resource.autoGarbageCollect) {\n        if (!hashClone) {\n          if (nullCount + 1 !== 1e4) {\n            hashValue[key] = null;\n            nullCount++;\n          } else {\n            hashClone = this._createHashClone(hashValue, key);\n          }\n        }\n        resource.unload();\n        resource._gcData = null;\n        resource._gcLastUsed = -1;\n      } else if (hashClone) {\n        hashClone[key] = resource;\n      }\n    }\n    if (hashClone) {\n      context[hash] = hashClone;\n    }\n  }\n  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n  destroy() {\n    this.enabled = false;\n    this._managedResources.forEach((resource) => {\n      resource.off(\"unload\", this.removeResource, this);\n    });\n    this._managedResources.length = 0;\n    this._managedResourceHashes.length = 0;\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_GCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"gc\",\n  priority: 0\n};\n/** Default options for the GCSystem */\n_GCSystem.defaultOptions = {\n  /** Enable/disable the garbage collector */\n  gcActive: true,\n  /** Time in ms before an unused resource is collected (default 1 minute) */\n  gcMaxUnusedTime: 6e4,\n  /** How often to run garbage collection in ms (default 30 seconds) */\n  gcFrequency: 3e4\n};\nlet GCSystem = _GCSystem;\n\nexport { GCSystem };\n//# sourceMappingURL=GCSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../../maths/point/Point.mjs';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GlobalUniformSystem {\n  constructor(renderer) {\n    this._stackIndex = 0;\n    this._globalUniformDataStack = [];\n    this._uniformsPool = [];\n    this._activeUniforms = [];\n    this._bindGroupPool = [];\n    this._activeBindGroups = [];\n    this._renderer = renderer;\n  }\n  reset() {\n    this._stackIndex = 0;\n    for (let i = 0; i < this._activeUniforms.length; i++) {\n      this._uniformsPool.push(this._activeUniforms[i]);\n    }\n    for (let i = 0; i < this._activeBindGroups.length; i++) {\n      this._bindGroupPool.push(this._activeBindGroups[i]);\n    }\n    this._activeUniforms.length = 0;\n    this._activeBindGroups.length = 0;\n  }\n  start(options) {\n    this.reset();\n    this.push(options);\n  }\n  bind({\n    size,\n    projectionMatrix,\n    worldTransformMatrix,\n    worldColor,\n    offset\n  }) {\n    const renderTarget = this._renderer.renderTarget.renderTarget;\n    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n      projectionData: renderTarget,\n      worldTransformMatrix: new Matrix(),\n      worldColor: 4294967295,\n      offset: new Point()\n    };\n    const globalUniformData = {\n      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n      resolution: size || renderTarget.size,\n      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n      worldColor: worldColor || currentGlobalUniformData.worldColor,\n      offset: offset || currentGlobalUniformData.offset,\n      bindGroup: null\n    };\n    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n    this._activeUniforms.push(uniformGroup);\n    const uniforms = uniformGroup.uniforms;\n    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n    uniforms.uResolution = globalUniformData.resolution;\n    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n    color32BitToUniform(\n      globalUniformData.worldColor,\n      uniforms.uWorldColorAlpha,\n      0\n    );\n    uniformGroup.update();\n    let bindGroup;\n    if (this._renderer.renderPipes.uniformBatch) {\n      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n    } else {\n      bindGroup = this._bindGroupPool.pop() || new BindGroup();\n      this._activeBindGroups.push(bindGroup);\n      bindGroup.setResource(uniformGroup, 0);\n    }\n    globalUniformData.bindGroup = bindGroup;\n    this._currentGlobalUniformData = globalUniformData;\n  }\n  push(options) {\n    this.bind(options);\n    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n  }\n  pop() {\n    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n    if (this._renderer.type === RendererType.WEBGL) {\n      this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n  }\n  get bindGroup() {\n    return this._currentGlobalUniformData.bindGroup;\n  }\n  get globalUniformData() {\n    return this._currentGlobalUniformData;\n  }\n  get uniformGroup() {\n    return this._currentGlobalUniformData.bindGroup.resources[0];\n  }\n  _createUniforms() {\n    const globalUniforms = new UniformGroup({\n      uProjectionMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uWorldTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n      uWorldColorAlpha: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    }, {\n      isStatic: true\n    });\n    return globalUniforms;\n  }\n  destroy() {\n    this._renderer = null;\n    this._globalUniformDataStack.length = 0;\n    this._uniformsPool.length = 0;\n    this._activeUniforms.length = 0;\n    this._bindGroupPool.length = 0;\n    this._activeBindGroups.length = 0;\n    this._currentGlobalUniformData = null;\n  }\n}\n/** @ignore */\nGlobalUniformSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"globalUniforms\"\n};\n\nexport { GlobalUniformSystem };\n//# sourceMappingURL=GlobalUniformSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../ticker/Ticker.mjs';\n\n\"use strict\";\nlet uid = 1;\nclass SchedulerSystem {\n  constructor() {\n    this._tasks = [];\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    this._offset = 0;\n  }\n  /** Initializes the scheduler system and starts the ticker. */\n  init() {\n    Ticker.system.add(this._update, this);\n  }\n  /**\n   * Schedules a repeating task.\n   * @param func - The function to execute.\n   * @param duration - The interval duration in milliseconds.\n   * @param useOffset - this will spread out tasks so that they do not all run at the same time\n   * @returns The unique identifier for the scheduled task.\n   */\n  repeat(func, duration, useOffset = true) {\n    const id = uid++;\n    let offset = 0;\n    if (useOffset) {\n      this._offset += 1e3;\n      offset = this._offset;\n    }\n    this._tasks.push({\n      func,\n      duration,\n      start: performance.now(),\n      offset,\n      last: performance.now(),\n      repeat: true,\n      id\n    });\n    return id;\n  }\n  /**\n   * Cancels a scheduled task.\n   * @param id - The unique identifier of the task to cancel.\n   */\n  cancel(id) {\n    for (let i = 0; i < this._tasks.length; i++) {\n      if (this._tasks[i].id === id) {\n        this._tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Updates and executes the scheduled tasks.\n   * @private\n   */\n  _update() {\n    const now = performance.now();\n    for (let i = 0; i < this._tasks.length; i++) {\n      const task = this._tasks[i];\n      if (now - task.offset - task.last >= task.duration) {\n        const elapsed = now - task.start;\n        task.func(elapsed);\n        task.last = now;\n      }\n    }\n  }\n  /**\n   * Destroys the scheduler system and removes all tasks.\n   * @internal\n   */\n  destroy() {\n    Ticker.system.remove(this._update, this);\n    this._tasks.length = 0;\n  }\n}\n/** @ignore */\nSchedulerSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"scheduler\",\n  priority: 0\n};\n\nexport { SchedulerSystem };\n//# sourceMappingURL=SchedulerSystem.mjs.map\n","import { DOMAdapter } from '../environment/adapter.mjs';\nimport { VERSION } from './const.mjs';\n\n\"use strict\";\nlet saidHello = false;\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      \"background: #E72264; padding:5px 0;\",\n      \"background: #6CA2EA; padding:5px 0;\",\n      \"background: #B5D33D; padding:5px 0;\",\n      \"background: #FED23F; padding:5px 0;\",\n      \"color: #FFFFFF; background: #E72264; padding:5px 0;\",\n      \"color: #E72264; background: #FFFFFF; padding:5px 0;\"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\nexport { sayHello };\n//# sourceMappingURL=sayHello.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { sayHello } from '../../../../utils/sayHello.mjs';\nimport { RendererType } from '../../types.mjs';\n\n\"use strict\";\nclass HelloSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  init(options) {\n    if (options.hello) {\n      let name = this._renderer.name;\n      if (this._renderer.type === RendererType.WEBGL) {\n        name += ` ${this._renderer.context.webGLVersion}`;\n      }\n      sayHello(name);\n    }\n  }\n}\n/** @ignore */\nHelloSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"hello\",\n  priority: -2\n};\n/** The default options for the system. */\nHelloSystem.defaultOptions = {\n  /** {@link WebGLOptions.hello} */\n  hello: false\n};\n\nexport { HelloSystem };\n//# sourceMappingURL=HelloSystem.mjs.map\n","\"use strict\";\nfunction cleanHash(hash) {\n  let clean = false;\n  for (const i in hash) {\n    if (hash[i] == void 0) {\n      clean = true;\n      break;\n    }\n  }\n  if (!clean)\n    return hash;\n  const cleanHash2 = /* @__PURE__ */ Object.create(null);\n  for (const i in hash) {\n    const value = hash[i];\n    if (value) {\n      cleanHash2[i] = value;\n    }\n  }\n  return cleanHash2;\n}\nfunction cleanArray(arr) {\n  let offset = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] == void 0) {\n      offset++;\n    } else {\n      arr[i - offset] = arr[i];\n    }\n  }\n  arr.length -= offset;\n  return arr;\n}\n\nexport { cleanArray, cleanHash };\n//# sourceMappingURL=clean.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { cleanHash, cleanArray } from '../../../../utils/data/clean.mjs';\n\n\"use strict\";\nlet renderableGCTick = 0;\nconst _RenderableGCSystem = class _RenderableGCSystem {\n  /**\n   * Creates a new RenderableGCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */\n  constructor(renderer) {\n    /** Array of renderables being tracked for garbage collection */\n    this._managedRenderables = [];\n    /** Array of hash objects being tracked for cleanup */\n    this._managedHashes = [];\n    /** Array of arrays being tracked for cleanup */\n    this._managedArrays = [];\n    this._renderer = renderer;\n  }\n  /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options for the renderer\n   */\n  init(options) {\n    options = { ..._RenderableGCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n    this._frequency = options.renderableGCFrequency;\n    this.enabled = options.renderableGCActive;\n  }\n  /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */\n  get enabled() {\n    return !!this._handler;\n  }\n  /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */\n  set enabled(value) {\n    if (this.enabled === value)\n      return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => this.run(),\n        this._frequency,\n        false\n      );\n      this._hashHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const hash of this._managedHashes) {\n            hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n          }\n        },\n        this._frequency\n      );\n      this._arrayHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const array of this._managedArrays) {\n            cleanArray(array.context[array.hash]);\n          }\n        },\n        this._frequency\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n      this._renderer.scheduler.cancel(this._hashHandler);\n      this._renderer.scheduler.cancel(this._arrayHandler);\n    }\n  }\n  /**\n   * Adds a hash table to be managed by the garbage collector.\n   * @param context - The object containing the hash table\n   * @param hash - The property name of the hash table\n   */\n  addManagedHash(context, hash) {\n    this._managedHashes.push({ context, hash });\n  }\n  /**\n   * Adds an array to be managed by the garbage collector.\n   * @param context - The object containing the array\n   * @param hash - The property name of the array\n   */\n  addManagedArray(context, hash) {\n    this._managedArrays.push({ context, hash });\n  }\n  /**\n   * Updates the GC timestamp and tracking before rendering.\n   * @param options - The render options\n   * @param options.container - The container to render\n   */\n  prerender({\n    container\n  }) {\n    this._now = performance.now();\n    container.renderGroup.gcTick = renderableGCTick++;\n    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n  }\n  /**\n   * Starts tracking a renderable for garbage collection.\n   * @param renderable - The renderable to track\n   */\n  addRenderable(renderable) {\n    if (!this.enabled)\n      return;\n    if (renderable._lastUsed === -1) {\n      this._managedRenderables.push(renderable);\n      renderable.once(\"destroyed\", this._removeRenderable, this);\n    }\n    renderable._lastUsed = this._now;\n  }\n  /**\n   * Performs garbage collection by cleaning up unused renderables.\n   * Removes renderables that haven't been used for longer than maxUnusedTime.\n   */\n  run() {\n    const now = this._now;\n    const managedRenderables = this._managedRenderables;\n    const renderPipes = this._renderer.renderPipes;\n    let offset = 0;\n    for (let i = 0; i < managedRenderables.length; i++) {\n      const renderable = managedRenderables[i];\n      if (renderable === null) {\n        offset++;\n        continue;\n      }\n      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n      const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n      if ((renderGroup?.gcTick ?? 0) === currentTick) {\n        renderable._lastUsed = now;\n      }\n      if (now - renderable._lastUsed > this.maxUnusedTime) {\n        if (!renderable.destroyed) {\n          const rp = renderPipes;\n          if (renderGroup)\n            renderGroup.structureDidChange = true;\n          rp[renderable.renderPipeId].destroyRenderable(renderable);\n        }\n        renderable._lastUsed = -1;\n        offset++;\n        renderable.off(\"destroyed\", this._removeRenderable, this);\n      } else {\n        managedRenderables[i - offset] = renderable;\n      }\n    }\n    managedRenderables.length -= offset;\n  }\n  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n  destroy() {\n    this.enabled = false;\n    this._renderer = null;\n    this._managedRenderables.length = 0;\n    this._managedHashes.length = 0;\n    this._managedArrays.length = 0;\n  }\n  /**\n   * Removes a renderable from being tracked when it's destroyed.\n   * @param renderable - The renderable to stop tracking\n   */\n  _removeRenderable(renderable) {\n    const index = this._managedRenderables.indexOf(renderable);\n    if (index >= 0) {\n      renderable.off(\"destroyed\", this._removeRenderable, this);\n      this._managedRenderables[index] = null;\n    }\n  }\n  /**\n   * Updates the GC tick counter for a render group and its children.\n   * @param renderGroup - The render group to update\n   * @param gcTick - The new tick value\n   */\n  _updateInstructionGCTick(renderGroup, gcTick) {\n    renderGroup.instructionSet.gcTick = gcTick;\n    for (const child of renderGroup.renderGroupChildren) {\n      this._updateInstructionGCTick(child, gcTick);\n    }\n  }\n};\n/**\n * Extension metadata for registering this system with the renderer.\n * @ignore\n */\n_RenderableGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"renderableGC\",\n  priority: 0\n};\n/**\n * Default configuration options for the garbage collection system.\n * These can be overridden when initializing the renderer.\n */\n_RenderableGCSystem.defaultOptions = {\n  /** Enable/disable the garbage collector */\n  renderableGCActive: true,\n  /** Time in ms before an unused resource is collected (default 1 minute) */\n  renderableGCMaxUnusedTime: 6e4,\n  /** How often to run garbage collection in ms (default 30 seconds) */\n  renderableGCFrequency: 3e4\n};\nlet RenderableGCSystem = _RenderableGCSystem;\n\nexport { RenderableGCSystem };\n//# sourceMappingURL=RenderableGCSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { deprecation } from '../../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _TextureGCSystem = class _TextureGCSystem {\n  /**\n   * Frame count since started.\n   * @readonly\n   * @deprecated since 8.15.0\n   */\n  get count() {\n    return this._renderer.tick;\n  }\n  /**\n   * Frame count since last garbage collection.\n   * @readonly\n   * @deprecated since 8.15.0\n   */\n  get checkCount() {\n    return this._checkCount;\n  }\n  set checkCount(value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._checkCount = value;\n  }\n  /**\n   * Maximum idle frames before a texture is destroyed by garbage collection.\n   * @see TextureGCSystem.defaultMaxIdle\n   * @deprecated since 8.15.0\n   */\n  get maxIdle() {\n    return this._renderer.gc.maxUnusedTime / 1e3 * 60;\n  }\n  set maxIdle(value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._renderer.gc.maxUnusedTime = value / 60 * 1e3;\n  }\n  /**\n   * Frames between two garbage collections.\n   * @see TextureGCSystem.defaultCheckCountMax\n   * @deprecated since 8.15.0\n   */\n  // eslint-disable-next-line dot-notation\n  get checkCountMax() {\n    return Math.floor(this._renderer.gc[\"_frequency\"] / 1e3);\n  }\n  set checkCountMax(_value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n  }\n  /**\n   * Current garbage collection mode.\n   * @see TextureGCSystem.defaultMode\n   * @deprecated since 8.15.0\n   */\n  get active() {\n    return this._renderer.gc.enabled;\n  }\n  set active(value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._renderer.gc.enabled = value;\n  }\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._checkCount = 0;\n  }\n  init(options) {\n    if (options.textureGCActive !== _TextureGCSystem.defaultOptions.textureGCActive) {\n      this.active = options.textureGCActive;\n    }\n    if (options.textureGCMaxIdle !== _TextureGCSystem.defaultOptions.textureGCMaxIdle) {\n      this.maxIdle = options.textureGCMaxIdle;\n    }\n    if (options.textureGCCheckCountMax !== _TextureGCSystem.defaultOptions.textureGCCheckCountMax) {\n      this.checkCountMax = options.textureGCCheckCountMax;\n    }\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   * @deprecated since 8.15.0\n   */\n  run() {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._renderer.gc.run();\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_TextureGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGC\"\n};\n/**\n * Default options for the TextureGCSystem\n * @deprecated since 8.15.0\n */\n_TextureGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  textureGCActive: true,\n  /**\n   * @deprecated since 8.3.0\n   * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n   */\n  textureGCAMaxIdle: null,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  textureGCMaxIdle: 60 * 60,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  textureGCCheckCountMax: 600\n};\nlet TextureGCSystem = _TextureGCSystem;\n\nexport { TextureGCSystem };\n//# sourceMappingURL=TextureGCSystem.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { RenderTarget } from '../renderTarget/RenderTarget.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\n\n\"use strict\";\nconst _ViewSystem = class _ViewSystem {\n  /**\n   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n   * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n   * @type {boolean}\n   */\n  get autoDensity() {\n    return this.texture.source.autoDensity;\n  }\n  set autoDensity(value) {\n    this.texture.source.autoDensity = value;\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.texture.source._resolution;\n  }\n  set resolution(value) {\n    this.texture.source.resize(\n      this.texture.source.width,\n      this.texture.source.height,\n      value\n    );\n  }\n  /**\n   * initiates the view system\n   * @param options - the options for the view\n   */\n  init(options) {\n    options = {\n      ..._ViewSystem.defaultOptions,\n      ...options\n    };\n    if (options.view) {\n      deprecation(v8_0_0, \"ViewSystem.view has been renamed to ViewSystem.canvas\");\n      options.canvas = options.view;\n    }\n    this.screen = new Rectangle(0, 0, options.width, options.height);\n    this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n    this.antialias = !!options.antialias;\n    this.texture = getCanvasTexture(this.canvas, options);\n    this.renderTarget = new RenderTarget({\n      colorTextures: [this.texture],\n      depth: !!options.depth,\n      isRoot: true\n    });\n    this.texture.source.transparent = options.backgroundAlpha < 1;\n    this.resolution = options.resolution;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   * @param resolution\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.screen.width = this.texture.frame.width;\n    this.screen.height = this.texture.frame.height;\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {options | false} options - The options for destroying the view, or \"false\".\n   * @example\n   * viewSystem.destroy();\n   * viewSystem.destroy(true);\n   * viewSystem.destroy({ removeView: true });\n   */\n  destroy(options = false) {\n    const removeView = typeof options === \"boolean\" ? options : !!options?.removeView;\n    if (removeView && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas);\n    }\n    this.texture.destroy();\n  }\n};\n/** @ignore */\n_ViewSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"view\",\n  priority: 0\n};\n/** The default options for the view system. */\n_ViewSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.width}\n   * @default 800\n   */\n  width: 800,\n  /**\n   * {@link WebGLOptions.height}\n   * @default 600\n   */\n  height: 600,\n  /**\n   * {@link WebGLOptions.autoDensity}\n   * @default false\n   */\n  autoDensity: false,\n  /**\n   * {@link WebGLOptions.antialias}\n   * @default false\n   */\n  antialias: false\n};\nlet ViewSystem = _ViewSystem;\n\nexport { ViewSystem };\n//# sourceMappingURL=ViewSystem.mjs.map\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe.mjs';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe.mjs';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem.mjs';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe.mjs';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks.mjs';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe.mjs';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe.mjs';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe.mjs';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe.mjs';\nimport { BackgroundSystem } from '../background/BackgroundSystem.mjs';\nimport { BlendModePipe } from '../blendModes/BlendModePipe.mjs';\nimport { ExtractSystem } from '../extract/ExtractSystem.mjs';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem.mjs';\nimport { GCSystem } from '../GCSystem.mjs';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem.mjs';\nimport { SchedulerSystem } from '../SchedulerSystem.mjs';\nimport { HelloSystem } from '../startup/HelloSystem.mjs';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem.mjs';\nimport { TextureGCSystem } from '../texture/TextureGCSystem.mjs';\nimport { ViewSystem } from '../view/ViewSystem.mjs';\n\n\"use strict\";\nconst SharedSystems = [\n  BackgroundSystem,\n  GlobalUniformSystem,\n  HelloSystem,\n  ViewSystem,\n  RenderGroupSystem,\n  GCSystem,\n  TextureGCSystem,\n  GenerateTextureSystem,\n  ExtractSystem,\n  RendererInitHook,\n  RenderableGCSystem,\n  SchedulerSystem\n];\nconst SharedRenderPipes = [\n  BlendModePipe,\n  BatcherPipe,\n  SpritePipe,\n  RenderGroupPipe,\n  AlphaMaskPipe,\n  StencilMaskPipe,\n  ColorMaskPipe,\n  CustomRenderPipe\n];\n\nexport { SharedRenderPipes, SharedSystems };\n//# sourceMappingURL=SharedSystems.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","\"use strict\";\nconst textureBit = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\nexport { textureBit, textureBitGl };\n//# sourceMappingURL=textureBit.mjs.map\n","import { uniformParsers } from './uniformParsers.mjs';\n\n\"use strict\";\nfunction createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n  const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n  let prev = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const name = uboElement.data.name;\n    let parsed = false;\n    let offset = 0;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.test(uboElement.data)) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          `name = \"${name}\";`,\n          `offset += ${offset - prev};`,\n          uniformParsers[j][parserCode] || uniformParsers[j].ubo\n        );\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n      } else {\n        const template = singleSettersMap[uboElement.data.type];\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          /* wgsl */\n          `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `\n        );\n      }\n    }\n    prev = offset;\n  }\n  const fragmentSrc = funcFragments.join(\"\\n\");\n  return new Function(\n    \"uv\",\n    \"data\",\n    \"dataInt32\",\n    \"offset\",\n    fragmentSrc\n  );\n}\n\nexport { createUboSyncFunction };\n//# sourceMappingURL=createUboSyncFunction.mjs.map\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    this._state = State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n    if (options.blendRequired) {\n      this.addResource(\"uBackTexture\", 0, 3);\n    }\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/** The default filter settings */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { BufferUsage } from '../buffer/const.mjs';\n\n\"use strict\";\nclass UboSystem {\n  constructor(adaptor) {\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n    this._adaptor = adaptor;\n    this._systemCheck();\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   */\n  _systemCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n  ensureUniformGroup(uniformGroup) {\n    const uniformData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n  }\n  getUniformGroupData(uniformGroup) {\n    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n  }\n  _initUniformGroup(uniformGroup) {\n    const uniformGroupSignature = uniformGroup._signature;\n    let uniformData = this._syncFunctionHash[uniformGroupSignature];\n    if (!uniformData) {\n      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n      const layout = this._adaptor.createUboElements(elements);\n      const syncFunction = this._generateUboSync(layout.uboElements);\n      uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n        layout,\n        syncFunction\n      };\n    }\n    return this._syncFunctionHash[uniformGroupSignature];\n  }\n  _generateUboSync(uboElements) {\n    return this._adaptor.generateUboSync(uboElements);\n  }\n  syncUniformGroup(uniformGroup, data, offset) {\n    const uniformGroupData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformGroupData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n    let dataInt32 = null;\n    if (!data) {\n      data = uniformGroup.buffer.data;\n      dataInt32 = uniformGroup.buffer.dataInt32;\n    }\n    offset || (offset = 0);\n    uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n    return true;\n  }\n  updateUniformGroup(uniformGroup) {\n    if (uniformGroup.isStatic && !uniformGroup._dirtyId)\n      return false;\n    uniformGroup._dirtyId = 0;\n    const synced = this.syncUniformGroup(uniformGroup);\n    uniformGroup.buffer.update();\n    return synced;\n  }\n  destroy() {\n    this._syncFunctionHash = null;\n  }\n}\n\nexport { UboSystem };\n//# sourceMappingURL=UboSystem.mjs.map\n","import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\n\nexport { ensureAttributes };\n//# sourceMappingURL=ensureAttributes.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection.mjs';\nimport { SystemRunner } from '../system/SystemRunner.mjs';\nimport { CanvasSource } from '../texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\nimport { isRenderingToScreen } from './isRenderingToScreen.mjs';\nimport { RenderTarget } from './RenderTarget.mjs';\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass*/\n    this.rootViewPort = new Rectangle();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuRenderTargetHash\");\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n    this.adaptor.prerender?.(this.rootRenderTarget);\n  }\n  postrender() {\n    this.adaptor.postrender?.(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n    if (!frame && renderSurface instanceof Texture) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      viewport.x = frame.x * resolution + 0.5 | 0;\n      viewport.y = frame.y * resolution + 0.5 | 0;\n      viewport.width = frame.width * resolution + 0.5 | 0;\n      viewport.height = frame.height * resolution + 0.5 | 0;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = CLEAR.ALL, clearColor) {\n    if (!clear)\n      return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */\n  push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture.\n   *\n   * NOTE:\n   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n   *\n   * The following is not valid:\n   * @example\n   * const canvas = document.createElement('canvas')\n   * canvas.width = 200;\n   * canvas.height = 200;\n   *\n   * const ctx = canvas2.getContext('2d')!\n   * ctx.fillStyle = 'red'\n   * ctx.fillRect(0, 0, 200, 200);\n   *\n   * const texture = RenderTexture.create({\n   *   width: 200,\n   *   height: 200,\n   * })\n   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n   *\n   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n   *\n   * The best way to copy a canvas is to create a texture from it. Then render with that.\n   *\n   * Parsing in a RenderTarget canvas context (with a 2d context)\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource.test(renderSurface)) {\n      renderSurface = getCanvasTexture(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource) {\n      renderTarget = new RenderTarget({\n        colorTextures: [renderSurface]\n      });\n      if (renderSurface.source instanceof CanvasSource) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n  resetState() {\n    this.renderTarget = null;\n    this.renderSurface = null;\n  }\n}\n\nexport { RenderTargetSystem };\n//# sourceMappingURL=RenderTargetSystem.mjs.map\n","\"use strict\";\nfunction isRenderingToScreen(renderTarget) {\n  const resource = renderTarget.colorTexture.source.resource;\n  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\nexport { isRenderingToScreen };\n//# sourceMappingURL=isRenderingToScreen.mjs.map\n","\"use strict\";\nfunction calculateProjection(pm, x, y, width, height, flipY) {\n  const sign = flipY ? 1 : -1;\n  pm.identity();\n  pm.a = 1 / width * 2;\n  pm.d = sign * (1 / height * 2);\n  pm.tx = -1 - x * pm.a;\n  pm.ty = -sign - y * pm.d;\n  return pm;\n}\n\nexport { calculateProjection };\n//# sourceMappingURL=calculateProjection.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","\"use strict\";\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: \"mat3x3<f32>\",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: \"vec2<f32>\",\n    test: (data) => data.type === \"vec2<f32>\" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: \"vec3<f32>\",\n    test: (data) => data.type === \"vec3<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\nexport { uniformParsers };\n//# sourceMappingURL=uniformParsers.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n  destroy() {\n    this.reset();\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","import { GlobalResourceRegistry } from '../../../../../utils/pool/GlobalResourceRegistry.mjs';\nimport { CanvasSource } from '../sources/CanvasSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst canvasCache = /* @__PURE__ */ new Map();\nGlobalResourceRegistry.register(canvasCache);\nfunction getCanvasTexture(canvas, options) {\n  if (!canvasCache.has(canvas)) {\n    const texture = new Texture({\n      source: new CanvasSource({\n        resource: canvas,\n        ...options\n      })\n    });\n    const onDestroy = () => {\n      if (canvasCache.get(canvas) === texture) {\n        canvasCache.delete(canvas);\n      }\n    };\n    texture.once(\"destroy\", onDestroy);\n    texture.source.once(\"destroy\", onDestroy);\n    canvasCache.set(canvas, texture);\n  }\n  return canvasCache.get(canvas);\n}\nfunction hasCachedCanvasTexture(canvas) {\n  return canvasCache.has(canvas);\n}\n\nexport { getCanvasTexture, hasCachedCanvasTexture };\n//# sourceMappingURL=getCanvasTexture.mjs.map\n"],"names":["_RenderTarget","constructor","descriptor","this","uid","colorTextures","dirtyId","isRoot","_size","Float32Array","_managedColorTextures","defaultOptions","stencil","depth","i","push","width","height","resolution","antialias","map","texture","source","colorSource","colorTexture","resize","_resolution","on","onSourceResize","depthStencilTexture","ensureDepthStencilTexture","size","pixelWidth","pixelHeight","format","autoGenerateMipmaps","mipLevelCount","skipColorTexture","forEach","destroy","off","RenderTarget","BufferResource","buffer","offset","super","_resourceType","_touched","_resourceId","_bufferResource","destroyed","onBufferChange","emit","destroyBuffer","removeAllListeners","GpuStencilModesToPixi","NONE","DISABLED","stencilWriteMask","stencilReadMask","RENDERING_MASK_ADD","stencilFront","compare","passOp","stencilBack","RENDERING_MASK_REMOVE","MASK_ACTIVE","INVERSE_MASK_ACTIVE","loopMatrix","col","row","uboSyncFunctionsSTD40","f32","i32","uboSyncFunctionsWGSL","localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","CustomRenderPipe","renderer","_renderer","updateRenderable","destroyRenderable","validateRenderable","addRenderable","container","instructionSet","renderPipes","batch","break","add","execute","isRenderable","render","extension","type","WebGLPipes","WebGPUPipes","CanvasPipes","executeInstructions","renderGroup","instructions","instructionSize","instruction","renderPipeId","tempMatrix","Matrix","RenderGroupPipe","addRenderGroup","isCachedAsTexture","_addRenderableCacheAsTexture","_addRenderableDirect","_executeCacheAsTexture","_executeDirect","_batchableRenderGroup","return","batchableRenderGroup","get","BatchableSprite","renderable","root","transform","relativeGroupTransform","bounds","_textureBounds","blendMode","pushBlendMode","groupBlendMode","addToBatch","popBlendMode","textureNeedsUpdate","worldTransformMatrix","identity","translate","x","y","renderTarget","frame","globalUniforms","worldColor","finishRenderPass","pop","_batcher","updateElement","geometry","buffers","update","inverseParentTextureTransform","worldColorAlpha","clearList","list","index","j","length","tempContainer","Container","UPDATE_BLEND_COLOR_VISIBLE","updateRenderGroupTransforms","updateChildRenderGroups","worldAlpha","renderGroupParent","worldTransform","appendFrom","multiplyColors","groupColor","groupAlpha","copyFrom","localTransform","localColor","localAlpha","updateRenderGroupTransform","childrenToUpdate","updateTick","renderGroupDepth","Number","childrenAtDepth","child","parentRenderGroup","relativeRenderGroupDepth","updateTransformAndChildren","renderGroupChildren","updateFlags","didChange","updateLocalTransform","parent","_updateFlags","updateColorBlendVisibility","children","structureDidChange","groupColorAlpha","localBlendMode","globalDisplayStatus","localDisplayStatus","RenderGroupSystem","originalLocalTransform","_updateCachedRenderGroups","_updateRenderGroups","start","uniformBatch","renderEnd","closestCacheAsTexture","_parentCacheAsTextureRenderGroup","invalidateMatrices","getLocalBounds","ceil","lastTexture","TexturePool","returnTexture","textureOptions","view","scaleMode","getOptimalTexture","_source","style","TextureStyle","Bounds","runOnRender","childrenRenderablesToUpdate","rebuildRequired","validateRenderables","_buildInstructions","_updateRenderables","upload","didViewUpdate","rendererOrPipes","reset","buildStart","colorMask","sortableChildren","sortChildren","collectRenderablesWithEffects","buildEnd","WebGLSystem","WebGPUSystem","CanvasSystem","SpritePipe","sprite","gpuSprite","_getGpuSprite","_updateBatchableSprite","checkAndUpdateTexture","_texture","batchableSprite","visualBounds","_gpuData","_initGPUSprite","groupTransform","roundPixels","_roundPixels","_BatcherPipe","adaptor","state","State","for2d","_batchersByInstructionSet","Object","create","_activeBatches","_adaptor","init","getBatcher","_availableBatchers","batchers","default","DefaultBatcher","maxTextures","limits","maxBatchableTextures","_activeBatch","begin","batchableObject","batcherName","batches","indexBuffer","setDataWithSize","indexSize","attributeBuffer","float32View","attributeSize","batcher","dirty","action","shader","BatcherPipe","handleByMap","Batcher","MaskFilter","Filter","options","rest","textureMatrix","TextureMatrix","filterUniforms","UniformGroup","uFilterMatrix","value","uMaskClamp","uClampFrame","uAlpha","uInverse","inverse","gpuProgram","GpuProgram","from","entryPoint","fragment","glProgram","GlProgram","clipToViewport","resources","uMaskTexture","_textureMatrix","uniforms","apply","filterManager","input","output","clearMode","calculateSpriteMatrix","prepend","mapCoord","applyFilter","tempBounds","AlphaMaskEffect","FilterEffect","filters","Sprite","Texture","EMPTY","AlphaMaskPipe","_activeMaskStage","mask","maskedContainer","_maskOptions","canBundle","renderMaskToTexture","maskContainer","includeInBuild","collectRenderables","_maskedContainer","renderMask","filterEffect","measurable","getGlobalBounds","colorTextureSource","filterTexture","tx","minX","ty","minY","maskData","WEBGL","filter","ColorMaskPipe","_colorStack","_colorStackIndex","_currentColor","_container","colorStack","currentColor","_mask","setMask","StencilMaskPipe","_maskStackHash","_maskHash","WeakMap","_a","effect","setBlendMode","has","set","instructionsStart","instructionsLength","renderTargetUid","maskStackIndex","ensureDepthStencil","setStencilMode","clear","STENCIL","_BackgroundSystem","clearBeforeRender","_backgroundColor","Color","color","alpha","background","backgroundColor","backgroundAlpha","setAlpha","shared","setValue","warn","colorRgba","toArray","priority","BackgroundSystem","BLEND_MODE_FILTERS","handle","BlendMode","Error","ref","BlendModePipe","_blendModeStack","_isAdvanced","_filterHash","runners","prerender","_activeBlendMode","isRenderGroup","RenderGroup","_endAdvancedBlendMode","_beginAdvancedBlendMode","_renderableList","_ensureFilterEffect","renderables","imageTypes","png","jpg","webp","_ExtractSystem","_normalizeOptions","defaults","target","image","createImage","src","base64","defaultImageOptions","quality","canvas","toBlob","Promise","resolve","reject","blob","reader","FileReader","onload","result","onerror","readAsDataURL","toDataURL","convertToBlob","generateCanvas","textureGenerator","generateTexture","pixels","pixelInfo","getPixels","download","link","document","createElement","filename","href","body","appendChild","click","removeChild","log","console","join","ExtractSystem","RenderTexture","dynamic","TextureSource","tempRect","Rectangle","noColor","GenerateTextureSystem","textureSourceOptions","clearColor","Array","isArray","region","copyTo","rectangle","Math","max","updateMipmaps","_GCSystem","_managedResources","_managedResourceHashes","_ready","maxUnusedTime","gcMaxUnusedTime","_frequency","gcFrequency","enabled","gcActive","now","performance","_handler","scheduler","repeat","cancel","gcTick","tick","_updateInstructionGCTick","postrender","run","addResource","resource","_gcLastUsed","_onTouch","_gcData","once","removeResource","gcData","last","lastResource","addResourceHash","context","hash","sort","a","b","managedResourceHashes","hashEntry","runOnHash","writeIndex","runOnResource","updateRenderableGCTick","currentTick","autoGarbageCollect","unload","_createHashClone","hashValue","stopKey","hashClone","k","nullCount","key","GCSystem","GlobalUniformSystem","_stackIndex","_globalUniformDataStack","_uniformsPool","_activeUniforms","_bindGroupPool","_activeBindGroups","bind","projectionMatrix","currentGlobalUniformData","projectionData","Point","globalUniformData","bindGroup","uniformGroup","_createUniforms","uProjectionMatrix","uResolution","uWorldTransformMatrix","uWorldColorAlpha","getUniformBindGroup","BindGroup","setResource","_currentGlobalUniformData","isStatic","SchedulerSystem","_tasks","_offset","Ticker","system","_update","func","duration","useOffset","id","splice","task","elapsed","remove","saidHello","HelloSystem","hello","webGLVersion","getNavigator","userAgent","toLowerCase","indexOf","args","globalThis","sayHello","cleanHash","clean","cleanHash2","cleanArray","arr","renderableGCTick","_RenderableGCSystem","_managedRenderables","_managedHashes","_managedArrays","renderableGCMaxUnusedTime","renderableGCFrequency","renderableGCActive","_hashHandler","_arrayHandler","array","addManagedHash","addManagedArray","_now","_lastUsed","_removeRenderable","managedRenderables","rp","RenderableGCSystem","_TextureGCSystem","count","checkCount","_checkCount","deprecation","maxIdle","gc","checkCountMax","floor","_value","active","textureGCActive","textureGCMaxIdle","textureGCCheckCountMax","textureGCAMaxIdle","TextureGCSystem","_ViewSystem","autoDensity","screen","createCanvas","getCanvasTexture","transparent","desiredScreenWidth","desiredScreenHeight","removeView","parentNode","SharedSystems","SharedRenderPipes","color32BitToUniform","abgr","out","textureBit","textureBitGl","createUboSyncFunction","uboElements","parserCode","arrayGenerationFunction","singleSettersMap","funcFragments","prev","uboElement","data","parsed","test","ubo","template","fragmentSrc","Function","_Filter","_state","padding","blendRequired","gpu","gl","UboSystem","_syncFunctionHash","_systemCheck","ensureUniformGroup","uniformData","getUniformGroupData","layout","usage","UNIFORM","COPY_DST","_signature","_initUniformGroup","uniformGroupSignature","elements","keys","uniformStructures","createUboElements","syncFunction","_generateUboSync","generateUboSync","syncUniformGroup","uniformGroupData","dataInt32","updateUniformGroup","_dirtyId","synced","ensureAttributes","extractedData","attributes","attribute","attributeData","instance","tempStride","tempStart","stride","ensureStartAndStride","RenderTargetSystem","rootViewPort","viewport","onRenderTargetChange","SystemRunner","defaultClearColor","_renderSurfaceToRenderTargetHash","Map","_gpuRenderTargetHash","_renderTargetStack","renderableGC","renderStart","rootRenderTarget","renderingToScreen","HTMLCanvasElement","contains","isRenderingToScreen","renderSurface","getRenderTarget","gpuRenderTarget","getGpuRenderTarget","resizeGpuRenderTarget","pm","flipY","sign","d","calculateProjection","startRenderPass","ALL","contextChange","currentRenderTargetData","isTexture","_initRenderTarget","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","min","CanvasSource","delete","destroyGpuRenderTarget","initGpuRenderTarget","resetState","blendModeIds","normal","multiply","overlay","erase","_State","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","default2d","uniformParsers","uniform","red","topology","packAsQuad","_attributeStart","_batch","canvasCache","onDestroy","register"],"ignoreList":[],"sourceRoot":""}